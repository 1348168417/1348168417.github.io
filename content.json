[{"title":"VUE项目搭建","date":"2017-06-29T14:38:21.000Z","path":"2017/06/29/VUE项目搭建/","text":"备忘！vue项目搭建流程node -v (查看node的版本，基于4.0以上)。npm install -g vue-cli (下载脚手架)。vue (查看是否成功)。vue list (查看vue的组件列表)。vue init webpack PorjectName (基于webpack环境搭建名字为PorjectName的项目)。12345678910111213141516171819202122232425262728? Project name (sell)? Project name sell? Project description (A Vue.js project) sell app? Project description sell app? Author (1348168417 &lt;1348168417@qq.com&gt;)? Author 1348168417 &lt;1348168417@qq.com&gt;? Vue build standalone? Install vue-router? (Y/n) y? Install vue-router? Yes? Use ESLint to lint your code? (Y/n)? Use ESLint to lint your code? Yes? Pick an ESLint preset (Use arrow keys)? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? (Y/n) n? Setup unit tests with Karma + Mocha? No? Setup e2e tests with Nightwatch? (Y/n) n? Setup e2e tests with Nightwatch? No vue-cli · Generated \"sell\". To get started: cd sell npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpackls ls (查看当前目录，可发现有PorjectName)。cnpm install (下载依赖)。npm run dev (启动端口默认8080)。","tags":[]},{"title":"治愈系git_命令清单","date":"2017-06-03T14:49:55.000Z","path":"2017/06/03/治愈系git-命令清单/","text":"常用 Git 命令清单作者： 阮一峰日期： 2015年12月 9日我每天使用 Git ，但是很多命令记不住。一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他123# 生成一个可供发布的压缩包$ git archive（完）","tags":[]},{"title":"MongoDB_安装及配置","date":"2017-06-01T15:44:28.000Z","path":"2017/06/01/MongoDB-安装及配置/","text":"MongoDB 下载：https://www.mongodb.com/download-center#community MongoDB 安装配置：备注：记得加入环境变量，指定绝对路径，最好是以超级管理员运行cmd1、进入mongodb 下的目录E:\\Tool\\modb&gt;在目录下新建 db 目录 log 目录 在log 目录下新建mongodb.log 文件 2、指定日志文件目录1E:\\Tool\\modb\\bin&gt;mongod --logpath \"E:\\Tool\\modb\\log\\mongodb.log\"指定数据存放目录 3、指定数据存放目录1E:\\Tool\\modb\\bin&gt;mongod --dbpath \"E:\\Tool\\modb\\db\" 123456789101112131415161718192021222324252627282930312017-04-09T10:45:31.583+0800 I CONTROL [initandlisten] MongoDB starting : pid=12244 port=27017 dbpath=E:\\Tool\\modb\\db 64-bit host=JSB0152017-04-09T10:45:31.584+0800 I CONTROL [initandlisten] targetMinOS: Windows Vista/Windows Server 20082017-04-09T10:45:31.587+0800 I CONTROL [initandlisten] db version v3.4.32017-04-09T10:45:31.587+0800 I CONTROL [initandlisten] git version: f07437fb5a6cca07c10bafa78365456eb1d6d5e12017-04-09T10:45:31.588+0800 I CONTROL [initandlisten] allocator: tcmalloc2017-04-09T10:45:31.589+0800 I CONTROL [initandlisten] modules: none2017-04-09T10:45:31.590+0800 I CONTROL [initandlisten] build environment:2017-04-09T10:45:31.590+0800 I CONTROL [initandlisten] distarch: x86_642017-04-09T10:45:31.591+0800 I CONTROL [initandlisten] target_arch: x86_642017-04-09T10:45:31.592+0800 I CONTROL [initandlisten] options: &#123; storage: &#123; dbPath: \"E:\\Tool\\modb\\db\" &#125; &#125;2017-04-09T10:45:31.600+0800 I STORAGE [initandlisten] wiredtiger_open config: create,cache_size=3518M,session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),checkpoint=(wait=60,log_size=2GB),statistics_log=(wait=0),2017-04-09T10:45:31.630+0800 I CONTROL [initandlisten]2017-04-09T10:45:31.630+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-04-09T10:45:31.631+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-04-09T10:45:31.632+0800 I CONTROL [initandlisten]2017-04-09T10:45:32.047+0800 I FTDC [initandlisten] Initializing full-time diagnostic data capture with directory 'E:/Tool/modb/db/diagnostic.data'2017-04-09T10:45:32.058+0800 I INDEX [initandlisten] build index on: admin.system.version properties: &#123; v: 2, key: &#123; version: 1 &#125;, name: \"incompatible_with_version_32\", ns: \"admin.system.version\" &#125;2017-04-09T10:45:32.058+0800 I INDEX [initandlisten] building index using bulk method; build may temporarily use up to 500 megabytes of RAM2017-04-09T10:45:32.061+0800 I INDEX [initandlisten] build index done. scanned 0 total records. 0 secs2017-04-09T10:45:32.063+0800 I COMMAND [initandlisten] setting featureCompatibilityVersion to 3.42017-04-09T10:45:32.064+0800 I NETWORK [thread1] waiting for connections on port 270172017-04-09T10:47:24.020+0800 I CONTROL [thread2] Ctrl-C signal2017-04-09T10:47:24.020+0800 I CONTROL [consoleTerminate] got CTRL_C_EVENT, will terminate after current cmd ends2017-04-09T10:47:24.028+0800 I NETWORK [consoleTerminate] shutdown: going to close listening sockets...2017-04-09T10:47:24.030+0800 I NETWORK [consoleTerminate] closing listening socket: 4642017-04-09T10:47:24.032+0800 I NETWORK [consoleTerminate] shutdown: going to flush diaglog...2017-04-09T10:47:24.034+0800 I FTDC [consoleTerminate] Shutting down full-time diagnostic data capture2017-04-09T10:47:24.043+0800 I STORAGE [consoleTerminate] WiredTigerKVEngine shutting down2017-04-09T10:47:24.164+0800 I STORAGE [consoleTerminate] shutdown: removing fs lock...2017-04-09T10:47:24.165+0800 I CONTROL [consoleTerminate] now exiting2017-04-09T10:47:24.171+0800 I CONTROL [consoleTerminate] shutting down with code:12 4、连接数据库12345678E:\\Tool\\modb\\bin&gt;mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:270172017-04-09T10:47:38.944+0800 W NETWORK [thread1] Failed to connect to 127.0.0.1:27017 after 5000ms milliseconds, giving up.2017-04-09T10:47:38.946+0800 E QUERY [thread1] Error: couldn't connect to server 127.0.0.1:27017, connection attempt failed :connect@src/mongo/shell/mongo.js:237:13@(connect):1:6exception: connect failed 5、从新打开一个终端, 安装MongoDB服务1E:\\Tool\\modb&gt;cd bin 12E:\\Tool\\modb\\bin&gt;mongod --dbpath \"E:\\Tool\\modb\" --logpath \"E:\\Tool\\modb\\log\\mongodb.log\" --install --serviceName \"MongoDB\"2017-04-09T11:01:31.833+0800 I CONTROL [main] log file \"E:\\Tool\\modb\\log\\mongodb.log\" exists; moved to \"E:\\Tool\\modb\\log\\mongodb.log.2017-04-09T03-01-31\". 123E:\\Tool\\modb\\bin&gt;net start MongoDBMongoDB 服务正在启动 .MongoDB 服务已经启动成功。 123456789101112131415E:\\Tool\\modb\\bin&gt;mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3Welcome to the MongoDB shell.For interactive help, type \"help\".For more comprehensive documentation, see http://docs.mongodb.org/Questions? Try the support group http://groups.google.com/group/mongodb-userServer has startup warnings:2017-04-09T11:02:18.826+0800 I CONTROL [initandlisten]2017-04-09T11:02:18.826+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-04-09T11:02:18.826+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-04-09T11:02:18.826+0800 I CONTROL [initandlisten] 连接上了———————","tags":[]},{"title":"安装及配置","date":"2017-06-01T15:40:21.000Z","path":"2017/06/01/安装及配置/","text":"","tags":[]},{"title":"浅谈Java面向对象","date":"2017-05-29T02:53:38.000Z","path":"2017/05/29/浅谈Java面向对象/","text":"Java面向对象详解 前言：接触项目开发也有很长一段时间了，最近开始萌发出想回过头来写写以前学过的基础知识的想法。一是原来刚开始学习接触编程，一个人跌跌撞撞摸索着往前走，初学的时候很多东西理解的也懵懵懂懂，后来实践的多了，有些东西才慢慢清楚；二是经过一定的实践之后，反过头来再去学习一些基础东西才能够理解的更透彻；三是有些东西基础但是确很重要，是值得好好搞一搞的。 1、面向对象 面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。 2、对象 对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。 类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除。 当不存在对一个对象的引用时，该对象成为一个无用对象。Java的垃圾收集器自动扫描对象的动态内存区，把没有引用的对象作为垃圾收集起来并释放。当系统内存用尽或调用System.gc( )要求垃圾回收时，垃圾回收线程与系统同步运行。 3、类 类是具有相同属性和方法的一组对象的集合，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性和方法两个主要部分。 Java中的类实现包括两个部分：类声明和类体。 类声明 11[public][abstract|final] class className [extends superclassName] [implements interfaceNameList]&#123;……&#125; 其中，修饰符public,abstract,final 说明了类的属性，className为类名，superclassName为类的父类的名字，interfaceNameList为类所实现的接口列表。 类体 123456class className&#123; [public | protected | private ] [static] [final] [transient] [volatile] type variableName;//成员变量 [public | protected | private ] [static] [final | abstract] [native] [synchronized] returnType methodName([paramList]) [throws exceptionList]&#123; statements &#125;//成员方法&#125; 成员变量限定词的含义： static: 静态变量（类变量） final: 常量；transient: 暂时性变量，用于对象存档，用于对象的串行化 volatile: 贡献变量，用于并发线程的共享 方法的实现也包括两部分内容：方法声明和方法体。 方法声明 方法声明中的限定词的含义： static: 类方法，可通过类名直接调用 abstract: 抽象方法，没有方法体 final: 方法不能被重写 native: 集成其它语言的代码 synchronized: 控制多个并发线程的访问 方法声明包括方法名、返回类型和外部参数。其中参数的类型可以是简单数据类型，也可以是复合数据类型（又称引用数据类型）。 对于简单数据类型来说，java实现的是值传递，方法接收参数的值，但不能改变这些参数的值。如果要改变参数的值，则用引用数据类型，因为引用数据类型传递给方法的是数据在内存中的地址，方法中对数据的操作可以改变数据的值。 方法体 方法体是对方法的实现，它包括局部变量的声明以及所有合法的Java指令。方法体中声明的局部变量的作用域在该方法内部。若局部变量与类的成员变量同名，则类的成员变量被隐藏。 为了区别参数和类的成员变量，我们必须使用this。this用在一个方法中引用当前对象，它的值是调用该方法的对象。返回值须与返回类型一致，或者完全相同，或是其子类。当返回类型是接口时，返回值必须实现该接口。 构造方法构造方法是一个特殊的方法。Java 中的每个类都有构造方法，用来初始化该类的一个对象。构造方法具有和类名相同的名称，而且不返回任何数据类型。重载经常用于构造方法。构造方法只能由new运算符调用 4、面向对象的基本特性封装 封装性就是尽可能的隐藏对象内部细节，对外形成一道边界，只保留有限的接口和方法与外界进行交互。封装的原则是使对象以外的部分不能随意的访问和操作对象的内部属性，从而避免了外界对对象内部属性的破坏。 可以通过对类的成员设置一定的访问权限，实现类中成员的信息隐藏。 private：类中限定为private的成员，只能被这个类本身访问。如果一个类的构造方法声明为private,则其它类不能生成该类的一个实例。 default：类中不加任何访问权限限定的成员属于缺省的（default）访问状态，可以被这个类本身和同一个包中的类所访问。 protected：类中限定为protected的成员，可以被这个类本身、它的子类（包括同一个包中以及不同包中的子类）和同一个包中的所有其他的类访问。 public：类中限定为public的成员，可以被所有的类访问。 继承 子类的对象拥有父类的全部属性与方法，称作子类对父类的继承。 Java中父类可以拥有多个子类，但是子类只能继承一个父类，称为单继承。继承实现了代码的复用。 Java中所有的类都是通过直接或间接地继承java.lang.Object类得到的。 子类不能继承父类中访问权限为private的成员变量和方法。 子类可以重写父类的方法，即命名与父类同名的成员变量。 Java中通过super来实现对父类成员的访问，super用来引用当前对象的父类。super 的使用有三种情况： 访问父类被隐藏的成员变量，如：super.variable; 调用父类中被重写的方法，如：super.Method([paramlist]),super()调用父类构造方法; 调用父类的构造函数，如：super([paramlist]);多态 对象的多态性是指在父类中定义的属性或方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或方法在父类及其各个子类中具有不同的语义。例如：”几何图形”的”绘图”方法，”椭圆”和”多边形”都是”几何图”的子类，其”绘图”方法功能不同。 Java的多态性体现在两个方面：由方法重载实现的静态多态性（编译时多态）和方法重写实现的动态多态性（运行时多态）。 编译时多态：在编译阶段，具体调用哪个被重载的方法，编译器会根据参数的不同来静态确定调用相应的方法。 运行时多态：由于子类继承了父类所有的属性（私有的除外），所以子类对象可以作为父类对象使用。程序中凡是使用父类对象的地方，都可以用子类对象来代替。一个对象可以通过引用子类的实例来调用子类的方法。 重载（Overloading） 方法重载是让类以统一的方式处理不同数据类型的手段。 一个类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法。 返回值类型可以相同也可以不相同，无法以返回型别作为重载函数的区分标准。 重写（Overriding） 子类对父类的方法进行重新编写。如果在子类中的方法与其父类有相同的的方法名、返回类型和参数表，我们说该方法被重写 (Overriding)。 如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。 子类函数的访问修饰权限不能低于父类的。","tags":[]},{"title":"如何摆脱项目命名困难的尴尬局面面_治愈系","date":"2017-05-26T12:16:22.000Z","path":"2017/05/26/如何摆脱项目命名困难的尴尬局面面-治愈系/","text":"如何高效的命名你的项目。在做一个项目的时候，我们往往遭遇命名问题的困惑，当看到一些非专业人的代码，看到他们凌乱的码法，有时候真的苦不堪言。深刻知道一个良好的命名规范的重要性，同时在项目中也会遇到一些命名的瓶颈。所以有必要写一篇关于常见命名的方式。以下是通过3年的编程经验，以及参考网上知名的开源项目总结的一点经验。希望共勉 1.文件夹命名 (1)最好用一个单词描述 常用项目命名 omi、element、master、project、test、vue、iview二级目录 build、static、config、src、examples、base、common、issues、assert三级目录 libs、models、plugins、skins、images、css、js (2))如果一个单词描述不了，用2个词（名词加动词） color-pick、button-groups、date-picker、option-grounp、jquery-select、jquery-swiper (3)中间用-或者_连接为了方便归类、一目了然 node_models、async-demo、array-union、array-differ、babel-each 2.文件命名 (1).最好用一个单词描述 以下变量名可以加css、js、html，例如index.html、index.js、index.css 常用组件命名 index、message、menu、slider（滑块）、page、progress（进度条）、tooltip（提示）、tree、upload、time、button、checkbox、dialog、cascader（三级联动）常用文件命名 index、shopping（购物）、 share（分享）、integral（积分）、advertisement（广告）、pay（支付）、community（社区）、game、docs、bussiness (2)如果一个单词描述不了，用2个词（名词加动词） share-to-friends，share-to-community，weex-pay，alipay-pay，user-integral，game-page，docs-page等等反正就是自我想象 (3)中间用-或者_连接为了方便归类、一目了然 在目前做的pc端和移动端，简单的对他们分个类： 移动广告(mobile-advertisement)移动社交(mobile-social)移动电子商务(mobile-bussiness)手机游戏(mobile-game)手机电视(mobile-tv)移动电子阅读(mobile-reading)手机搜索(mobile-search)移动支付(mobile-pay)手机内容共享(mobile-share)关于以上的项目都可以用名词+需要的动词命名，达到见词知意 3.html布局命名可以参考DIV+CSS规范命名大全集合但是我觉得写的并不是很好，很全面。因为往往比较纠结的是每一个大布局中小布局的命名。 外套 wrap #container头部 header #head, #header，#nav，#sub-nav，#menu， #sub-menu，#branding主要内容 main bussiness-title 、bussiness-logo、bussiness-search、bussiness-search-results左侧 main-left #side-bar, #side-bar-a, #side-bar-b右侧 main-right #side-bar, #side-bar-a, #side-bar-b内容 content radio-click、radio-heightlight、radio-active、input-seach-off、input-search-on底部 footer #service, #regsiter,#partner（合作伙伴）,#joinus, #site-info总结 (1)一般头部有nav、nav-event、nav-style、nav-item、nav-link。 (2)内容：xx-title、xx-box、xx-warp、xx-item、xx-item-title、xx-item-link、xx-item-image (3)底部：footer-time、footer-box、footer-item、footer-item-link、footer-address。总之xx-wrap，xx-box，xx-item、xx-link、xx-title、xx-total肯定会满足你80%的需求 4.js变量命名 (1)基础类型和引用数据类型 基础类型字符串var s_count=”“,布尔类型var b_status=false,数字类型var n_total=12。引用数据类型数组var ar_bar=[],对象var o_bar={},函数var f_submit=function(){} (2)不要用关键字命名default、class、private (3)用可读的同义词代替保留词。 123456789101112// badvar superman = &#123; class: 'alien'&#125;;// badvar superman = &#123; klass: 'alien'&#125;;// goodvar superman = &#123; type: 'alien'&#125;; (4)函数用驼峰形式（动词+名词） login(),logout(),expandList(),getTotal(),keySearch(),submitForm(),cancel(),goMore(),searchAll&gt;(),searchCurrent().clearContent().uploadImage().searchResult()这些都是常用事件，可以清晰知道每一项的意义。 (5)当命名的构造函数和类使用PascalCase。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;);6)不要使用尾随或前导下划线// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda';7)前缀jQuery对象变量与$// badvar sidebar = $('.sidebar');// goodvar $sidebar = $('.sidebar');// bad$('ul', '.sidebar').hide();// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125;// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); 5.css命名公共的 common.css其实和common差不多 base.css动画 animation.css皮肤 skin.css文字 font.css主题 themes.css打印样式 print.css颜色 color.css 6.图片命名 (1)第一部分是图片的逻辑归属分类 (2)第二部分是图片的表现内容 (3)第三部分是图片的内容的类型（有些图片还会有第四部分，表示图片表现的状态。） (4)tabbar_home_icon, navigationbar_showtime_icon@2x.png，tabbar_categories_icon ￼ 7.分享demo (1)饿了么部分组织构架 ￼ (2)腾讯omi￼","tags":[]},{"title":"整理了一些最近的知识_JavaScript","date":"2017-05-25T15:34:29.000Z","path":"2017/05/25/整理了一些最近的知识-JavaScript/","text":"JavaScript 介绍js的基本数据类型。 123 Undefined、Null、Boolean、Number、String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 12数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error 说几条写JavaScript的基本规范？ 1234567891.不要在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 JavaScript原型，原型链 ? 有什么特点？ 123456789101112131415161718192021每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。关系：instance.constructor.prototype = instance.__proto__特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话， 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。 function Func()&#123;&#125; Func.prototype.name = \"Sean\"; Func.prototype.getInfo = function() &#123; return this.name; &#125; var person = new Func();//现在可以参考var person = Object.create(oldObject); console.log(person.getInfo());//它拥有了Func的属性和方法 //\"Sean\" console.log(Func.prototype); // Func &#123; name=\"Sean\", getInfo=function()&#125; JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 123456栈：原始数据类型（Undefined，Null，Boolean，Number、String）堆：引用数据类型（对象、数组和函数）两种类型的区别是：存储位置不同；原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 如何将字符串转化为数字，例如’12.3b’? parseFloat(‘12.3b’); 正则表达式，’12.3b’.match(/(\\d)+(.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』? 1234567function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d&#123;3&#125;)+\\.)/g, function($1, $2)&#123; return $2 + ','; &#125;);&#125; 如何实现数组的随机排序？方法一： var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort1(arr)&#123; for(var i = 0,len = arr.length;i < len; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr; &#125; console.log(randSort1(arr));1234567891011121314```方法二： ```javascript var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort2(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray; &#125; console.log(randSort2(arr)); 方法三： 12345var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); Javascript如何实现继承？ 1、构造继承2、原型继承3、实例继承4、拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。 123456789101112function Parent()&#123; this.name = 'wang';&#125;function Child()&#123; this.age = 28;&#125;Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性 JavaScript继承的几种实现方式？ 参考：构造函数的继承，非构造函数的继承； javascript创建对象的几种方式？ javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。 1、对象字面量的方式 person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;}; 2、用function来模拟无参的构造函数 function Person(){} var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class person.name=&quot;Mark&quot;; person.age=&quot;25&quot;; person.work=function(){ alert(person.name+&quot; hello...&quot;); } person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） function Pet(name,age,hobby){ this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function(){ alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); } } var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象 maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象） var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function(){ alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); } wcDog.work(); 5、用原型方式来创建 function Dog(){ } Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function(){ alert(this.name+&quot;是个吃货&quot;); } var wangcai =new Dog(); wangcai.eat(); 6、用混合方式来创建 function Car(name,price){ this.name=name; this.price=price; } Car.prototype.sell=function(){ alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); } var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell(); Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。 谈谈This对象的理解。 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’); 什么是window对象? 什么是document对象? window对象是指浏览器打开的窗口。document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。 null，undefined 的区别？ null 表示一个对象是“没有值”的值，也就是值为“空”；undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是；undefined的类型(typeof)是undefined；null的类型(typeof)是object； Javascript将未赋值的变量默认值设为undefined； Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 typeof undefined //“undefined” undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined typeof null //“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined null == undefined // true null === undefined // false 再来一个例子： null Q：有张三这个人么？ A：有！ Q：张三有房子么？ A：没有！ undefined Q：有张三这个人么？ A：有！ Q: 张三有多少岁？ A: 不知道（没有被告诉） 参考阅读：undefined与null的区别 写一个通用的事件侦听器函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyunmarkyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;; [“1”, “2”, “3”].map(parseInt) 答案是多少？ parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。 function parseInt(str, radix) { return str+’-‘+radix;};var a=[“1”, “2”, “3”];a.map(parseInt); // [“1-0”, “2-1”, “3-2”] 不能大于radix 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN所以[“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN] 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件； ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 闭包的特性： 1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收 1234567891011121314151617//li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id=\"testUL\"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; var nodes = document.getElementsByTagName(\"li\"); for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125;&lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源因为say667()的内部函数的执行需要依赖say667()中的变量这是对闭包作用的非常直白的描述 function say667() { // Local variable that ends up within closure var num = 666; var sayAlert = function() { alert(num); } num++; return sayAlert;} var sayAlert = say667();sayAlert()//执行结果应该弹出的667 javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。 如何判断一个对象是否属于某个类？ 使用instanceof （待完善） if(a instanceof Person){ alert(&apos;yes&apos;); } new操作符具体干了什么呢? 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 var obj = {};obj.proto = Base.prototype;Base.call(obj); 用原生JavaScript的实现过什么功能吗？ Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ hasOwnProperty javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。使用方法：object.hasOwnProperty(proName)其中参数object是必选项。一个对象的实例。proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 JSON 的了解？JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小如：{“age”:”12”, “name”:”back”} JSON字符串转换为JSON对象:var obj =eval(‘(‘+ str +’)’);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串：var last=obj.toJSONString();var last=JSON.stringify(obj); js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么? 如何创建一个Ajax？ ajax的全称：Asynchronous Javascript And XML。异步传输+js+xml。所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息(3)设置响应HTTP请求状态变化的函数(4)发送HTTP请求(5)获取异步调用返回的数据(6)使用JavaScript和DOM实现局部刷新 Ajax 解决浏览器缓存问题？ 1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3、在URL后面加上一个随机数： “fresh=” + Math.random();。 4、在URL后面加上时间搓：”nowtime=” + new Date().getTime();。 5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 同步和异步的区别? 同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性. 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。 （待完善） 如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 页面编码和被请求的资源编码如果不一致如何处理？ 模块化开发怎么做？ 立即执行函数,不暴露私有成员 var module1 = (function(){ var _count = 0; var m1 = function(){ //... }; var m2 = function(){ //... }; return { m1 : m1, m2 : m2 }; })(); （待完善） AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMDCMD 规范在这里：https://github.com/seajs/seajs/issues/242 Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。 区别： 1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. 2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： // CMD define(function(require, exports, module) { var a = require(‘./a’) a.doSomething() // 此处略去 100 行 var b = require(‘./b’) // 依赖可以就近书写 b.doSomething() // … }) // AMD 默认推荐 define([‘./a’, ‘./b’], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // … }) requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？） 参考：http://annn.me/how-to-realize-cmd-loader/ JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？ 谈一谈你对ECMAScript6的了解？ ECMAScript6 怎么写class么，为什么会出现class这种东西? 异步加载JS的方式有哪些？ (1) defer，只支持IE (2) async： (3) 创建script，插入到DOM中，加载完毕后callBackdocumen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点? （1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点（2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点（3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 .call() 和 .apply() 的区别？ 例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 function add(a,b){ alert(a+b); } function sub(a,b){ alert(a-b); } add.call(sub,3,1); 数组和对象有哪些原生方法，列举一下？ JS 怎么实现一个类。怎么实例化这个类 JavaScript中的作用域与变量声明提升？ 如何编写高性能的Javascript？ 那些操作会造成内存泄漏？ JQuery的源码看过吗？能不能简单概况一下它的实现原理？ jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？ jquery中如何将数组转化为json字符串，然后再转化回来？ jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ jquery.extend 与 jquery.fn.extend的区别？ jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 jquery.fn.extend:源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数使用：jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。 jQuery 的队列是如何实现的？队列可以用在哪些地方？ 谈一下Jquery中的bind(),live(),delegate(),on()的区别？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？ jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle） 针对 jQuery性能的优化方法？ Jquery与jQuery UI 有啥区别？ *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。 *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 JQuery的源码看过吗？能不能简单说一下它的实现原理？ jquery 中如何将数组转化为json字符串，然后再转化回来？ jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展： $.fn.stringifyArray = function(array) { return JSON.stringify(array) } $.fn.parseArray = function(array) { return JSON.parse(array) } 然后调用： $(“”).stringifyArray(array) jQuery和Zepto的区别？各自的使用场景？ 针对 jQuery 的优化方法？ *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。比如：var str=$(“a”).attr(“href”); *for (var i = size; i &lt; arr.length; i++) {}for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：for (var i = size, length = arr.length; i &lt; length; i++) {} Zepto的点透问题如何解决？ jQueryUI如何自定义组件? 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？ 如何判断当前脚本运行在浏览器还是node环境中？（阿里） this === window ? ‘browser’ : ‘node’; 通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中移动端最小触控区域是多大？ jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? jquery stop(): 如：$(“#div”).stop().animate({width:”100px”},100); 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。） 知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么? Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？ 解释JavaScript中的作用域与变量声明提升？ 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 多个事件同一个函数：$(“div”).on(“click mouseover”, function(){}); 多个事件不同函数$(“div”).on({click: function(){}, mouseover: function(){} }); Node.js的适用场景？ (如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么? 解释一下 Backbone 的 MVC 实现方式？ 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点? 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么? Chrome,Safari浏览器内核。 如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)? 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用? 简述一下 Handlebars 的基本用法？ 简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？ 用js实现千位分隔符?(来源：前端农民工，提示：正则+replace) 参考：http://www.tuicool.com/articles/ArQZfuifunction commafy(num) { return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d{3})+\\.)/g, function($0, $1) { return $1 + &quot;,&quot;; }); }console.log(commafy(1234567.90)); //1,234,567.90 检测浏览器版本版本有哪些方式？ 功能检测、userAgent特征检测 比如：navigator.userAgent//“Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36” What is a Polyfill? polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？ 比如： html5shiv、Geolocation、Placeholder 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？ 使用JS实现获取文件扩展名？ function getFileExtension(filename) { return filename.slice((filename.lastIndexOf(“.”) - 1 &gt;&gt;&gt; 0) + 2); } String.lastIndexOf() 方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。 对于’filename’和’.hiddenfile’，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。 String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为””。 ECMAScript6 相关 Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ 两等号判等，会在比较时进行类型转换；三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true. Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。前端框架相关 react-router 路由系统的实现原理？ React中如何解决第三方类库的问题? 其他问题 原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？ 你遇到过比较难的技术问题是？你是如何解决的？ 设计模式 知道什么是singleton, factory, strategy, decrator么? 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？ 页面重构怎么操作？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面 减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写)采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存 列举IE与其他浏览器不一样的特性？ 1、事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()； 99%的网站都需要被重构是那本书上写的？ 网站重构：应用web标准进行设计（第2版） 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验； 是否了解公钥加密和私钥加密。 一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。 WEB应用从服务器主动推送Data到客户端有那些方式？ html5提供的Websocket不可见的iframeWebSocket通过FlashXHR长时间连接XHR Multipart Streaming标签的长时间连接(可跨域) 对Node的优点和缺点提出了自己的看法？ *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 你有用过哪些前端性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。 http状态码有那些？分别代表是什么意思？ 简单版 [ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ] 完整版 1**(信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 2**(响应成功)：表示动作被成功接收、理解和接受 200——表明该请求被成功地完成，所请求的资源发送回客户端 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 3**(重定向类)：为了完成指定的动作，必须接受进一步处理 300——请求的资源可在多处得到 301——本网页被永久性转移到另一个URL 302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。 303——建议客户访问其他URL或访问方式 304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 4**(客户端错误类)：请求包含错误语法或不能正确执行 400——客户端请求有语法错误，不能被服务器所理解 401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 HTTP 401.1 - 未授权：登录失败 HTTP 401.2 - 未授权：服务器配置问题导致登录失败 HTTP 401.3 - ACL 禁止访问资源 HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 402——保留有效ChargeTo头响应 403——禁止访问，服务器收到请求，但是拒绝提供服务 HTTP 403.1 禁止访问：禁止可执行访问 HTTP 403.2 - 禁止访问：禁止读访问 HTTP 403.3 - 禁止访问：禁止写访问 HTTP 403.4 - 禁止访问：要求 SSL HTTP 403.5 - 禁止访问：要求 SSL 128 HTTP 403.6 - 禁止访问：IP 地址被拒绝 HTTP 403.7 - 禁止访问：要求客户证书 HTTP 403.8 - 禁止访问：禁止站点访问 HTTP 403.9 - 禁止访问：连接的用户过多 HTTP 403.10 - 禁止访问：配置无效 HTTP 403.11 - 禁止访问：密码更改 HTTP 403.12 - 禁止访问：映射器拒绝访问 HTTP 403.13 - 禁止访问：客户证书已被吊销 HTTP 403.15 - 禁止访问：客户访问许可过多 HTTP 403.16 - 禁止访问：客户证书不可信或者无效 HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。 5**(服务端错误类)：服务器不能正确执行一个正确的请求 HTTP 500 - 服务器遇到错误，无法完成请求 HTTP 500.100 - 内部服务器错误 - ASP 错误 HTTP 500-11 服务器关闭 HTTP 500-12 应用程序重新启动 HTTP 500-13 - 服务器太忙 HTTP 500-14 - 应用程序无效 HTTP 500-15 - 不允许请求 global.asa Error 501 - 未实现 HTTP 502 - 网关错误 HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等； 详细版： 1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 4、进行HTTP协议会话，客户端发送报头(请求报头); 5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？ 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决? 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？ 你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ Sublime Text 3 + 相关插件编写前端代码 Google chrome 、Mozilla Firefox浏览器 +firebug 兼容测试和预览页面UI、动画效果和交互功能 Node.js+Gulp git 用于版本控制和Code Review对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。你怎么看待Web App 、hybrid App、Native App？ 你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？） 你对加班的看法？ 加班就像借钱，原则应当是——救急不救穷平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理如何设计突发大规模并发架构？ 当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？ 说说最近最流行的一些东西吧？常去哪些网站？ ES6\\WebAssembly\\Node\\MVVM\\Web Components\\React\\React Native\\Webpack 组件化 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么? 移动端（Android IOS）怎么做好用户体验? 清晰的视觉纵线、 信息的分组、极致的减法、 利用选择代替输入、 标签及文字的排布方式、 依靠明文确认密码、 合理的键盘利用、简单描述一下你做过的移动APP项目研发流程？ 你在现在的团队处于什么样的角色，起到了什么明显的作用？ 你认为怎样才是全端工程师（Full Stack developer）？ 介绍一个你最得意的作品吧？ 你有自己的技术博客吗，用了哪些技术？ 对前端安全有什么看法？ 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？ 项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。 最近在学什么东西？ 你的优点是什么？缺点是什么？ 如何管理前端团队? 最近在学什么？能谈谈你未来3，5年给自己的规划吗？","tags":[]},{"title":"整理了一些最近的知识_HTML","date":"2017-05-25T15:33:46.000Z","path":"2017/05/25/整理了一些最近的知识-HTML/","text":"12345678910HTML&amp;CSS： 对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、 HTML5、CSS3、FlexboxJavaScript： 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、 DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs其他： 移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力 1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。10、JSON —— 作用、用途、设计结构。 备注：根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。更新记录：2017年5月25日：整理了最近的一些HTML、CSS、JavaScript的知识点 HTML Doctype作用？标准模式于建嵘模式各有什么区别？ 12(1) &lt;!Doctype&gt; 位于HTML标签的第一行，处于HTML标签之前，告知浏览器的解析器用什么文档标准解析这个文档DOCTYPE不存在或格式不正确导致文档以兼容模式呈现。(2) 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行在兼容模式中，页面页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;?(1)HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；(2)而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 123456789101112首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 （1）行内元素有：a b span img input select strong（强调的语气） （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素： &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 鲜为人知的是： &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异 参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements 页面导入样式时，使用link和@import有什么区别？ 123(1)link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;(2)页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;(3)import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 介绍一下你对浏览器内核的理解？ 123456主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ 123456 Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html) html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 123456789101112131415161718192021222324* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； * 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 当然也可以直接使用成熟的框架、比如html5shim; &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"&lt;/script&gt; &lt;![endif]--&gt; * 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素 简述一下你对HTML语义化的理解？用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 1、页面头部像下面一样加入一个manifest的属性； 2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭. iframe有那些缺点？ 1234567*iframe会阻塞主页面的Onload事件； *搜索引擎的检索程序无法解读这种页面，不利于SEO; *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么？是怎么用的？ 123456label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;label for=\"Name\"&gt;Number:&lt;/label&gt;&lt;input type=“text“name=\"Name\" id=\"Name\"/&gt;&lt;label&gt;Date:&lt;input type=\"text\" name=\"B\"/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里)WebSocket、SharedWorker；也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； webSocket如何兼容低浏览器？(阿里)Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 如何在页面上实现一个圆形的可点击区域？1、map+area或者svg2、border-radius3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。1&lt;div style=\"height:1px;overflow:hidden;background:red\"&gt;&lt;/div&gt; 如下： 网页验证码是干嘛的，是为了解决什么安全问题。区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容。 i内容展示为斜体，em表示强调的文本； Physical Style Elements – 自然样式标签b, i, u, s, preSemantic Style Elements – 语义样式标签strong, em, ins, del, code应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。","tags":[]},{"title":"整理了一些最近的知识_CSS","date":"2017-05-25T15:33:33.000Z","path":"2017/05/25/整理了一些最近的知识-CSS/","text":"CSS 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？（1）有两种， IE 盒子模型、W3C 盒子模型；（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；（3）区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？ 12345678910111213- 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &gt; li） 6.后代选择器（li a） 7.通配符选择器（ * ） 8.属性选择器（a[rel = \"external\"]） 9.伪类选择器（a:hover, li:nth-child） - 可继承的样式： font-size font-family color, UL LI DL DD DT; - 不可继承的样式：border padding margin width height ; CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; 优先级为:同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。!important &gt; id &gt; class &gt; tagimportant 比 内联优先级高 CSS3新增伪类有那些？举例：p:first-of-type 选择属于其父元素的首个 元素的每个 元素。p:last-of-type 选择属于其父元素的最后 元素的每个 元素。p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。p:only-child 选择属于其父元素的唯一子元素的每个 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。:before 在元素之后添加内容:enabled:disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 如何居中div？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364水平居中：给div设置一个宽度，然后添加margin:0 auto属性 div&#123; width:200px; margin:0 auto; &#125;让绝对定位的div居中 div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */ &#125;水平垂直居中一 确定容器的宽高 宽500 高 300 的层 设置层的外边距 div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */ &#125;水平垂直居中二 未知容器的宽高，利用 `transform` 属性 div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */ &#125;水平垂直居中三 利用 flex 布局 实际使用时应考虑兼容性 .container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125; .container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */ &#125; display有哪些值？说明他们的作用。 1234567block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none 缺省值。象行内元素类型一样显示。inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。list-item 象块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父元素继承 display 属性的值。 position的值relative和absolute定位原点是？absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值。 CSS3有哪些新特性？ 12345678910新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 缩放,定位,倾斜,动画,多背景 例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation: 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。 在布局上有了比以前更加灵活的空间。 用纯CSS创建一个三角形的原理是什么？把上、左、右三条边隐藏掉（颜色设为 transparent）#demo { width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;} 一个满屏 品 字布局 如何设计?简单的方式：上面的div宽100%，下面的两个div分别宽50%，然后用float或者inline使其不换行即可 css多列等高如何实现？利用padding-bottom|margin-bottom正负值相抵；设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ 123456789101112131415161718192021222324252627282930313233343536373839* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. * 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。 * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125; 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb&#123; background-color:red;/*所有识别*/ background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ &#125; * IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。 * IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 * 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 * Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125; li 与li 之间有空格怎么办？行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 为什么要初始化CSS样式。 12345678910111213141516171819202122因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法： * &#123;padding: 0; margin: 0;&#125; （强烈不建议） 淘宝的样式初始化代码： body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; absolute的containing block(容器块)计算方式跟正常流有什么不同？ 无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；2、否则,则由这个祖先元素的 padding box 构成。如果都找不到，则为 initial containing block。 * 补充： static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） absolute: 向上找最近的定位为absolute/relative的元素 fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block＊ CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ 对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同. 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间. ＊ position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠. ＊ 对BFC规范(块级格式化上下文：block formatting context)的理解？ （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。） 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。＊ css定义的权重 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：123456789101112131415161718/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125; 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现请解释一下为什么需要清除浮动？清除浮动的方式 ＊ 清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。123456789101112131415161718192021222324252627282930311、父级div定义height；2、父级div 也一起浮动；3、常规的使用一个class； .clearfix:before, .clearfix:after &#123; content: \" \"; display: table; &#125; .clearfix:after &#123; clear: both; &#125; .clearfix &#123; *zoom: 1; &#125;4、SASS编译的时候，浮动元素的父级div定义伪类:after &amp;:after,&amp;:before&#123; content: \" \"; visibility: hidden; display: block; height: 0; clear: both; &#125;解析原理：1) display:block 使生成的元素以块级元素显示,占满剩余空间;2) height:0 避免生成内容破坏原有布局的高度。3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;4）通过 content:\".\"生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:\".\",有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”\" 仍然会产生额外的空隙；5）zoom：1 触发IE hasLayout。通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。 什么是外边距合并？ 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp zoom:1的清除浮动原理? 清除浮动，触发hasLayout；Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。 来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。 Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。 目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。 移动端的布局用过媒体查询吗？ 假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } 使用 CSS 预处理器吗？喜欢那个？ SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS) CSS优化、提高性能的方法有哪些？ 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 浏览器是怎样解析CSS选择器的？ 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 在网页中的应该使用奇数还是偶数的字体？为什么呢？ margin和padding分别适合什么场景使用？ margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题] 元素竖向的百分比设定是相对于容器的高度吗？ 全屏滚动的原理是什么？用到了CSS的那些属性？ 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？） ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。 想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上 如何修改chrome记住密码后自动填充表单的黄色背景 ？ input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { background-color: rgb(250, 255, 189); / #FAFFBD; / background-image: none; color: rgb(0, 0, 0);} 你对line-height是如何理解的？ 设置元素浮动后，该元素的display值是多少？ 自动变成了 display:block 怎么让Chrome支持小于12px 的文字？ 1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。 让页面里的字体变清晰，变细用CSS怎么做？ -webkit-font-smoothing: antialiased; font-style属性可以让它赋值为“oblique” oblique是什么意思？ 倾斜的字体样式 position:fixed;在android下无效怎么处理？ fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms display:inline-block 什么时候会显示间隙？(携程) 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing overflow: scroll时不能平滑滚动的问题怎么处理？ 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？ 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做） 如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。 同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。 style标签写在body后与body前有什么区别？ 什么是CSS 预处理器 / 后处理器？ 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。","tags":[]},{"title":"好的学习网站","date":"2017-05-20T11:27:26.000Z","path":"2017/05/20/好的学习网站/","text":"51cto专题汇总：http://www.51cto.com/col/35/all.htm Oracle：http://database.51cto.com/art/200511/12457.htm JavaJava集合类源码解读http://blog.csdn.net/column/details/lc-java-collection.html JVM分代垃圾回收策略的基础概念:http://developer.51cto.com/art/201201/312639.htmhttp://developer.51cto.com/art/201001/176550.htm MySQL入门到精通相关：http://database.51cto.com/art/200811/98728.htmhttp://database.51cto.com/art/201007/210727.htmhttp://linux.51yip.com/search/mysqldump TCP/IP（传输入控制地议/网际协议）http://network.51cto.com/art/200701/38863.htm spring技术专题：http://developer.51cto.com/art/200610/33613.htmhttp://developer.51cto.com/art/201206/342959.htm多核平台下的Java优化：http://developer.51cto.com/art/201306/397339.htm Linux:http://vbird.dic.ksu.edu.tw/linux_basic/Mandrake9.0/mandrake9.0.php 图标下载：http://www.easyicon.net/ html教材：http://www.dreamdu.com/xhtml/attribute_cellpadding_cellspacing/ RGB颜色对照：http://www.114la.com/other/rgb.htm w3school:http://www.w3school.com.cn/index.html Extjs:http://dev.sencha.com/extjs/5.1.0/examples/http://extjs.org.cn/examples POI：http://poi.apache.org/download.html#POI-3.10-FINALhttp://www.cnblogs.com/xwdreamer/archive/2011/07/20/2296975.html Fusionchartshttp://www.fusioncharts.com/charts/line-area-charts/ Log4j:http://www.iteye.com/topic/378077 存储：https://community.emc.com/thread/176852https://community.emc.com/community/support/chinese/storagehwhttp://support.huawei.com/ecommunity/bbs/10174443.htmlhttp://support.huawei.com/ecommunity/bbs/10170777.htmlhttp://support.huawei.com/ecommunity/bbs/list_1069,4287.html?dist=1http://blog.163.com/hlz_2599/blog/static/14237847420141610112127/HP的支持中心：http://h20565.www2.hp.com/portal/site/hpsc/template.PAGE/public/kb/search/?javax.portlet.begCacheTok=com.vignette.cachetoken&amp;javax.portlet.endCacheTok=com.vignette.cachetoken&amp;javax.portlet.pbp_89ff4a7dab82d782fcbb0710b053ce01_myAction=withResults&amp;javax.portlet.tpst=89ff4a7dab82d782fcbb0710b053ce01&amp;sp4ts.oid=5386547&amp;ac.admitted=1430724918795.876444892.492883150#searchResultHead SMIS：http://www.ibm.com/developerworks/cn/data/library/techarticles/dm-0901sunhao/http://wbemservices.sourceforge.net/http://www.doc88.com/p-776453718587.html 博科交换机：http://www.doc88.com/p-338761686467.html UML:http://www.cnblogs.com/wangkangluo1/archive/2013/02/21/2920606.html","tags":[]},{"title":"浅谈MyEclipse通过JDBC连接MySQL数据库","date":"2017-05-19T02:00:18.000Z","path":"2017/05/19/浅谈MyEclipse通过JDBC连接MySQL数据库/","text":"1.前提是MyEclipse已经能正常开发Java工程2.安装MySQL个人使用的是版本是 mysql-5.0.22-win32.zip网址：http://www.mysql.com/downloads/mysql/#downloads3.下载JDBC驱动个人使用的是 mysql-connector-java-5.1.22.zip，所需要的就是解压缩之后其中的 mysql-connector-java-5.1.22-bin.jar网址：http://www.mysql.com/downloads/connector/j/4.代码测试复制代码 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package ts.jsj.lyh; import java.sql.*; /** *//** * 使用JDBC连接数据库MySQL的过程 * DataBase：JSJ， table：student； * @author DuChangfeng 2008 09 18 */ public class JDBCTest &#123; public static Connection getConnection() throws SQLException, java.lang.ClassNotFoundException &#123; //第一步：加载MySQL的JDBC的驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //取得连接的url,能访问MySQL数据库的用户名,密码；jsj：数据库名 String url = &quot;jdbc:mysql://localhost:3306/jsj&quot;; String username = &quot;root&quot;; String password = &quot;111&quot;; //第二步：创建与MySQL数据库的连接类的实例 Connection con = DriverManager.getConnection(url, username, password); return con; &#125; public static void main(String args[]) &#123; try &#123; //第三步：获取连接类实例con，用con创建Statement对象类实例 sql_statement Connection con = getConnection(); Statement sql_statement = con.createStatement(); /** *//************ 对数据库进行相关操作 ************/ //如果同名数据库存在，删除 //sql_statement.executeUpdate(&quot;drop table if exists student&quot;); //执行了一个sql语句生成了一个名为student的表 //sql_statement.executeUpdate(&quot;create table student (id int not null auto_increment, name varchar(20) not null default &apos;name&apos;, math int not null default 60, primary key (id) ); &quot;); //向表中插入数据 //sql_statement.executeUpdate(&quot;insert student values(1, &apos;liying&apos;, 98)&quot;); //sql_statement.executeUpdate(&quot;insert student values(2, &apos;jiangshan&apos;, 88)&quot;); //sql_statement.executeUpdate(&quot;insert student values(3, &apos;wangjiawu&apos;, 78)&quot;); //sql_statement.executeUpdate(&quot;insert student values(4, &apos;duchangfeng&apos;, 100)&quot;); //---以上操作不实用，但是列出来作为参考--- //第四步：执行查询，用ResultSet类的对象，返回查询的结果 String query = &quot;select * from student&quot;; ResultSet result = sql_statement.executeQuery(query); /** *//************ 对数据库进行相关操作 ************/ System.out.println(&quot;Student表中的数据如下:&quot;); System.out.println(&quot;------------------------&quot;); System.out.println(&quot;学号&quot; + &quot; &quot; + &quot;姓名&quot; + &quot; &quot; + &quot;数据成绩 &quot;); System.out.println(&quot;------------------------&quot;); //对获得的查询结果进行处理，对Result类的对象进行操作 while (result.next()) &#123; int number = result.getInt(&quot;sno&quot;); String name = result.getString(&quot;sname&quot;); String mathScore = result.getString(&quot;sgrade&quot;); //取得数据库中的数据 System.out.println(&quot; &quot; + number + &quot; &quot; + name + &quot; &quot; + mathScore); &#125; //关闭连接和声明 sql_statement.close(); con.close(); &#125; catch(java.lang.ClassNotFoundException e) &#123; //加载JDBC错误,所要用的驱动没有找到 System.err.print(&quot;ClassNotFoundException&quot;); //其他错误 System.err.println(e.getMessage()); &#125; catch (SQLException ex) &#123; //显示数据库连接错误或查询错误 System.err.println(&quot;SQLException: &quot; + ex.getMessage()); &#125; &#125; &#125; 以上大部分内容整理自网络，感谢猿猿们的无私奉献~~具体的步骤、强大的互联网上都比较容易查询的到，这里不再赘述，现加上几点个人认为需要注意的地方： 1）关于mysql-connector-java-5.1.22-bin.jar 的存放位置。在MyEclipse具体的java工程中新建一存放jar 包的文件夹（如 lib），将mysql-connector-java-5.1.22-bin.jar 复制到文件夹中，选中jar包右击—&gt;Build Path—&gt;Add To Build Path，即可。 若出现 ClassNotFoundExceptioncom.mysql.jdbc.Driver 的提示，则正是由于缺少导入jar包所造成的。 2）如果已经对MySQL的使用很熟悉，则可忽略这条。个人在测试连接时，老是出现这样的异常提示： SQLException: Communications link failureThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. 这正是由于个人对MySQL使用不熟悉，对MySQL进行了诸多尝试性的操作，不知何时无意中将MySQL的服务(如果在安装MySQL时没有更改的话，缺省服务名就是MySQL)关闭，解决方法开启此服务即可。控制面板—&gt;管理工具—&gt;服务—&gt;MySQL—&gt;选择启用。 3)在使用上面的代码测试时，需要更改的地方有：//MySQL数据库的用户名,密码,数据库名复制代码 代码如下: String url = “jdbc:mysql://localhost:3306/jsj”;String username = “root”;String password = “111”; 以及具体基本表中的所要查询的字段名：复制代码 代码如下: int number = result.getInt(“sno”);String name = result.getString(“sname”);String mathScore = result.getString(“sgrade”); 多多分享，有问题欢迎交流~~","tags":[]},{"title":"数据库常用命令小结","date":"2017-05-08T01:26:15.000Z","path":"2017/05/08/数据库常用命令小结、/","text":"MySQL 数据库常用命令1、MySQL常用命令 create database name; 创建数据库 use databasename; 选择数据库 drop database name 直接删除数据库，不提醒 show tables; 显示表 describe tablename; 表的详细描述 select 中加上distinct去除重复字段 mysqladmin drop databasename 删除数据库前，有提示。 显示当前mysql版本和当前日期 select version(),current_date; 2、修改mysql中root的密码：shell&gt;mysql -u root -pmysql&gt; update user set password=password(”xueok654123″) where user=’root’;mysql&gt; flush privileges //刷新数据库mysql&gt;use dbname； 打开数据库：mysql&gt;show databases; 显示所有数据库mysql&gt;show tables; 显示数据库mysql中所有的表：先use mysql；然后mysql&gt;describe user; 显示表mysql数据库中user表的列信息）； 3、grant创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个mysql&gt; grant all privileges on . to user@localhost identified by ’something’ with增加新用户格式：grant select on 数据库. to 用户名@登录主机 identified by “密码”GRANT ALL PRIVILEGES ON . TO monty@localhost IDENTIFIED BY ’something’ WITH GRANT OPTION;GRANT ALL PRIVILEGES ON . TO monty@”%” IDENTIFIED BY ’something’ WITH GRANT OPTION;删除授权：mysql&gt; revoke all privileges on . from root@”%”;mysql&gt; delete from user where user=”root” and host=”%”;mysql&gt; flush privileges;创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandbmysql &gt;grant select, insert, update, delete, create,drop on fangchandb. to custom@ it363.com identified by ‘ passwd’重命名表:mysql &gt; alter table t1 rename t2; 4、mysqldump备份数据库shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql恢复数据库shell&gt; mysqladmin -h myhost -u root -p create dbnameshell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql如果只想卸出建表指令，则命令如下：shell&gt; mysqladmin -u root -p -d databasename &gt; a.sql如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下：shell&gt; mysqladmin -u root -p -t databasename &gt; a.sql那么如果我只想要数据，而不想要什么sql命令时，应该如何操作呢？ mysqldump -T./ phptest driver其中，只有指定了-T参数才可以卸出纯文本文件，表示卸出数据的目录，./表示当前目录，即与mysqldump同一目录。如果不指定driver 表，则将卸出整个数据库的数据。每个表会生成两个文件，一个为.sql文件，包含建表执行。另一个为.txt文件，只包含数据，且没有sql指令。 5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。例如，如果在文件my_file.sql 中存放有查询，可如下执行这些查询：例如，如果您想将建表语句提前写在sql.txt中:mysql &gt; mysql -h myhost -u root -p database &lt; sql.txt 常用mysql命令行命令1、mysql的启动与停止 启动MYSQL服务 net start mysql 停止MYSQL服务 net stop mysql 2、 netstat –na | findstr 3306 查看被监听的端口 , findstr用于查找后面的端口是否存在3、 在命令行中登陆MYSQL控制台 , 即使用 MYSQL COMMEND LINE TOOL 语法格式 mysql –user=root –password=123456 db_name 或 mysql –u root –p123456 db_name 4、 进入MYSQL命令行工具后 , 使用status; 或/s 查看运行环境信息5、 切换连接数据库的语法 : use new_dbname; 6、 显示所有数据库 : show databases; 7、 显示数据库中的所有表 : show tables; 8、 显示某个表创建时的全部信息 : show create table table_name; 9、 查看表的具体属性信息及表中各字段的描述 Describe table_name; 缩写形式 : desc table_name; MySql中的SQL语句1 . 数据库创建 : Create database db_name; 数据库删除 : Drop database db_name; 删除时可先判断是否存在，写成 : drop database if exits db_name 2 . 建表 : 创建数据表的语法 : create table table_name (字段1 数据类型 , 字段2 数据类型); 例 : create table mytable (id int , username char(20)); 删表 : drop table table_name; 例 : drop table mytable; 3 . 添加数据 : Insert into 表名 [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..); 如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可不写 例 : insert into mytable (id,username) values (1,’zhangsan’); 4. 查询 : 查询所有数据 : select * from table_name; 查询指定字段的数据 : select 字段1 , 字段2 from table_name; 例 : select id,username from mytable where id=1 order by desc;多表查询语句————参照第17条实例 ### 5 . 更新指定数据 , 更新某一个字段的数据（注意，不是更新字段的名字） Update table_name set 字段名=’新值’ [, 字段2 =’新值’ , …..][where id=id_num] [order by 字段 顺序] 例 : update mytable set username=’lisi’ where id=1; Order语句是查询的顺序 , 如 : order by id desc(或asc) , 顺序有两种 : desc倒序(100—1,即从最新数据往后查询),asc(从1-100)，Where和order语句也可用于查询select 与删除delete 6 . 删除表中的信息 : 删除整个表中的信息 : delete from table_name; 删除表中指定条件的语句 : delete from table_name where 条件语句 ; 条件语句如 : id=3; 7 . 创建数据库用户 一次可以创建多个数据库用户如： CREATE USER username1 identified BY ‘password’ , username2 IDENTIFIED BY ‘password’…. 8 . 用户的权限控制：grant 库，表级的权限控制 : 将某个库中的某个表的控制权赋予某个用户 Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; 9 . 表结构的修改 （1）增加一个字段格式： alter table table_name add column (字段名 字段类型); —-此方法带括号 （2）指定字段插入的位置： alter table table_name add column 字段名 字段类型 after 某字段； 删除一个字段： alter table table_name drop字段名; （3）修改字段名称/类型 alter table table_name change 旧字段名 新字段名 新字段的类型; （4）改表的名字 alter table table_name rename to new_table_name; （5）一次性清空表中的所有数据 truncate table table_name; 此方法也会使表中的取号器(ID)从1开始 10 . 增加主键，外键，约束，索引。。。。(使用方法见17实例) ① 约束（主键Primary key、唯一性Unique、非空Not Null） ② 自动增张 auto_increment ③外键Foreign key—–与reference table_name(col_name列名)配合使用，建表时单独使用 ④ 删除多个表中有关联的数据—-设置foreign key 为set null —具体设置参考帮助文档 11 . 查看数据库当前引擎 SHOW CREATE TABLE table_name; 修改数据库引擎 ALTER TABLE table_name ENGINE=MyISAM | InnoDB; 12 . SQL语句运用实例: –1 建users表 create table users (id int primary key auto_increment,nikename varchar(20) not null unique,password varchar(100) not null,address varchar(200), reg_date timestamp not null default CURRENT_TIMESTAMP); –2 建articles表,在建表时设置外键 create table articles (id int primary key auto_increment,content longtext not null,userid int,constraint foreign key (userid) references users(id) on delete set null); ———————————————————————– –2.1 建articles表,建表时不设置外键 create table articles (id int primary key auto_increment,content longtext not null,userid int); –2.2 给articles表设置外键 alter table articles add constraint foreign key (userid) references users(id) on delete set null; ———————————————————————— –3. 向users表中插入数据,同时插入多条 insert into users (id,nikename,password,address) values (1,’lyh1’,’1234’,null),(10,’lyh22’,’4321’,’湖北武汉’),(null,’lyh333’,’5678’, ‘北京海淀’); –4. 向article中插入三条数据 insert into articles (id,content,userid) values (2,’hahahahahaha’,11),(null,’xixixixixix’,10),(13,’aiaiaiaiaiaiaiaiaiaiaiaia’,1),(14,’hohoahaoaoooooooooo’,10); –5. 进行多表查询，选择users表中ID=10的用户发布的所有留言及该用户的所有信息 select articles.id,articles.content,users. from users,articles where users.id=10 and articles.userid=users.id order by articles.id desc; –6. 查看数据库引擎类型 show create table users; –7. 修改数据库引擎类型 alter table users engine=MyISAM; —因为users表中ID被设置成外键，执行此句会出错 –8. 同表查询,已知一个条件的情况下.查询ID号大于用户lyh1的ID号的所有用户 select a.id,a.nikename,a.address from users a,users b where b.nikename=’lyh1’ and a.id&gt;b.id; ——也可写成 select id,nikename,address from users where id&gt;(select id from users where nikename=’lyh1’); –9. 显示年龄比领导还大的员工： select a.name from users a,users b where a.managerid=b.id and a.age&gt;b.age; 查询编号为2的发帖人: 先查articles表,得到发帖人的编号,再根据编号查users得到的用户名。 接着用关联查询. select from articles,users得到笛卡儿积,再加order by articles.id以便观察 使用select from articles,users where articles.id=2 筛选出2号帖子与每个用户的组合记录 再使用select from articles,users where articles.id=2 and articles.userid=users.id选出users.id等于2号帖的发帖人id的记录. 只取用户名:select user where user.id=(select userid from articles where article.id =2) 找出年龄比小王还大的人:假设小王是28岁,先想找出年龄大于28的人 select from users where age&gt;(select age from users where name=’xiaowang’); **要查询的记录需要参照表里面的其他记录: select a.name from users a,users b where b.name=’xiaowang’ and a.age&gt;b.age 表里的每个用户都想pk一下.select a.nickname,b.nickname from users a,users b where a.id&gt;b.id ; 更保险的语句:select a.nickname,b.nickname from (select from users order by id) a,(se lect from users order by id) b where a.id&gt;b.id ; 再查询某个人发的所有帖子. select b.* from articles a , articles b where a.id=2 and a.userid=b.userid 说明: 表之间存在着关系，ER概念的解释，用access中的示例数据库演示表之间的关系.只有innodb引擎才支持foreign key，mysql的任何引擎目前都不支持check约束。 字符集出现错误解决办法出现的问题： mysql&gt; update users -&gt; set username=’关羽’ -&gt; where userid=2; ERROR 1366 (HY000): Incorrect string value: ‘/xB9/xD8/xD3/xF0’ for column ‘usern ame’ at row 1 向表中插入中文字符时，出现错误。12345678 mysql&gt; select * from users; +--------+----------+ | userid | username | +--------+----------+ | 2 | ???? | | 3 | ???? | | 4 | ?í?ù | +--------+----------+ 3 rows in set (0.00 sec) 表中的中文字符位乱码。 解决办法： 使用命令： mysql&gt; status; ————– mysql Ver 14.12 Distrib 5.0.45, for Win32 (ia32) Connection id: 8 Current database: test Current user: root@localhost SSL: Not in use Using delimiter: ; Server version: 5.0.45-community-nt MySQL Community Edition (GPL) Protocol version: 10 Connection: localhost via TCP/IP Server characterset: latin1 Db characterset: latin1 Client characterset: gbk Conn. characterset: gbk TCP port: 3306 Uptime: 7 hours 39 min 19 sec Threads: 2 Questions: 174 Slow queries: 0 Opens: 57 Flush tables: 1 Open ta bles: 1 Queries per second avg: 0.006 ————– 查看mysql发现Server characterset，Db characterset的字符集设成了latin1，所以出现中文乱码。1234567 mysql&gt; show tables; +----------------+ | Tables_in_test | +----------------+ | users | +----------------+ 1 row in set (0.00 sec) 更改表的字符集。 mysql&gt; alter table users character set GBK; Query OK, 3 rows affected (0.08 sec) Records: 3 Duplicates: 0 Warnings: 0 查看表的结构： mysql&gt; show create users; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘users ‘ at line 1 mysql&gt; show create table users; +——-+———————————————————————– ——————————————————————————+ | Table | Create Table | +——-+———————————————————————– ——————————————————————————+ | users | CREATE TABLE users ( userid int(11) default NULL, username char(20) character set latin1 default NULL ) ENGINE=InnoDB DEFAULT CHARSET=gbk | +——-+———————————————————————– ——————————————————————————+ 1 row in set (0.00 sec) mysql&gt; desc users; +———-+———-+——+—–+———+——-+ | Field | Type | Null | Key | Default | Extra | +———-+———-+——+—–+———+——-+ | userid | int(11) | YES | | NULL | | | username | char(20) | YES | | NULL | | +———-+———-+——+—–+———+——-+ 2 rows in set (0.02 sec) 这时向表中插入中文然后有错误。 mysql&gt; insert into users values(88,’中文’); ERROR 1366 (HY000): Incorrect string value: ‘/xD6/xD0/xCE/xC4’ for column ‘usern ame’ at row 1 mysql&gt; insert into users values(88,’中文’); ERROR 1366 (HY000): Incorrect string value: ‘/xD6/xD0/xCE/xC4’ for column ‘usern ame’ at row 1 还要更改users表的username的字符集。 mysql&gt; alter table users modify username char(20) character set gbk; ERROR 1366 (HY000): Incorrect string value: ‘/xC0/xEE/xCB/xC4’ for column ‘usern ame’ at row 1 mysql&gt; alter table users modify username char(20) character set gbk; ERROR 1366 (HY000): Incorrect string value: ‘/xC0/xEE/xCB/xC4’ for column ‘usern ame’ at row 1 因为表中已经有数据，所以更改username字符集的操作没有成 清空users表中的数据 mysql&gt; truncate table users; Query OK, 3 rows affected (0.01 sec) 从新更改user表中username的字符集 mysql&gt; alter table users modify username char(20) character set gbk; Query OK, 0 rows affected (0.06 sec) Records: 0 Duplicates: 0 Warnings: 0 这时再插入中文字符，插入成。 mysql&gt; insert into users values(88,’中文’); Query OK, 1 row affected (0.01 sec) mysql&gt; select * from users; +——–+———-+ | userid | username | +——–+———-+ | 88 | 中文 | +——–+———-+ 1 row in set (0.00 sec) mysql&gt; 转载声明：本文转自http://hi.baidu.com/zhjlabm/blog/item/b939fc3307a1d445ad4b5fbd.html学习MySQL常用操作命令1、启动MySQL服务器实际上上篇已讲到如何启动MySQL。两种方法： 一是用winmysqladmin，如果机器启动时已自动运行，则可直接进入下一步操作。 二是在DOS方式下运行 d:mysqlbinmysqld 2、进入mysql交互操作界面在DOS方式下，运行： d:mysqlbinmysql出现: mysql 的提示符，此时已进入mysql的交互操作方式。如果出现 “ERROR 2003: Can′t connect to MySQL server on ′localhost′ (10061)“，说明你的MySQL还没有启动。 3、退出MySQL操作界面在mysql&gt;提示符下输入quit可以随时退出交互操作界面：mysql&gt; quitBye你也可以用control-D退出。 4、第一条命令mysql&gt; select version(),current_date();+—————-+—————–+| version() | current_date() |+—————-+—————–+| 3.23.25a-debug | 2001-05-17 |+—————-+—————–+1 row in set (0.01 sec)mysql&gt; 此命令要求mysql服务器告诉你它的版本号和当前日期。尝试用不同大小写操作上述命令，看结果如何。结果说明mysql命令的大小写结果是一致的。练习如下操作：mysql&gt;Select (20+5)4;mysql&gt;Select (20+5)4,sin(pi()/3);mysql&gt;Select (20+5)*4 AS Result,sin(pi()/3); (AS: 指定假名为Result) 5、多行语句一条命令可以分成多行输入，直到出现分号“；”为止： mysql&gt; select-&gt; USER()-&gt; ,-&gt; now()-&gt;;+——————–+———————+| USER() | now() |+——————–+———————+| ODBC@localhost | 2001-05-17 22:59:15 |+——————–+———————+1 row in set (0.06 sec)mysql&gt; 注意中间的逗号和最后的分号的使用方法。 6、一行多命令输入如下命令：mysql&gt; SELECT USER(); SELECT NOW();+——————+| USER() |+——————+| ODBC@localhost |+——————+1 row in set (0.00 sec)+———————+| NOW() |+———————+| 2001-05-17 23:06:15 |+———————+1 row in set (0.00 sec)mysql&gt; 注意中间的分号，命令之间用分号隔开。 7、显示当前存在的数据库mysql&gt; show databases;+———-+| Database |+———-+| mysql || test |+———-+2 row in set (0.06 sec)mysql&gt; 8、选择数据库并显示当前选择的数据库mysql&gt; USE mysqlDatabase changedmysql&gt;(USE 和 QUIT 命令不需要分号结束。）mysql&gt; select database();+—————+| database() |+—————+| mysql |+—————+1 row in set (0.00 sec) 9、显示当前数据库中存在的表mysql&gt; SHOW TABLES; 10、显示表(db)的内容mysql&gt;select * from db; 11、命令的取消当命令输入错误而又无法改变（多行语句情形）时，只要在分号出现前就可以用 c来取消该条命令mysql&gt; select *-&gt; user()-&gt; cmysql&gt;这是一些最常用的最基本的操作命令，通过多次练习就可以牢牢掌捂了 ========================================================================== mysql命令测试环境：mysql 5.0.45【注：可以在mysql中通过mysql&gt; SELECT VERSION();来查看数据库版本】整理：leo 一、连接MYSQL。格式： mysql -h主机地址 -u用户名 －p用户密码 1、连接到本机上的MYSQL。首先打开DOS窗口，然后进入目录mysql/bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码.如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt; 2、连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令：mysql -h110.110.110.110 -u root -p 123; （注:u与root之间可以不用加空格，其它也一样） 3、退出MYSQL命令： exit （回车） 二、修改密码。格式：mysqladmin -u用户名 -p旧密码 password 新密码 1、给root加个密码ab12。首先在DOS下进入目录mysql/bin，然后键入以下命令mysqladmin -u root -password ab12注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 2、再将root的密码改为djg345。mysqladmin -u root -p ab12 password djg345三、增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：grant select,insert,update,delete on . to [email=test1@”%]test1@”%[/email]” Identified by “abc”;但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。 2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。grant select,insert,update,delete on mydb. to [email=test2@localhost]test2@localhost[/email] identified by “abc”;如果你不想test2有密码，可以再打一个命令将密码消掉。grant select,insert,update,delete on mydb. to [email=test2@localhost]test2@localhost[/email] identified by “”; 下篇我是MYSQL中有关数据库方面的操作。注意：你必须首先登录到MYSQL中，以下操作都是在MYSQL的提示符下进行的，而且每个命令以分号结束。一、操作技巧 1、如果你打命令时，回车后发现忘记加分号，你无须重打一遍命令，只要打个分号回车就可以了。也就是说你可以把一个完整的命令分成几行来打，完后用分号作结束标志就OK。 2、你可以使用光标上下键调出以前的命令。二、显示命令 1、显示当前数据库服务器中的数据库列表：mysql&gt; SHOW DATABASES;注意：mysql库里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。 2、显示数据库中的数据表：mysql&gt; USE 库名；mysql&gt; SHOW TABLES; 3、显示数据表的结构：mysql&gt; DESCRIBE 表名; 4、建立数据库：mysql&gt; CREATE DATABASE 库名; 5、建立数据表：mysql&gt; USE 库名;mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1)); 6、删除数据库：mysql&gt; DROP DATABASE 库名; 7、删除数据表：mysql&gt; DROP TABLE 表名； 8、将表中记录清空：mysql&gt; DELETE FROM 表名; 9、显示表中的记录：mysql&gt; SELECT * FROM 表名; 10、往表中插入记录：mysql&gt; INSERT INTO 表名 VALUES (”hyq”,”M”); 11、更新表中数据：mysql-&gt; UPDATE 表名 SET 字段名1=’a’,字段名2=’b’ WHERE 字段名3=’c’; 12、用文本方式将数据装入数据表中：mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE 表名; 13、导入.sql文件命令：mysql&gt; USE 数据库名;mysql&gt; SOURCE d:/mysql.sql; 14、命令行修改root密码：mysql&gt; UPDATE mysql.user SET password=PASSWORD(’新密码’) WHERE User=’root’;mysql&gt; FLUSH PRIVILEGES; 15、显示use的数据库名：mysql&gt; SELECT DATABASE(); 16、显示当前的user：mysql&gt; SELECT USER(); 三、一个建库和建表以及插入数据的实例drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(id int(3) auto_increment not null primary key,name char(10) not null,address varchar(50) default ‘深圳’,year date); //建表结束//以下为插入字段insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。 （1）你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c://下，并在DOS状态进入目录[url=file:////mysql//bin]//mysql//bin[/url]，然后键入以下命令：mysql -uroot -p密码 &lt; c://school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 （2）或者进入命令行后使用 mysql&gt; source c://school.sql; 也可以将school.sql文件导入数据库中。 将文本数据转到数据库中 1、文本数据应符合的格式：字段数据之间用tab键隔开，null值用[url=file:////n]//n[/url]来代替.例：3 rose 大连二中 1976-10-104 mike 大连一中 1975-12-23假设你把这两组数据存为school.txt文件，放在c盘根目录下。 2、数据传入命令 load data local infile “c://school.txt” into table 表名;注意：你最好将文件复制到[url=file:////mysql//bin]//mysql//bin[/url]目录下，并且要先用use命令打表所在的库。 备份数据库 1.导出整个数据库导出文件默认是存在mysql/bin目录下mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 导入数据库例如：数据库名为 dbTest首先，进入mysqlmysql -uroot -p123456然后，创建数据库create dbTestexit最后，导入数据库mysql -uroot -p123456 dbTest &lt; dbTest_bk.sql 数据库及表导出导入示例：导出数据库mysqldump -u root -p123456 gameTop &gt; gameTop_db.sql 导出数据库的表mysqldump -u -p123456 root gameTop gametop800 &gt; gameTop_table.sql 导出数据库的特定表mysqldump -u root -p123456 gameTop –table gametop800 &gt; gameTop_table.sql 导出数据库（只导结构，不要数据）mysqldump -u root -p123456 –opt -d gameTop &gt; gameTop_db.sql或者mysqldump -u root -p123456 -d gameTop &gt; gameTop_db.sql 导出数据库（只导数据，不要结构）mysqldump -u root -p123456 -t gameTop &gt; gameTop_db.sql 注：不加 -d 和 -t 则既导出结构，也导出数据mysqldump导出抛出异常：mysqldump: Got error: 1044: Access denied for user ‘username’@’%’ to database ‘dbname’ when using LOCK TABLES解决办法，添加参数 –skip-lock-tables：mysqldump –skip-lock-tables -h172.88.12.102 -username-pAnJnVs3C2tYXyTwV dbname&gt; dbname_bk.sql 导入数据库：登录MySQL: mysql -uroot -p123456创建数据库： create database gameTop; 导入数据库：mysql -uroot -p123456 gameTop &lt; gameTop_db.sql 导入数据库表：mysql -uroot -p123456 gameTop gametop800 &lt; gameTop_table.sql 导入数据库表：mysql -uroot -p123456 gameTop &lt; gameTop_table.sql （不指定表名） 转载声明：本文转自http://blog.csdn.net/networld2002/archive/2009/04/23/4103407.aspx 1:使用SHOW语句找出在服务器上当前存在什么数据库：mysql&gt; SHOW DATABASES; 2:创建一个数据库MYSQLDATAmysql&gt; CREATE DATABASE MYSQLDATA; 3:选择你所创建的数据库mysql&gt; USE MYSQLDATA; (按回车键出现Database changed 时说明操作成功！) 4:查看现在的数据库中存在什么表mysql&gt; SHOW TABLES; 5:创建一个数据库表mysql&gt; CREATE TABLE MYTABLE (name VARCHAR(20), sex CHAR(1)); 6:显示表的结构：mysql&gt; DESCRIBE MYTABLE; 7:往表中加入记录mysql&gt; insert into MYTABLE values (”hyq”,”M”); 8:用文本方式将数据装入数据库表中（例如D:/mysql.txt）mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE MYTABLE; 9:导入.sql文件命令（例如D:/mysql.sql）mysql&gt;use database;mysql&gt;source d:/mysql.sql; 10:删除表mysql&gt;drop TABLE MYTABLE; 11:清空表mysql&gt;delete from MYTABLE; 12:更新表中数据mysql&gt;update MYTABLE set sex=”f” where name=’hyq’; 以下是无意中在网络看到的使用MySql的管理心得,在windows中MySql以服务形式存在，在使用前应确保此服务已经启动，未启动可用net start mysql命令启动。而Linux中启动时可用“/etc/rc.d/init.d/mysqld start”命令，注意启动者应具有管理员权限。刚安装好的MySql包含一个含空密码的root帐户和一个匿名帐户，这是很大的安全隐患，对于一些重要的应用我们应将安全性尽可能提高，在这里应把匿名帐户删除、 root帐户设置密码，可用如下命令进行：use mysql;delete from User where User=””;update User set Password=PASSWORD(’newpassword’) where User=’root’; 如果要对用户所用的登录终端进行限制，可以更新User表中相应用户的Host字段，在进行了以上更改后应重新启动数据库服务，此时登录时可用如下类似命令：mysql -uroot -p;mysql -uroot -pnewpassword;mysql mydb -uroot -p;mysql mydb -uroot -pnewpassword;上面命令参数是常用参数的一部分，详细情况可参考文档。此处的mydb是要登录的数据库的名称。在 进行开发和实际应用中，用户不应该只用root用户进行连接数据库，虽然使用root用户进行测试时很方便，但会给系统带来重大安全隐患，也不利于管理技 术的提高。我们给一个应用中使用的用户赋予最恰当的数据库权限。如一个只进行数据插入的用户不应赋予其删除数据的权限。MySql的用户管理是通过 User表来实现的，添加新用户常用的方法有两个，一是在User表插入相应的数据行，同时设置相应的权限；二是通过GRANT命令创建具有某种权限的用 户。其中GRANT的常用用法如下： grant all on mydb. to NewUserName@HostName identified by “password” ;grant usage on . to NewUserName@HostName identified by “password”;grant select,insert,update on mydb. to NewUserName@HostName identified by “password”;grant update,delete on mydb.TestTable to NewUserName@HostName identified by “password”; 若 要给此用户赋予他在相应对象上的权限的管理能力，可在GRANT后面添加WITH GRANT OPTION选项。而对于用插入User表添加的用户，Password字段应用PASSWORD 函数进行更新加密，以防不轨之人窃看密码。对于那些已经不用的用户应给予清除，权限过界的用户应及时回收权限，回收权限可以通过更新User表相应字段， 也可以使用REVOKE操作。下面给出本人从其它资料(www.cn-Java.com)获得的对常用权限的解释：全局管理权限：FILE: 在MySQL服务器上读写文件。PROCESS: 显示或杀死属于其它用户的服务线程。RELOAD: 重载访问控制表，刷新日志等。SHUTDOWN: 关闭MySQL服务。数据库/数据表/数据列权限：ALTER: 修改已存在的数据表(例如增加/删除列)和索引。CREATE: 建立新的数据库或数据表。DELETE: 删除表的记录。DROP: 删除数据表或数据库。INDEX: 建立或删除索引。INSERT: 增加表的记录。SELECT: 显示/搜索表的记录。UPDATE: 修改表中已存在的记录。特别的权限：ALL: 允许做任何事(和root一样)。USAGE: 只允许登录–其它什么也不允许做。","tags":[]},{"title":"vue.js笔记","date":"2017-05-01T03:29:40.000Z","path":"2017/05/01/vue-js笔记/","text":"每多学一点知识，就少写一行代码。1、Vue.js使用vue-resource实现ajax请求1234567891011121314151617181920/** * Created by gequn06 on 2017/3/20. */import Vue from 'vue/dist/vue.common.js';import VueResource from 'vue-resource';Vue.use(VueResource);new Vue(&#123; el: '#doctorWrap', data: &#123; someData : null &#125;, created :function () &#123; this.$http.get('/public/js/data.json').then(function(response)&#123; console.log(response) // get body data this.someData = response.body.sites; &#125;); &#125;&#125;); 2、Vue.js引用css123&lt;style scoped&gt; @import '../assets/hello.css';&lt;/style&gt; 3、过滤器123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div v-bind:id=\"msg | filterA | filterB\"&gt;111&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hello', data () &#123; return &#123; msg: 'thanks' &#125; &#125;, filters: &#123; filterA: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;, filterB: function (value) &#123; if (!value) return '' value = value.toString(); return value.slice(0, 1) + value.charAt(2).toUpperCase() + value.slice(2); &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 4、Computed Properties and Watchers12345678910111213141516171819&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 5、component lists rendered with v-for should have explicit keys12345678910v-for需要绑定:key&lt;el-select v-model=\"value\" placeholder=\"请选择\" class=\"meeting-duration-select\"&gt; &lt;el-option v-for=\"(item,index) in options\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\"&gt; &lt;/el-option&gt;&lt;/el-select&gt;","tags":[]},{"title":"项目中的常见问题题_vue_store","date":"2017-04-26T02:47:16.000Z","path":"2017/04/26/项目中的常见问题题-vue-store/","text":"我会把我做关于模仿微博的这个项目遇到的一些问题公开在这里，遇到不对的地方请指教，发送邮件wang1348168417@gmail.com，或者扫我的微信二维码。一个简单的状态管理 单一数据源:1234567const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 每当 sourceOfTruth 发生变化, vmA 和 vmB 都会自动更新它们的视图. 子组件可以通过 this.$root.$data 访问数据. 现在我们有了单一的数据源, 但是调试会很困难. 因为无论何时数据源发生变化都会改变程序, 但是没有任何迹象表明变化发生. store pattern为了解决上述问题, 我们可以引入 store pattern:1234567891011121314var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; this.debug &amp;&amp; console.log('setMessageAction triggered with', newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; this.debug &amp;&amp; console.log('clearMessageAction triggered') this.state.message = 'action B triggered' &#125;&#125; 所有的数据改变都发生 store 内. 这种集中的状态管理模式使我们很容易记录变化发生, 如何发生.除了单一的数据源外, 每个 vue 实例或组件也可以有其私有状态:123456789101112var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 使用Vuex12345678910111213141516171819// 如果 Vuex 不是全局的, 那么确保调用 Vue.use(Vuex) 使 Vuex 生效.const store = new Vuex.Store(&#123; // 数据源 state: &#123; count: 0 &#125;, // 数据操作 mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)// 触发数据变化操作store.commit('increment')console.log(store.state.count) // -&gt; 1 Statestore 自动注入到子组件中 通常我们通过计算属性来访问 store 中的数据, 这样就能感知到数据发生变化.根组件的 store 属性会注入到其所有的子组件中. (通过 Vue.use(Vuex) 生效)1234567891011121314151617const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count() &#123; // 子组件通过 this.$store 访问父组件的 store return this.$store.state.count &#125; &#125;&#125;new Vue(&#123; // 父对象中的 store 自动注入到子组件 store, componets: &#123; Counter &#125;&#125;) mapState如果 store 中有许多数据需要访问, 每个数据都需要定义一个计算属性会非常麻烦. Vuex 提供了 mapState 来简化计算属性的定义.123456789101112131415161718import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // es6 箭头函数更加简洁 count: state =&gt; state.count, // 字符串 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了访问组件的 `this`, 必须使用普通的函数 // 箭头函数会绑定 `this` 到 `mapState` 的参数这个对象 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 如果计算属性和 store 中数据是一一对应的, 可以使用更简单的字符串数组:1234computed: mapState([ // map this.count to store.state.count 'count']) es6 的扩展操作符使用 mapState 返回一个对象, 如果组件还有私有的计算属性, 通常我们可以使用 _.extend({localComputed}, mapState(…)) 这种方式合并对象已得到最终的 computed. 使用 es6 的扩展操作符可以简化:1234567computed: &#123; localComputed()&#123; /* ... */&#125;, // 通过扩展操作符扩展 computed 对象 ...mapState(&#123; // ... &#125;)&#125; Getters通常计算属性是基于一段 store 数据的代码, 比如过滤一个列表并计数:12345computed: &#123; doneTodoCount() &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果我们需要复用这段代码, 基本就是重构提取出一个函数, 但是这样还不是很理想.123456789101112131415161718192021Vuex 在 store 中提供了 getters:const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125;, doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; &#125;&#125;)// 通过 `store.getters` 访问store.getters.doneTodosCount 上面的计算属性就可以改成:12345computed: &#123; doneTodoCount() &#123; return this.$store.getters.doneTodoCount &#125;&#125; mapGetters同 state 的 mapState 类似, getters 也有 mapGetters 来简化计算属性的定义12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // mix the getters into computed with object spread operator ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 使用对象可以自定义对应关系1234mapGetters(&#123; // map this.doneCount to store.getters.doneTodosCount doneCount: 'doneTodosCount'&#125;) MutationsVuex 中的 state 只能通过 mutations 来改变. mutations 很像事件, 都有一个类型和处理函数. 处理函数是真正改变 state 的地方, 并以 state 作为第一个参数.1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 改变 state state.count++ &#125; &#125;&#125;) 就是事件一样, 我们不能直接调用处理函数, 而是要通过 store.commit(type) 来触发 mutation 处理函数. store.commit(‘increment’)带 playload commit 我们可以将处理函数的参数放到第二个参数 playload 中:12345678910111213mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123;amount: 10&#125;)对象风格 commitstore.commit(&#123; type: 'increment', playload: &#123; amount: 10 &#125;&#125;) 静默模式默认情况下, 每一次 commit 都会发送到插件 (比如: devtools) 中. 可能你会希望某些 commit 不被记录. 这时候可以传递第三个参数以设置为静默模式:123456789store.commit('increment', &#123; amount: 1&#125;, &#123; silent: true &#125;)// 对象风格 commitstore.commit(&#123; type: 'increment', amount: 1&#125;, &#123; silent: true &#125;) Mutations 要遵守 Vue 的响应式规则 即: 提前初始化所有的状态值添加新的属性到对象时, 你应该:使用 Vue.set(obj, ‘newProp’, 123) 或直接替换新的对象: state.obj = {…state.obj, newProp: 123}使用常量为 Mutations 命名 使用常量为 Mutations 命名是各种 Flux 实现常用的模式. 将所有常量放到一个文件中, 我们能看到整个程序有什么情况数据会发生变化.1234567891011121314151617// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // es6 特性 computed property name // 属性名称运行时确定 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) Mutations 必须是同步的异步 mutations 调用违反了所有的状态变化必须在 store 中进行的规定. 比如:1234567mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125; 当上例中状态变化时, someMutation 已经结束了. 这时候如果有其他状态变化的操作发生, devtools 记录下来的状态变化就是错误的. mapMutations我们可以通过 this.$store.commit(‘xxx’) 在组件中调用 mutations, 一般我们将这些调用分装到 methods 中, 同时 Vuex 也提供了 mapMutations 函数简化 methods 定义:12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // 映射 this.increment() 到 this.$store.commit('increment') ]), ...mapMutations(&#123; add: 'increment' // map this.add() to this.$store.commit('increment') &#125;) &#125;&#125; Actions异步的 mutations 使程序的状态变化难以追踪. 为了解决异步操作, Vuex 引入了 actions.actions 跟 mutations 非常像, 它们的不同之处在于:1234567891011121314151617actions 不改变 state, 而是 commit mutationsactions 可以包含任意的异步操作const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) actions 接收一个 context 对象作为参数, context 可以访问 commit, getters, state, 但是它不是 store 对象.通常, 我们会使用 es6 的参数结构语法来简化代码:12345actions: &#123; increment(&#123;commit&#125;) &#123; commit('increment') &#125;&#125; Dispatching Actionsactions 通过 store.dispatch 来触发: store.dispatch(‘increment’)dispatch 也支持 commit 中的 playload 参数以及对象风格的调用方式.12345678910// dispatch with a payloadstore.dispatch('incrementAsync', &#123; amount: 10&#125;)// dispatch with an objectstore.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) mapActions类似 mapMutations Actions 组合 actions 通常是异步的, 我们怎么来组合多个 actions 来执行复杂的操作? 首先我们需要知道的是 store.dispatch 返回 actions 中处理函数的返回值, 因此我们可以返回一个 Promise:123456789101112131415161718192021222324252627282930actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;, actionB (&#123; dispatch, commit &#125;) &#123; // 组合 return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125;使用 async/await 语法, 可以简化为:// 假设 getData() 和 getOtherData() 返回 Promisesactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // wait for actionA to finish commit('gotOtherData', await getOtherData()) &#125;&#125; Modules当我们的程序足够大时, store 也会变得非常大, 其中的 state, getters, mutations, actions 也会非常大. 因此 Vuex 允许我们将 store 分成几个 modules, 每个 modules 都有自己的 state, getters, mutations, actions 甚至它自己的 modules.12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA's statestore.state.b // -&gt; moduleB's state Modules 当前状态在 modules 中, getters 和 mutations 的第一个参数都是 modules 的 state, 同样 actions 的 context.state 也是 modules 的 state, 根节点的状态可以通过 context.rootState 访问到. getters 的可以通过第三个参数访问 $rootState:12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; ### 命名空间 modules 的 state 放到根节点的对应的属性中, 而 actions, mutations 和 getters 没有命名空间. 所以多个 modules 可以对同一个 commit 或 dispatch 做响应. 因此必须自己通过前缀或后缀来避免命名冲突. 动态 Modules 注册1234store.registerModule('myModule', &#123; // ...&#125;)keep learning","tags":[]},{"title":"Es6新特性","date":"2017-04-18T07:36:32.000Z","path":"2017/04/18/Es6新特性/","text":"####ECMAScript 6简介 ###1.Class基本语法 ##概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。12345678class Bar &#123; doStuff() &#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // \"stuff\" 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。1234567891011121314151617181920class Point &#123; constructor()&#123; // ... &#125; toString()&#123; // ... &#125; toValue()&#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678910111213class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;);prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 class Point { constructor(x, y) { // … } toString() { // … }} Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [“constructor”,”toString”] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。 var Point = function (x, y) { // …}; Point.prototype.toString = function() { // …}; Object.keys(Point.prototype)// [“toString”]Object.getOwnPropertyNames(Point.prototype)// [“constructor”,”toString”] 上面代码采用ES5的写法，toString方法就是可枚举的。 类的属性名，可以采用表达式。 let methodName = “getArea”;class Square{ constructor(length) { // … } methodName { // … }} 上面代码中，Square类的方法名getArea，是从表达式得到的。 constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor() {}constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 class Foo { constructor() { return Object.create(null); }} new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 class Foo { constructor() { return Object.create(null); }} Foo()// TypeError: Class constructor Foo cannot be invoked without ‘new’ 类的实例对象生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 // 报错var point = Point(2, 3); // 正确var point = new Point(2, 3); 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 //定义类class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’; } } var point = new Point(2, 3); point.toString() // (2, 3) point.hasOwnProperty(‘x’) // truepoint.hasOwnProperty(‘y’) // truepoint.hasOwnProperty(‘toString’) // falsepoint.proto.hasOwnProperty(‘toString’) // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。 与ES5一样，类的所有实例共享一个原型对象。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto === p2.proto//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以proto属性是相等的。 这也意味着，可以通过实例的proto属性为Class添加方法。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto.printName = function () { return ‘Oops’ }; p1.printName() // “Oops”p2.printName() // “Oops” var p3 = new Point(4,2);p3.printName() // “Oops” 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。 new Foo(); // ReferenceErrorclass Foo {}上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 { let Foo = class {}; class Bar extends Foo { }}上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 Class表达式与函数一样，类也可以使用表达式的形式定义。 const MyClass = class Me { getClassName() { return Me.name; }};上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined上面代码表示，Me只在Class内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { / … / };采用Class表达式，可以写出立即执行的Class。 let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); }}(‘张三’); person.sayName(); // “张三”上面代码中，person是一个立即执行的类的实例。 私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 class Widget { // 公有方法 foo (baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // …}上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 class Widget { foo (baz) { bar.call(this, baz); } // …} function bar(baz) { return this.snaf = baz;}上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 const bar = Symbol(‘bar’);const snaf = Symbol(‘snaf’); export default class myClass{ // 公有方法 foo(baz) { thisbar; } // 私有方法 bar { return this[snaf] = baz; } // …};上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = ‘there’) { this.print(Hello ${name}); } print(text) { console.log(text); }} const logger = new Logger();const { printName } = logger;printName(); // TypeError: Cannot read property ‘print’ of undefined上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // …}另一种解决方法是使用箭头函数。 class Logger { constructor() { this.printName = (name = ‘there’) =&gt; { this.print(Hello ${name}); }; } // …}还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 function selfish (target) { const cache = new WeakMap(); const handler = { get (target, key) { const value = Reflect.get(target, key); if (typeof value !== ‘function’) { return value; } if (!cache.has(value)) { cache.set(value, value.bind(target)); } return cache.get(value); } }; const proxy = new Proxy(target, handler); return proxy;} const logger = selfish(new Logger());严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。 name属性由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 class Point {}Point.name // “Point”name属性总是返回紧跟在class关键字后面的类名。 Class的继承基本用法Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 class ColorPoint extends Point {}上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ‘ ‘ + super.toString(); // 调用父类的toString() }}上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 class Point { / … / } class ColorPoint extends Point { constructor() { }} let cp = new ColorPoint(); // ReferenceError上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 constructor(…args) { super(…args);}另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 class Point { constructor(x, y) { this.x = x; this.y = y; }} class ColorPoint extends Point { constructor(x, y, color) { this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 }}上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 let cp = new ColorPoint(25, 8, ‘green’); cp instanceof ColorPoint // truecp instanceof Point // true上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。 类的prototype属性和proto属性大多数浏览器的ES5实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 class A {} class B extends A {} B.proto === A // trueB.prototype.proto === A.prototype // true上面代码中，子类B的proto属性指向父类A，子类B的prototype属性的proto属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 class A {} class B {} // B的实例继承A的实例Object.setPrototypeOf(B.prototype, A.prototype);const b = new B(); // B的实例继承A的静态属性Object.setPrototypeOf(B, A);const b = new B();《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 Object.setPrototypeOf = function (obj, proto) { obj.proto = proto; return obj;}因此，就得到了上面的结果。 Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.proto = A.prototype; Object.setPrototypeOf(B, A);// 等同于B.proto = A;这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（proto属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 Object.create(A.prototype);// 等同于B.prototype.proto = A.prototype;Extends 的继承目标extends关键字后面可以跟多种类型的值。 class B extends A {}上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论三种特殊情况。 第一种特殊情况，子类继承Object类。 class A extends Object {} A.proto === Object // trueA.prototype.proto === Object.prototype // true这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种特殊情况，不存在任何继承。 class A {} A.proto === Function.prototype // trueA.prototype.proto === Object.prototype // true这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.proto指向构造函数（Object）的prototype属性。 第三种特殊情况，子类继承null。 class A extends null {} A.proto === Function.prototype // trueA.prototype.proto === undefined // true这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的proto指向Function.prototype，即实质上执行了下面的代码。 class C extends null { constructor() { return Object.create(null); }}Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 Object.getPrototypeOf(ColorPoint) === Point// true因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 class A {} class B extends A { constructor() { super(); }}上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 class A { constructor() { console.log(new.target.name); }}class B extends A { constructor() { super(); }}new A() // Anew B() // B上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 class A {} class B extends A { m() { super(); // 报错 }}上面代码中，super()用在B类的m方法之中，就会造成句法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 class A { p() { return 2; }} class B extends A { constructor() { super(); console.log(super.p()); // 2 }} let b = new B();上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 class A { constructor() { this.p = 2; }} class B extends A { get m() { return super.p; }} let b = new B();b.m // undefined上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到。 class A {}A.prototype.x = 2; class B extends A { constructor() { super(); console.log(super.x) // 2 }} let b = new B();上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。 ES6 规定，通过super调用父类的方法时，super会绑定子类的this。 class A { constructor() { this.x = 1; } print() { console.log(this.x); }} class B extends A { constructor() { super(); this.x = 2; } m() { super.print(); }} let b = new B();b.m() // 2上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 class A { constructor() { this.x = 1; }} class B extends A { constructor() { super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 }} let b = new B();上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 class Parent { static myMethod(msg) { console.log(‘static’, msg); } myMethod(msg) { console.log(‘instance’, msg); }} class Child extends Parent { static myMethod(msg) { super.myMethod(msg); } myMethod(msg) { super.myMethod(msg); }} Child.myMethod(1); // static 1 var child = new Child();child.myMethod(2); // instance 2上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 class A {} class B extends A { constructor() { super(); console.log(super); // 报错 }}上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 class A {} class B extends A { constructor() { super(); console.log(super.valueOf() instanceof B); // true }} let b = new B();上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 var obj = { toString() { return “MyObject: “ + super.toString(); }}; obj.toString(); // MyObject: [object Object]实例的proto属性子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。 var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, ‘red’); p2.proto === p1.proto // falsep2.proto.proto === p1.proto // true上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的proto.proto属性，可以修改父类实例的行为。 p2.proto.proto.printName = function () { console.log(‘Ha’);}; p1.printName() // “Ha”上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。 Boolean()Number()String()Array()Date()Function()RegExp()Error()Object()以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 function MyArray() { Array.apply(this, arguments);} MyArray.prototype = Object.create(Array.prototype, { constructor: { value: MyArray, writable: true, configurable: true, enumerable: true }});上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。 var colors = new MyArray();colors[0] = “red”;colors.length // 0 colors.length = 0;colors[0] // “red”之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 下面的例子中，我们想让一个普通对象继承Error对象。 var e = {}; Object.getOwnPropertyNames(Error.call(e))// [ ‘stack’ ] Object.getOwnPropertyNames(e)// []上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 class MyArray extends Array { constructor(…args) { super(…args); }} var arr = new MyArray();arr[0] = 12;arr.length // 1 arr.length = 0;arr[0] // undefined上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 class VersionedArray extends Array { constructor() { super(); this.history = [[]]; } commit() { this.history.push(this.slice()); } revert() { this.splice(0, this.length, …this.history[this.history.length - 1]); }} var x = new VersionedArray(); x.push(1);x.push(2);x // [1, 2]x.history // [[]] x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3] x.revert();x // [1, 2]上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。 下面是一个自定义Error子类的例子。 class ExtendableError extends Error { constructor(message) { super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; }} class MyError extends ExtendableError { constructor(m) { super(m); }} var myerror = new MyError(‘ll’);myerror.message // “ll”myerror instanceof Error // truemyerror.name // “MyError”myerror.stack// Error// at MyError.ExtendableError// …注意，继承Object的子类，有一个行为差异。 class NewObj extends Object{ constructor(){ super(…arguments); }}var o = new NewObj({attr: true});console.log(o.attr === true); // false上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。 Class的取值函数（getter）和存值函数（setter）与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 class MyClass { constructor() { // … } get prop() { return ‘getter’; } set prop(value) { console.log(‘setter: ‘+value); }} let inst = new MyClass(); inst.prop = 123;// setter: 123 inst.prop// ‘getter’上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的descriptor对象上的。 class CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; }} var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, “html”);“get” in descriptor // true“set” in descriptor // true上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。 Class 的 Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 class Foo { constructor(…args) { this.args = args; } Symbol.iterator {for (let arg of this.args) { yield arg;}}} for (let x of new Foo(‘hello’, ‘world’)) { console.log(x);}// hello// world上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo { static classMethod() { return ‘hello’; }} Foo.classMethod() // ‘hello’ var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo {} Bar.classMethod(); // ‘hello’上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo { static classMethod() { return super.classMethod() + ‘, too’; }} Bar.classMethod();Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。 class Foo {} Foo.prop = 1;Foo.prop // 1上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。 // 以下两种写法都无效class Foo { // 写法一 prop: 2 // 写法二 static prop: 2} Foo.prop // undefinedES7有一个静态属性的提案，目前Babel转码器支持。 这个提案对实例属性和静态属性，都规定了新的写法。 （1）类的实例属性 类的实例属性可以用等式，写入类的定义之中。 class MyClass { myProp = 42; constructor() { console.log(this.myProp); // 42 }}上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; }}上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。 class ReactCounter extends React.Component { state = { count: 0 };}这种写法比以前更清晰。 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } state;}（2）类的静态属性 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 class MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myStaticProp); // 42 }}同样的，这个新写法大大方便了静态属性的表达。 // 老写法class Foo {}Foo.prop = 1; // 新写法class Foo { static prop = 1;}上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。 类的私有属性目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。 class Point { #x; constructor(x = 0) { #x = +x; } get x() { return #x } set x(value) { #x = +value }}上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。 私有属性可以指定初始值，在构造函数执行时进行初始化。 class Point { #x = 0; constructor() { #x; // 0 }}之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。 class Foo { #a; #b; #sum() { return #a + #b; } printSum() { console.log(#sum()); } constructor(a, b) { #a = a; #b = b; }}new.target属性new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(‘必须使用new生成实例’); }} // 另一种写法function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error(‘必须使用new生成实例’); }} var person = new Person(‘张三’); // 正确var notAPerson = Person.call(person, ‘张三’); // 报错上面代码确保构造函数只能通过new命令调用。 Class内部调用new.target，返回当前Class。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; }} var obj = new Rectangle(3, 4); // 输出 true需要注意的是，子类继承父类时，new.target会返回子类。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); // … }} class Square extends Rectangle { constructor(length) { super(length, length); }} var obj = new Square(3); // 输出 false上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error(‘本类不能实例化’); } }} class Rectangle extends Shape { constructor(length, width) { super(); // … }} var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。 Mixin模式的实现Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。 function mix(…mixins) { class Mix {} for (let mixin of mixins) { copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); } return Mix;} function copyProperties(target, source) { for (let key of Reflect.ownKeys(source)) { if ( key !== “constructor” &amp;&amp; key !== “prototype” &amp;&amp; key !== “name” ) { let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); } }}上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 class DistributedEdit extends mix(Loggable, Serializable) { // …}","tags":[]},{"title":"yilia配置","date":"2017-04-11T02:41:53.000Z","path":"2017/04/11/yilia配置/","text":"主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份 Headermenu: 主页: / 随笔: /tags/随笔/ SubNavsubnav: github: “#” weibo: “#” rss: “#” zhihu: “#” #qq: “#” #weixin: “#” #jianshu: “#” #douban: “#” #segmentfault: “#” #bilibili: “#” #acfun: “#” #mail: “mailto:litten225@qq.com” #facebook: “#” #google: “#” #twitter: “#” #linkedin: “#” rss: /atom.xml 是否需要修改 root 路径如果您的网站存放在子目录中，例如 http://yoursite.com/blog，请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: Content文章太长，截断按钮文字excerpt_link: more 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: ‘展开全文’ 数学公式mathjax: false 是否在新窗口打开链接open_in_new: false 打赏请在需要打赏的文章的md文件头部，设置属性reward: true打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2 打赏wordingreward_wording: ‘谢谢你请我吃糖果’ 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: 微信二维码图片地址weixin: Miscellaneousbaidu_analytics: ‘’google_analytics: ‘’favicon: /favicon.png #你的头像urlavatar: #是否开启分享share_jia: true #是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key #若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: 头像上面的背景颜色 header: ‘#4d4d4d’ 右滑板块背景 slider: ‘linear-gradient(200deg,#a0cfe4,#e8c37e)’ slider的设置slider: 是否默认展开tags板块 showTags: false 智能菜单如不需要，将该对应项置为false比如#smart_menu: friends: falsesmart_menu: innerArchive: ‘所有文章’ friends: ‘友链’ aboutme: ‘关于我’ friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/ aboutme: 很惭愧只做了一点微小的工作谢谢大家","tags":[]},{"title":"我的第一个博客","date":"2017-04-08T03:11:41.000Z","path":"2017/04/08/我的第一个博客/","text":"您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！","tags":[]}]