[{"title":"浅谈MyEclipse通过JDBC连接MySQL数据库","date":"2017-05-19T02:00:18.000Z","path":"2017/05/19/浅谈MyEclipse通过JDBC连接MySQL数据库/","text":"1.前提是MyEclipse已经能正常开发Java工程2.安装MySQL个人使用的是版本是 mysql-5.0.22-win32.zip网址：http://www.mysql.com/downloads/mysql/#downloads3.下载JDBC驱动个人使用的是 mysql-connector-java-5.1.22.zip，所需要的就是解压缩之后其中的 mysql-connector-java-5.1.22-bin.jar网址：http://www.mysql.com/downloads/connector/j/4.代码测试复制代码 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package ts.jsj.lyh; import java.sql.*; /** *//** * 使用JDBC连接数据库MySQL的过程 * DataBase：JSJ， table：student； * @author DuChangfeng 2008 09 18 */ public class JDBCTest &#123; public static Connection getConnection() throws SQLException, java.lang.ClassNotFoundException &#123; //第一步：加载MySQL的JDBC的驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //取得连接的url,能访问MySQL数据库的用户名,密码；jsj：数据库名 String url = &quot;jdbc:mysql://localhost:3306/jsj&quot;; String username = &quot;root&quot;; String password = &quot;111&quot;; //第二步：创建与MySQL数据库的连接类的实例 Connection con = DriverManager.getConnection(url, username, password); return con; &#125; public static void main(String args[]) &#123; try &#123; //第三步：获取连接类实例con，用con创建Statement对象类实例 sql_statement Connection con = getConnection(); Statement sql_statement = con.createStatement(); /** *//************ 对数据库进行相关操作 ************/ //如果同名数据库存在，删除 //sql_statement.executeUpdate(&quot;drop table if exists student&quot;); //执行了一个sql语句生成了一个名为student的表 //sql_statement.executeUpdate(&quot;create table student (id int not null auto_increment, name varchar(20) not null default &apos;name&apos;, math int not null default 60, primary key (id) ); &quot;); //向表中插入数据 //sql_statement.executeUpdate(&quot;insert student values(1, &apos;liying&apos;, 98)&quot;); //sql_statement.executeUpdate(&quot;insert student values(2, &apos;jiangshan&apos;, 88)&quot;); //sql_statement.executeUpdate(&quot;insert student values(3, &apos;wangjiawu&apos;, 78)&quot;); //sql_statement.executeUpdate(&quot;insert student values(4, &apos;duchangfeng&apos;, 100)&quot;); //---以上操作不实用，但是列出来作为参考--- //第四步：执行查询，用ResultSet类的对象，返回查询的结果 String query = &quot;select * from student&quot;; ResultSet result = sql_statement.executeQuery(query); /** *//************ 对数据库进行相关操作 ************/ System.out.println(&quot;Student表中的数据如下:&quot;); System.out.println(&quot;------------------------&quot;); System.out.println(&quot;学号&quot; + &quot; &quot; + &quot;姓名&quot; + &quot; &quot; + &quot;数据成绩 &quot;); System.out.println(&quot;------------------------&quot;); //对获得的查询结果进行处理，对Result类的对象进行操作 while (result.next()) &#123; int number = result.getInt(&quot;sno&quot;); String name = result.getString(&quot;sname&quot;); String mathScore = result.getString(&quot;sgrade&quot;); //取得数据库中的数据 System.out.println(&quot; &quot; + number + &quot; &quot; + name + &quot; &quot; + mathScore); &#125; //关闭连接和声明 sql_statement.close(); con.close(); &#125; catch(java.lang.ClassNotFoundException e) &#123; //加载JDBC错误,所要用的驱动没有找到 System.err.print(&quot;ClassNotFoundException&quot;); //其他错误 System.err.println(e.getMessage()); &#125; catch (SQLException ex) &#123; //显示数据库连接错误或查询错误 System.err.println(&quot;SQLException: &quot; + ex.getMessage()); &#125; &#125; &#125; 以上大部分内容整理自网络，感谢猿猿们的无私奉献~~具体的步骤、强大的互联网上都比较容易查询的到，这里不再赘述，现加上几点个人认为需要注意的地方： 1）关于mysql-connector-java-5.1.22-bin.jar 的存放位置。在MyEclipse具体的java工程中新建一存放jar 包的文件夹（如 lib），将mysql-connector-java-5.1.22-bin.jar 复制到文件夹中，选中jar包右击—&gt;Build Path—&gt;Add To Build Path，即可。 若出现 ClassNotFoundExceptioncom.mysql.jdbc.Driver 的提示，则正是由于缺少导入jar包所造成的。 2）如果已经对MySQL的使用很熟悉，则可忽略这条。个人在测试连接时，老是出现这样的异常提示： SQLException: Communications link failureThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. 这正是由于个人对MySQL使用不熟悉，对MySQL进行了诸多尝试性的操作，不知何时无意中将MySQL的服务(如果在安装MySQL时没有更改的话，缺省服务名就是MySQL)关闭，解决方法开启此服务即可。控制面板—&gt;管理工具—&gt;服务—&gt;MySQL—&gt;选择启用。 3)在使用上面的代码测试时，需要更改的地方有：//MySQL数据库的用户名,密码,数据库名复制代码 代码如下: String url = “jdbc:mysql://localhost:3306/jsj”;String username = “root”;String password = “111”; 以及具体基本表中的所要查询的字段名：复制代码 代码如下: int number = result.getInt(“sno”);String name = result.getString(“sname”);String mathScore = result.getString(“sgrade”); 多多分享，有问题欢迎交流~~","tags":[]},{"title":"数据库常用命令小结","date":"2017-05-08T01:26:15.000Z","path":"2017/05/08/数据库常用命令小结、/","text":"MySQL 数据库常用命令1、MySQL常用命令 create database name; 创建数据库 use databasename; 选择数据库 drop database name 直接删除数据库，不提醒 show tables; 显示表 describe tablename; 表的详细描述 select 中加上distinct去除重复字段 mysqladmin drop databasename 删除数据库前，有提示。 显示当前mysql版本和当前日期 select version(),current_date; 2、修改mysql中root的密码：shell&gt;mysql -u root -pmysql&gt; update user set password=password(”xueok654123″) where user=’root’;mysql&gt; flush privileges //刷新数据库mysql&gt;use dbname； 打开数据库：mysql&gt;show databases; 显示所有数据库mysql&gt;show tables; 显示数据库mysql中所有的表：先use mysql；然后mysql&gt;describe user; 显示表mysql数据库中user表的列信息）； 3、grant创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个mysql&gt; grant all privileges on . to user@localhost identified by ’something’ with增加新用户格式：grant select on 数据库. to 用户名@登录主机 identified by “密码”GRANT ALL PRIVILEGES ON . TO monty@localhost IDENTIFIED BY ’something’ WITH GRANT OPTION;GRANT ALL PRIVILEGES ON . TO monty@”%” IDENTIFIED BY ’something’ WITH GRANT OPTION;删除授权：mysql&gt; revoke all privileges on . from root@”%”;mysql&gt; delete from user where user=”root” and host=”%”;mysql&gt; flush privileges;创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandbmysql &gt;grant select, insert, update, delete, create,drop on fangchandb. to custom@ it363.com identified by ‘ passwd’重命名表:mysql &gt; alter table t1 rename t2; 4、mysqldump备份数据库shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql恢复数据库shell&gt; mysqladmin -h myhost -u root -p create dbnameshell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql如果只想卸出建表指令，则命令如下：shell&gt; mysqladmin -u root -p -d databasename &gt; a.sql如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下：shell&gt; mysqladmin -u root -p -t databasename &gt; a.sql那么如果我只想要数据，而不想要什么sql命令时，应该如何操作呢？ mysqldump -T./ phptest driver其中，只有指定了-T参数才可以卸出纯文本文件，表示卸出数据的目录，./表示当前目录，即与mysqldump同一目录。如果不指定driver 表，则将卸出整个数据库的数据。每个表会生成两个文件，一个为.sql文件，包含建表执行。另一个为.txt文件，只包含数据，且没有sql指令。 5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。例如，如果在文件my_file.sql 中存放有查询，可如下执行这些查询：例如，如果您想将建表语句提前写在sql.txt中:mysql &gt; mysql -h myhost -u root -p database &lt; sql.txt 常用mysql命令行命令1、mysql的启动与停止 启动MYSQL服务 net start mysql 停止MYSQL服务 net stop mysql 2、 netstat –na | findstr 3306 查看被监听的端口 , findstr用于查找后面的端口是否存在3、 在命令行中登陆MYSQL控制台 , 即使用 MYSQL COMMEND LINE TOOL 语法格式 mysql –user=root –password=123456 db_name 或 mysql –u root –p123456 db_name 4、 进入MYSQL命令行工具后 , 使用status; 或/s 查看运行环境信息5、 切换连接数据库的语法 : use new_dbname; 6、 显示所有数据库 : show databases; 7、 显示数据库中的所有表 : show tables; 8、 显示某个表创建时的全部信息 : show create table table_name; 9、 查看表的具体属性信息及表中各字段的描述 Describe table_name; 缩写形式 : desc table_name; MySql中的SQL语句1 . 数据库创建 : Create database db_name; 数据库删除 : Drop database db_name; 删除时可先判断是否存在，写成 : drop database if exits db_name 2 . 建表 : 创建数据表的语法 : create table table_name (字段1 数据类型 , 字段2 数据类型); 例 : create table mytable (id int , username char(20)); 删表 : drop table table_name; 例 : drop table mytable; 3 . 添加数据 : Insert into 表名 [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..); 如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可不写 例 : insert into mytable (id,username) values (1,’zhangsan’); 4. 查询 : 查询所有数据 : select * from table_name; 查询指定字段的数据 : select 字段1 , 字段2 from table_name; 例 : select id,username from mytable where id=1 order by desc;多表查询语句————参照第17条实例 ### 5 . 更新指定数据 , 更新某一个字段的数据（注意，不是更新字段的名字） Update table_name set 字段名=’新值’ [, 字段2 =’新值’ , …..][where id=id_num] [order by 字段 顺序] 例 : update mytable set username=’lisi’ where id=1; Order语句是查询的顺序 , 如 : order by id desc(或asc) , 顺序有两种 : desc倒序(100—1,即从最新数据往后查询),asc(从1-100)，Where和order语句也可用于查询select 与删除delete 6 . 删除表中的信息 : 删除整个表中的信息 : delete from table_name; 删除表中指定条件的语句 : delete from table_name where 条件语句 ; 条件语句如 : id=3; 7 . 创建数据库用户 一次可以创建多个数据库用户如： CREATE USER username1 identified BY ‘password’ , username2 IDENTIFIED BY ‘password’…. 8 . 用户的权限控制：grant 库，表级的权限控制 : 将某个库中的某个表的控制权赋予某个用户 Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; 9 . 表结构的修改 （1）增加一个字段格式： alter table table_name add column (字段名 字段类型); —-此方法带括号 （2）指定字段插入的位置： alter table table_name add column 字段名 字段类型 after 某字段； 删除一个字段： alter table table_name drop字段名; （3）修改字段名称/类型 alter table table_name change 旧字段名 新字段名 新字段的类型; （4）改表的名字 alter table table_name rename to new_table_name; （5）一次性清空表中的所有数据 truncate table table_name; 此方法也会使表中的取号器(ID)从1开始 10 . 增加主键，外键，约束，索引。。。。(使用方法见17实例) ① 约束（主键Primary key、唯一性Unique、非空Not Null） ② 自动增张 auto_increment ③外键Foreign key—–与reference table_name(col_name列名)配合使用，建表时单独使用 ④ 删除多个表中有关联的数据—-设置foreign key 为set null —具体设置参考帮助文档 11 . 查看数据库当前引擎 SHOW CREATE TABLE table_name; 修改数据库引擎 ALTER TABLE table_name ENGINE=MyISAM | InnoDB; 12 . SQL语句运用实例: –1 建users表 create table users (id int primary key auto_increment,nikename varchar(20) not null unique,password varchar(100) not null,address varchar(200), reg_date timestamp not null default CURRENT_TIMESTAMP); –2 建articles表,在建表时设置外键 create table articles (id int primary key auto_increment,content longtext not null,userid int,constraint foreign key (userid) references users(id) on delete set null); ———————————————————————– –2.1 建articles表,建表时不设置外键 create table articles (id int primary key auto_increment,content longtext not null,userid int); –2.2 给articles表设置外键 alter table articles add constraint foreign key (userid) references users(id) on delete set null; ———————————————————————— –3. 向users表中插入数据,同时插入多条 insert into users (id,nikename,password,address) values (1,’lyh1’,’1234’,null),(10,’lyh22’,’4321’,’湖北武汉’),(null,’lyh333’,’5678’, ‘北京海淀’); –4. 向article中插入三条数据 insert into articles (id,content,userid) values (2,’hahahahahaha’,11),(null,’xixixixixix’,10),(13,’aiaiaiaiaiaiaiaiaiaiaiaia’,1),(14,’hohoahaoaoooooooooo’,10); –5. 进行多表查询，选择users表中ID=10的用户发布的所有留言及该用户的所有信息 select articles.id,articles.content,users. from users,articles where users.id=10 and articles.userid=users.id order by articles.id desc; –6. 查看数据库引擎类型 show create table users; –7. 修改数据库引擎类型 alter table users engine=MyISAM; —因为users表中ID被设置成外键，执行此句会出错 –8. 同表查询,已知一个条件的情况下.查询ID号大于用户lyh1的ID号的所有用户 select a.id,a.nikename,a.address from users a,users b where b.nikename=’lyh1’ and a.id&gt;b.id; ——也可写成 select id,nikename,address from users where id&gt;(select id from users where nikename=’lyh1’); –9. 显示年龄比领导还大的员工： select a.name from users a,users b where a.managerid=b.id and a.age&gt;b.age; 查询编号为2的发帖人: 先查articles表,得到发帖人的编号,再根据编号查users得到的用户名。 接着用关联查询. select from articles,users得到笛卡儿积,再加order by articles.id以便观察 使用select from articles,users where articles.id=2 筛选出2号帖子与每个用户的组合记录 再使用select from articles,users where articles.id=2 and articles.userid=users.id选出users.id等于2号帖的发帖人id的记录. 只取用户名:select user where user.id=(select userid from articles where article.id =2) 找出年龄比小王还大的人:假设小王是28岁,先想找出年龄大于28的人 select from users where age&gt;(select age from users where name=’xiaowang’); **要查询的记录需要参照表里面的其他记录: select a.name from users a,users b where b.name=’xiaowang’ and a.age&gt;b.age 表里的每个用户都想pk一下.select a.nickname,b.nickname from users a,users b where a.id&gt;b.id ; 更保险的语句:select a.nickname,b.nickname from (select from users order by id) a,(se lect from users order by id) b where a.id&gt;b.id ; 再查询某个人发的所有帖子. select b.* from articles a , articles b where a.id=2 and a.userid=b.userid 说明: 表之间存在着关系，ER概念的解释，用access中的示例数据库演示表之间的关系.只有innodb引擎才支持foreign key，mysql的任何引擎目前都不支持check约束。 字符集出现错误解决办法出现的问题： mysql&gt; update users -&gt; set username=’关羽’ -&gt; where userid=2; ERROR 1366 (HY000): Incorrect string value: ‘/xB9/xD8/xD3/xF0’ for column ‘usern ame’ at row 1 向表中插入中文字符时，出现错误。12345678 mysql&gt; select * from users; +--------+----------+ | userid | username | +--------+----------+ | 2 | ???? | | 3 | ???? | | 4 | ?í?ù | +--------+----------+ 3 rows in set (0.00 sec) 表中的中文字符位乱码。 解决办法： 使用命令： mysql&gt; status; ————– mysql Ver 14.12 Distrib 5.0.45, for Win32 (ia32) Connection id: 8 Current database: test Current user: root@localhost SSL: Not in use Using delimiter: ; Server version: 5.0.45-community-nt MySQL Community Edition (GPL) Protocol version: 10 Connection: localhost via TCP/IP Server characterset: latin1 Db characterset: latin1 Client characterset: gbk Conn. characterset: gbk TCP port: 3306 Uptime: 7 hours 39 min 19 sec Threads: 2 Questions: 174 Slow queries: 0 Opens: 57 Flush tables: 1 Open ta bles: 1 Queries per second avg: 0.006 ————– 查看mysql发现Server characterset，Db characterset的字符集设成了latin1，所以出现中文乱码。1234567 mysql&gt; show tables; +----------------+ | Tables_in_test | +----------------+ | users | +----------------+ 1 row in set (0.00 sec) 更改表的字符集。 mysql&gt; alter table users character set GBK; Query OK, 3 rows affected (0.08 sec) Records: 3 Duplicates: 0 Warnings: 0 查看表的结构： mysql&gt; show create users; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘users ‘ at line 1 mysql&gt; show create table users; +——-+———————————————————————– ——————————————————————————+ | Table | Create Table | +——-+———————————————————————– ——————————————————————————+ | users | CREATE TABLE users ( userid int(11) default NULL, username char(20) character set latin1 default NULL ) ENGINE=InnoDB DEFAULT CHARSET=gbk | +——-+———————————————————————– ——————————————————————————+ 1 row in set (0.00 sec) mysql&gt; desc users; +———-+———-+——+—–+———+——-+ | Field | Type | Null | Key | Default | Extra | +———-+———-+——+—–+———+——-+ | userid | int(11) | YES | | NULL | | | username | char(20) | YES | | NULL | | +———-+———-+——+—–+———+——-+ 2 rows in set (0.02 sec) 这时向表中插入中文然后有错误。 mysql&gt; insert into users values(88,’中文’); ERROR 1366 (HY000): Incorrect string value: ‘/xD6/xD0/xCE/xC4’ for column ‘usern ame’ at row 1 mysql&gt; insert into users values(88,’中文’); ERROR 1366 (HY000): Incorrect string value: ‘/xD6/xD0/xCE/xC4’ for column ‘usern ame’ at row 1 还要更改users表的username的字符集。 mysql&gt; alter table users modify username char(20) character set gbk; ERROR 1366 (HY000): Incorrect string value: ‘/xC0/xEE/xCB/xC4’ for column ‘usern ame’ at row 1 mysql&gt; alter table users modify username char(20) character set gbk; ERROR 1366 (HY000): Incorrect string value: ‘/xC0/xEE/xCB/xC4’ for column ‘usern ame’ at row 1 因为表中已经有数据，所以更改username字符集的操作没有成 清空users表中的数据 mysql&gt; truncate table users; Query OK, 3 rows affected (0.01 sec) 从新更改user表中username的字符集 mysql&gt; alter table users modify username char(20) character set gbk; Query OK, 0 rows affected (0.06 sec) Records: 0 Duplicates: 0 Warnings: 0 这时再插入中文字符，插入成。 mysql&gt; insert into users values(88,’中文’); Query OK, 1 row affected (0.01 sec) mysql&gt; select * from users; +——–+———-+ | userid | username | +——–+———-+ | 88 | 中文 | +——–+———-+ 1 row in set (0.00 sec) mysql&gt; 转载声明：本文转自http://hi.baidu.com/zhjlabm/blog/item/b939fc3307a1d445ad4b5fbd.html学习MySQL常用操作命令1、启动MySQL服务器实际上上篇已讲到如何启动MySQL。两种方法： 一是用winmysqladmin，如果机器启动时已自动运行，则可直接进入下一步操作。 二是在DOS方式下运行 d:mysqlbinmysqld 2、进入mysql交互操作界面在DOS方式下，运行： d:mysqlbinmysql出现: mysql 的提示符，此时已进入mysql的交互操作方式。如果出现 “ERROR 2003: Can′t connect to MySQL server on ′localhost′ (10061)“，说明你的MySQL还没有启动。 3、退出MySQL操作界面在mysql&gt;提示符下输入quit可以随时退出交互操作界面：mysql&gt; quitBye你也可以用control-D退出。 4、第一条命令mysql&gt; select version(),current_date();+—————-+—————–+| version() | current_date() |+—————-+—————–+| 3.23.25a-debug | 2001-05-17 |+—————-+—————–+1 row in set (0.01 sec)mysql&gt; 此命令要求mysql服务器告诉你它的版本号和当前日期。尝试用不同大小写操作上述命令，看结果如何。结果说明mysql命令的大小写结果是一致的。练习如下操作：mysql&gt;Select (20+5)4;mysql&gt;Select (20+5)4,sin(pi()/3);mysql&gt;Select (20+5)*4 AS Result,sin(pi()/3); (AS: 指定假名为Result) 5、多行语句一条命令可以分成多行输入，直到出现分号“；”为止： mysql&gt; select-&gt; USER()-&gt; ,-&gt; now()-&gt;;+——————–+———————+| USER() | now() |+——————–+———————+| ODBC@localhost | 2001-05-17 22:59:15 |+——————–+———————+1 row in set (0.06 sec)mysql&gt; 注意中间的逗号和最后的分号的使用方法。 6、一行多命令输入如下命令：mysql&gt; SELECT USER(); SELECT NOW();+——————+| USER() |+——————+| ODBC@localhost |+——————+1 row in set (0.00 sec)+———————+| NOW() |+———————+| 2001-05-17 23:06:15 |+———————+1 row in set (0.00 sec)mysql&gt; 注意中间的分号，命令之间用分号隔开。 7、显示当前存在的数据库mysql&gt; show databases;+———-+| Database |+———-+| mysql || test |+———-+2 row in set (0.06 sec)mysql&gt; 8、选择数据库并显示当前选择的数据库mysql&gt; USE mysqlDatabase changedmysql&gt;(USE 和 QUIT 命令不需要分号结束。）mysql&gt; select database();+—————+| database() |+—————+| mysql |+—————+1 row in set (0.00 sec) 9、显示当前数据库中存在的表mysql&gt; SHOW TABLES; 10、显示表(db)的内容mysql&gt;select * from db; 11、命令的取消当命令输入错误而又无法改变（多行语句情形）时，只要在分号出现前就可以用 c来取消该条命令mysql&gt; select *-&gt; user()-&gt; cmysql&gt;这是一些最常用的最基本的操作命令，通过多次练习就可以牢牢掌捂了 ========================================================================== mysql命令测试环境：mysql 5.0.45【注：可以在mysql中通过mysql&gt; SELECT VERSION();来查看数据库版本】整理：leo 一、连接MYSQL。格式： mysql -h主机地址 -u用户名 －p用户密码 1、连接到本机上的MYSQL。首先打开DOS窗口，然后进入目录mysql/bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码.如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt; 2、连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令：mysql -h110.110.110.110 -u root -p 123; （注:u与root之间可以不用加空格，其它也一样） 3、退出MYSQL命令： exit （回车） 二、修改密码。格式：mysqladmin -u用户名 -p旧密码 password 新密码 1、给root加个密码ab12。首先在DOS下进入目录mysql/bin，然后键入以下命令mysqladmin -u root -password ab12注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 2、再将root的密码改为djg345。mysqladmin -u root -p ab12 password djg345三、增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：grant select,insert,update,delete on . to [email=test1@”%]test1@”%[/email]” Identified by “abc”;但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。 2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。grant select,insert,update,delete on mydb. to [email=test2@localhost]test2@localhost[/email] identified by “abc”;如果你不想test2有密码，可以再打一个命令将密码消掉。grant select,insert,update,delete on mydb. to [email=test2@localhost]test2@localhost[/email] identified by “”; 下篇我是MYSQL中有关数据库方面的操作。注意：你必须首先登录到MYSQL中，以下操作都是在MYSQL的提示符下进行的，而且每个命令以分号结束。一、操作技巧 1、如果你打命令时，回车后发现忘记加分号，你无须重打一遍命令，只要打个分号回车就可以了。也就是说你可以把一个完整的命令分成几行来打，完后用分号作结束标志就OK。 2、你可以使用光标上下键调出以前的命令。二、显示命令 1、显示当前数据库服务器中的数据库列表：mysql&gt; SHOW DATABASES;注意：mysql库里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。 2、显示数据库中的数据表：mysql&gt; USE 库名；mysql&gt; SHOW TABLES; 3、显示数据表的结构：mysql&gt; DESCRIBE 表名; 4、建立数据库：mysql&gt; CREATE DATABASE 库名; 5、建立数据表：mysql&gt; USE 库名;mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1)); 6、删除数据库：mysql&gt; DROP DATABASE 库名; 7、删除数据表：mysql&gt; DROP TABLE 表名； 8、将表中记录清空：mysql&gt; DELETE FROM 表名; 9、显示表中的记录：mysql&gt; SELECT * FROM 表名; 10、往表中插入记录：mysql&gt; INSERT INTO 表名 VALUES (”hyq”,”M”); 11、更新表中数据：mysql-&gt; UPDATE 表名 SET 字段名1=’a’,字段名2=’b’ WHERE 字段名3=’c’; 12、用文本方式将数据装入数据表中：mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE 表名; 13、导入.sql文件命令：mysql&gt; USE 数据库名;mysql&gt; SOURCE d:/mysql.sql; 14、命令行修改root密码：mysql&gt; UPDATE mysql.user SET password=PASSWORD(’新密码’) WHERE User=’root’;mysql&gt; FLUSH PRIVILEGES; 15、显示use的数据库名：mysql&gt; SELECT DATABASE(); 16、显示当前的user：mysql&gt; SELECT USER(); 三、一个建库和建表以及插入数据的实例drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(id int(3) auto_increment not null primary key,name char(10) not null,address varchar(50) default ‘深圳’,year date); //建表结束//以下为插入字段insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。 （1）你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c://下，并在DOS状态进入目录[url=file:////mysql//bin]//mysql//bin[/url]，然后键入以下命令：mysql -uroot -p密码 &lt; c://school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 （2）或者进入命令行后使用 mysql&gt; source c://school.sql; 也可以将school.sql文件导入数据库中。 将文本数据转到数据库中 1、文本数据应符合的格式：字段数据之间用tab键隔开，null值用[url=file:////n]//n[/url]来代替.例：3 rose 大连二中 1976-10-104 mike 大连一中 1975-12-23假设你把这两组数据存为school.txt文件，放在c盘根目录下。 2、数据传入命令 load data local infile “c://school.txt” into table 表名;注意：你最好将文件复制到[url=file:////mysql//bin]//mysql//bin[/url]目录下，并且要先用use命令打表所在的库。 备份数据库 1.导出整个数据库导出文件默认是存在mysql/bin目录下mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 导入数据库例如：数据库名为 dbTest首先，进入mysqlmysql -uroot -p123456然后，创建数据库create dbTestexit最后，导入数据库mysql -uroot -p123456 dbTest &lt; dbTest_bk.sql 数据库及表导出导入示例：导出数据库mysqldump -u root -p123456 gameTop &gt; gameTop_db.sql 导出数据库的表mysqldump -u -p123456 root gameTop gametop800 &gt; gameTop_table.sql 导出数据库的特定表mysqldump -u root -p123456 gameTop –table gametop800 &gt; gameTop_table.sql 导出数据库（只导结构，不要数据）mysqldump -u root -p123456 –opt -d gameTop &gt; gameTop_db.sql或者mysqldump -u root -p123456 -d gameTop &gt; gameTop_db.sql 导出数据库（只导数据，不要结构）mysqldump -u root -p123456 -t gameTop &gt; gameTop_db.sql 注：不加 -d 和 -t 则既导出结构，也导出数据mysqldump导出抛出异常：mysqldump: Got error: 1044: Access denied for user ‘username’@’%’ to database ‘dbname’ when using LOCK TABLES解决办法，添加参数 –skip-lock-tables：mysqldump –skip-lock-tables -h172.88.12.102 -username-pAnJnVs3C2tYXyTwV dbname&gt; dbname_bk.sql 导入数据库：登录MySQL: mysql -uroot -p123456创建数据库： create database gameTop; 导入数据库：mysql -uroot -p123456 gameTop &lt; gameTop_db.sql 导入数据库表：mysql -uroot -p123456 gameTop gametop800 &lt; gameTop_table.sql 导入数据库表：mysql -uroot -p123456 gameTop &lt; gameTop_table.sql （不指定表名） 转载声明：本文转自http://blog.csdn.net/networld2002/archive/2009/04/23/4103407.aspx 1:使用SHOW语句找出在服务器上当前存在什么数据库：mysql&gt; SHOW DATABASES; 2:创建一个数据库MYSQLDATAmysql&gt; CREATE DATABASE MYSQLDATA; 3:选择你所创建的数据库mysql&gt; USE MYSQLDATA; (按回车键出现Database changed 时说明操作成功！) 4:查看现在的数据库中存在什么表mysql&gt; SHOW TABLES; 5:创建一个数据库表mysql&gt; CREATE TABLE MYTABLE (name VARCHAR(20), sex CHAR(1)); 6:显示表的结构：mysql&gt; DESCRIBE MYTABLE; 7:往表中加入记录mysql&gt; insert into MYTABLE values (”hyq”,”M”); 8:用文本方式将数据装入数据库表中（例如D:/mysql.txt）mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE MYTABLE; 9:导入.sql文件命令（例如D:/mysql.sql）mysql&gt;use database;mysql&gt;source d:/mysql.sql; 10:删除表mysql&gt;drop TABLE MYTABLE; 11:清空表mysql&gt;delete from MYTABLE; 12:更新表中数据mysql&gt;update MYTABLE set sex=”f” where name=’hyq’; 以下是无意中在网络看到的使用MySql的管理心得,在windows中MySql以服务形式存在，在使用前应确保此服务已经启动，未启动可用net start mysql命令启动。而Linux中启动时可用“/etc/rc.d/init.d/mysqld start”命令，注意启动者应具有管理员权限。刚安装好的MySql包含一个含空密码的root帐户和一个匿名帐户，这是很大的安全隐患，对于一些重要的应用我们应将安全性尽可能提高，在这里应把匿名帐户删除、 root帐户设置密码，可用如下命令进行：use mysql;delete from User where User=””;update User set Password=PASSWORD(’newpassword’) where User=’root’; 如果要对用户所用的登录终端进行限制，可以更新User表中相应用户的Host字段，在进行了以上更改后应重新启动数据库服务，此时登录时可用如下类似命令：mysql -uroot -p;mysql -uroot -pnewpassword;mysql mydb -uroot -p;mysql mydb -uroot -pnewpassword;上面命令参数是常用参数的一部分，详细情况可参考文档。此处的mydb是要登录的数据库的名称。在 进行开发和实际应用中，用户不应该只用root用户进行连接数据库，虽然使用root用户进行测试时很方便，但会给系统带来重大安全隐患，也不利于管理技 术的提高。我们给一个应用中使用的用户赋予最恰当的数据库权限。如一个只进行数据插入的用户不应赋予其删除数据的权限。MySql的用户管理是通过 User表来实现的，添加新用户常用的方法有两个，一是在User表插入相应的数据行，同时设置相应的权限；二是通过GRANT命令创建具有某种权限的用 户。其中GRANT的常用用法如下： grant all on mydb. to NewUserName@HostName identified by “password” ;grant usage on . to NewUserName@HostName identified by “password”;grant select,insert,update on mydb. to NewUserName@HostName identified by “password”;grant update,delete on mydb.TestTable to NewUserName@HostName identified by “password”; 若 要给此用户赋予他在相应对象上的权限的管理能力，可在GRANT后面添加WITH GRANT OPTION选项。而对于用插入User表添加的用户，Password字段应用PASSWORD 函数进行更新加密，以防不轨之人窃看密码。对于那些已经不用的用户应给予清除，权限过界的用户应及时回收权限，回收权限可以通过更新User表相应字段， 也可以使用REVOKE操作。下面给出本人从其它资料(www.cn-Java.com)获得的对常用权限的解释：全局管理权限：FILE: 在MySQL服务器上读写文件。PROCESS: 显示或杀死属于其它用户的服务线程。RELOAD: 重载访问控制表，刷新日志等。SHUTDOWN: 关闭MySQL服务。数据库/数据表/数据列权限：ALTER: 修改已存在的数据表(例如增加/删除列)和索引。CREATE: 建立新的数据库或数据表。DELETE: 删除表的记录。DROP: 删除数据表或数据库。INDEX: 建立或删除索引。INSERT: 增加表的记录。SELECT: 显示/搜索表的记录。UPDATE: 修改表中已存在的记录。特别的权限：ALL: 允许做任何事(和root一样)。USAGE: 只允许登录–其它什么也不允许做。","tags":[]},{"title":"vue.js笔记","date":"2017-05-01T03:29:40.000Z","path":"2017/05/01/vue-js笔记/","text":"每多学一点知识，就少写一行代码。1、Vue.js使用vue-resource实现ajax请求1234567891011121314151617181920/** * Created by gequn06 on 2017/3/20. */import Vue from 'vue/dist/vue.common.js';import VueResource from 'vue-resource';Vue.use(VueResource);new Vue(&#123; el: '#doctorWrap', data: &#123; someData : null &#125;, created :function () &#123; this.$http.get('/public/js/data.json').then(function(response)&#123; console.log(response) // get body data this.someData = response.body.sites; &#125;); &#125;&#125;); 2、Vue.js引用css123&lt;style scoped&gt; @import '../assets/hello.css';&lt;/style&gt; 3、过滤器123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div v-bind:id=\"msg | filterA | filterB\"&gt;111&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hello', data () &#123; return &#123; msg: 'thanks' &#125; &#125;, filters: &#123; filterA: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;, filterB: function (value) &#123; if (!value) return '' value = value.toString(); return value.slice(0, 1) + value.charAt(2).toUpperCase() + value.slice(2); &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 4、Computed Properties and Watchers12345678910111213141516171819&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 5、component lists rendered with v-for should have explicit keys12345678910v-for需要绑定:key&lt;el-select v-model=\"value\" placeholder=\"请选择\" class=\"meeting-duration-select\"&gt; &lt;el-option v-for=\"(item,index) in options\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\"&gt; &lt;/el-option&gt;&lt;/el-select&gt;","tags":[]},{"title":"项目中的常见问题题_vue_store","date":"2017-04-26T02:47:16.000Z","path":"2017/04/26/项目中的常见问题题-vue-store/","text":"我会把我做关于模仿微博的这个项目遇到的一些问题公开在这里，遇到不对的地方请指教，发送邮件wang1348168417@gmail.com，或者扫我的微信二维码。一个简单的状态管理 单一数据源:1234567const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 每当 sourceOfTruth 发生变化, vmA 和 vmB 都会自动更新它们的视图. 子组件可以通过 this.$root.$data 访问数据. 现在我们有了单一的数据源, 但是调试会很困难. 因为无论何时数据源发生变化都会改变程序, 但是没有任何迹象表明变化发生. store pattern为了解决上述问题, 我们可以引入 store pattern:1234567891011121314var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; this.debug &amp;&amp; console.log('setMessageAction triggered with', newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; this.debug &amp;&amp; console.log('clearMessageAction triggered') this.state.message = 'action B triggered' &#125;&#125; 所有的数据改变都发生 store 内. 这种集中的状态管理模式使我们很容易记录变化发生, 如何发生.除了单一的数据源外, 每个 vue 实例或组件也可以有其私有状态:123456789101112var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 使用Vuex12345678910111213141516171819// 如果 Vuex 不是全局的, 那么确保调用 Vue.use(Vuex) 使 Vuex 生效.const store = new Vuex.Store(&#123; // 数据源 state: &#123; count: 0 &#125;, // 数据操作 mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)// 触发数据变化操作store.commit('increment')console.log(store.state.count) // -&gt; 1 Statestore 自动注入到子组件中 通常我们通过计算属性来访问 store 中的数据, 这样就能感知到数据发生变化.根组件的 store 属性会注入到其所有的子组件中. (通过 Vue.use(Vuex) 生效)1234567891011121314151617const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count() &#123; // 子组件通过 this.$store 访问父组件的 store return this.$store.state.count &#125; &#125;&#125;new Vue(&#123; // 父对象中的 store 自动注入到子组件 store, componets: &#123; Counter &#125;&#125;) mapState如果 store 中有许多数据需要访问, 每个数据都需要定义一个计算属性会非常麻烦. Vuex 提供了 mapState 来简化计算属性的定义.123456789101112131415161718import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // es6 箭头函数更加简洁 count: state =&gt; state.count, // 字符串 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了访问组件的 `this`, 必须使用普通的函数 // 箭头函数会绑定 `this` 到 `mapState` 的参数这个对象 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 如果计算属性和 store 中数据是一一对应的, 可以使用更简单的字符串数组:1234computed: mapState([ // map this.count to store.state.count 'count']) es6 的扩展操作符使用 mapState 返回一个对象, 如果组件还有私有的计算属性, 通常我们可以使用 _.extend({localComputed}, mapState(…)) 这种方式合并对象已得到最终的 computed. 使用 es6 的扩展操作符可以简化:1234567computed: &#123; localComputed()&#123; /* ... */&#125;, // 通过扩展操作符扩展 computed 对象 ...mapState(&#123; // ... &#125;)&#125; Getters通常计算属性是基于一段 store 数据的代码, 比如过滤一个列表并计数:12345computed: &#123; doneTodoCount() &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果我们需要复用这段代码, 基本就是重构提取出一个函数, 但是这样还不是很理想.123456789101112131415161718192021Vuex 在 store 中提供了 getters:const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125;, doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; &#125;&#125;)// 通过 `store.getters` 访问store.getters.doneTodosCount 上面的计算属性就可以改成:12345computed: &#123; doneTodoCount() &#123; return this.$store.getters.doneTodoCount &#125;&#125; mapGetters同 state 的 mapState 类似, getters 也有 mapGetters 来简化计算属性的定义12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // mix the getters into computed with object spread operator ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 使用对象可以自定义对应关系1234mapGetters(&#123; // map this.doneCount to store.getters.doneTodosCount doneCount: 'doneTodosCount'&#125;) MutationsVuex 中的 state 只能通过 mutations 来改变. mutations 很像事件, 都有一个类型和处理函数. 处理函数是真正改变 state 的地方, 并以 state 作为第一个参数.1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 改变 state state.count++ &#125; &#125;&#125;) 就是事件一样, 我们不能直接调用处理函数, 而是要通过 store.commit(type) 来触发 mutation 处理函数. store.commit(‘increment’)带 playload commit 我们可以将处理函数的参数放到第二个参数 playload 中:12345678910111213mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123;amount: 10&#125;)对象风格 commitstore.commit(&#123; type: 'increment', playload: &#123; amount: 10 &#125;&#125;) 静默模式默认情况下, 每一次 commit 都会发送到插件 (比如: devtools) 中. 可能你会希望某些 commit 不被记录. 这时候可以传递第三个参数以设置为静默模式:123456789store.commit('increment', &#123; amount: 1&#125;, &#123; silent: true &#125;)// 对象风格 commitstore.commit(&#123; type: 'increment', amount: 1&#125;, &#123; silent: true &#125;) Mutations 要遵守 Vue 的响应式规则 即: 提前初始化所有的状态值添加新的属性到对象时, 你应该:使用 Vue.set(obj, ‘newProp’, 123) 或直接替换新的对象: state.obj = {…state.obj, newProp: 123}使用常量为 Mutations 命名 使用常量为 Mutations 命名是各种 Flux 实现常用的模式. 将所有常量放到一个文件中, 我们能看到整个程序有什么情况数据会发生变化.1234567891011121314151617// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // es6 特性 computed property name // 属性名称运行时确定 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) Mutations 必须是同步的异步 mutations 调用违反了所有的状态变化必须在 store 中进行的规定. 比如:1234567mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125; 当上例中状态变化时, someMutation 已经结束了. 这时候如果有其他状态变化的操作发生, devtools 记录下来的状态变化就是错误的. mapMutations我们可以通过 this.$store.commit(‘xxx’) 在组件中调用 mutations, 一般我们将这些调用分装到 methods 中, 同时 Vuex 也提供了 mapMutations 函数简化 methods 定义:12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // 映射 this.increment() 到 this.$store.commit('increment') ]), ...mapMutations(&#123; add: 'increment' // map this.add() to this.$store.commit('increment') &#125;) &#125;&#125; Actions异步的 mutations 使程序的状态变化难以追踪. 为了解决异步操作, Vuex 引入了 actions.actions 跟 mutations 非常像, 它们的不同之处在于:1234567891011121314151617actions 不改变 state, 而是 commit mutationsactions 可以包含任意的异步操作const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) actions 接收一个 context 对象作为参数, context 可以访问 commit, getters, state, 但是它不是 store 对象.通常, 我们会使用 es6 的参数结构语法来简化代码:12345actions: &#123; increment(&#123;commit&#125;) &#123; commit('increment') &#125;&#125; Dispatching Actionsactions 通过 store.dispatch 来触发: store.dispatch(‘increment’)dispatch 也支持 commit 中的 playload 参数以及对象风格的调用方式.12345678910// dispatch with a payloadstore.dispatch('incrementAsync', &#123; amount: 10&#125;)// dispatch with an objectstore.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) mapActions类似 mapMutations Actions 组合 actions 通常是异步的, 我们怎么来组合多个 actions 来执行复杂的操作? 首先我们需要知道的是 store.dispatch 返回 actions 中处理函数的返回值, 因此我们可以返回一个 Promise:123456789101112131415161718192021222324252627282930actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;, actionB (&#123; dispatch, commit &#125;) &#123; // 组合 return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125;使用 async/await 语法, 可以简化为:// 假设 getData() 和 getOtherData() 返回 Promisesactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // wait for actionA to finish commit('gotOtherData', await getOtherData()) &#125;&#125; Modules当我们的程序足够大时, store 也会变得非常大, 其中的 state, getters, mutations, actions 也会非常大. 因此 Vuex 允许我们将 store 分成几个 modules, 每个 modules 都有自己的 state, getters, mutations, actions 甚至它自己的 modules.12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA's statestore.state.b // -&gt; moduleB's state Modules 当前状态在 modules 中, getters 和 mutations 的第一个参数都是 modules 的 state, 同样 actions 的 context.state 也是 modules 的 state, 根节点的状态可以通过 context.rootState 访问到. getters 的可以通过第三个参数访问 $rootState:12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; ### 命名空间 modules 的 state 放到根节点的对应的属性中, 而 actions, mutations 和 getters 没有命名空间. 所以多个 modules 可以对同一个 commit 或 dispatch 做响应. 因此必须自己通过前缀或后缀来避免命名冲突. 动态 Modules 注册1234store.registerModule('myModule', &#123; // ...&#125;)keep learning","tags":[]},{"title":"Es6新特性","date":"2017-04-18T07:36:32.000Z","path":"2017/04/18/Es6新特性/","text":"####ECMAScript 6简介 ###1.Class基本语法 ##概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。12345678class Bar &#123; doStuff() &#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // \"stuff\" 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。1234567891011121314151617181920class Point &#123; constructor()&#123; // ... &#125; toString()&#123; // ... &#125; toValue()&#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678910111213class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;);prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 class Point { constructor(x, y) { // … } toString() { // … }} Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [“constructor”,”toString”] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。 var Point = function (x, y) { // …}; Point.prototype.toString = function() { // …}; Object.keys(Point.prototype)// [“toString”]Object.getOwnPropertyNames(Point.prototype)// [“constructor”,”toString”] 上面代码采用ES5的写法，toString方法就是可枚举的。 类的属性名，可以采用表达式。 let methodName = “getArea”;class Square{ constructor(length) { // … } methodName { // … }} 上面代码中，Square类的方法名getArea，是从表达式得到的。 constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor() {}constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 class Foo { constructor() { return Object.create(null); }} new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 class Foo { constructor() { return Object.create(null); }} Foo()// TypeError: Class constructor Foo cannot be invoked without ‘new’ 类的实例对象生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 // 报错var point = Point(2, 3); // 正确var point = new Point(2, 3); 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 //定义类class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’; } } var point = new Point(2, 3); point.toString() // (2, 3) point.hasOwnProperty(‘x’) // truepoint.hasOwnProperty(‘y’) // truepoint.hasOwnProperty(‘toString’) // falsepoint.proto.hasOwnProperty(‘toString’) // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。 与ES5一样，类的所有实例共享一个原型对象。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto === p2.proto//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以proto属性是相等的。 这也意味着，可以通过实例的proto属性为Class添加方法。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto.printName = function () { return ‘Oops’ }; p1.printName() // “Oops”p2.printName() // “Oops” var p3 = new Point(4,2);p3.printName() // “Oops” 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。 new Foo(); // ReferenceErrorclass Foo {}上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 { let Foo = class {}; class Bar extends Foo { }}上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 Class表达式与函数一样，类也可以使用表达式的形式定义。 const MyClass = class Me { getClassName() { return Me.name; }};上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined上面代码表示，Me只在Class内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { / … / };采用Class表达式，可以写出立即执行的Class。 let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); }}(‘张三’); person.sayName(); // “张三”上面代码中，person是一个立即执行的类的实例。 私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 class Widget { // 公有方法 foo (baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // …}上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 class Widget { foo (baz) { bar.call(this, baz); } // …} function bar(baz) { return this.snaf = baz;}上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 const bar = Symbol(‘bar’);const snaf = Symbol(‘snaf’); export default class myClass{ // 公有方法 foo(baz) { thisbar; } // 私有方法 bar { return this[snaf] = baz; } // …};上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = ‘there’) { this.print(Hello ${name}); } print(text) { console.log(text); }} const logger = new Logger();const { printName } = logger;printName(); // TypeError: Cannot read property ‘print’ of undefined上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // …}另一种解决方法是使用箭头函数。 class Logger { constructor() { this.printName = (name = ‘there’) =&gt; { this.print(Hello ${name}); }; } // …}还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 function selfish (target) { const cache = new WeakMap(); const handler = { get (target, key) { const value = Reflect.get(target, key); if (typeof value !== ‘function’) { return value; } if (!cache.has(value)) { cache.set(value, value.bind(target)); } return cache.get(value); } }; const proxy = new Proxy(target, handler); return proxy;} const logger = selfish(new Logger());严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。 name属性由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 class Point {}Point.name // “Point”name属性总是返回紧跟在class关键字后面的类名。 Class的继承基本用法Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 class ColorPoint extends Point {}上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ‘ ‘ + super.toString(); // 调用父类的toString() }}上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 class Point { / … / } class ColorPoint extends Point { constructor() { }} let cp = new ColorPoint(); // ReferenceError上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 constructor(…args) { super(…args);}另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 class Point { constructor(x, y) { this.x = x; this.y = y; }} class ColorPoint extends Point { constructor(x, y, color) { this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 }}上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 let cp = new ColorPoint(25, 8, ‘green’); cp instanceof ColorPoint // truecp instanceof Point // true上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。 类的prototype属性和proto属性大多数浏览器的ES5实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 class A {} class B extends A {} B.proto === A // trueB.prototype.proto === A.prototype // true上面代码中，子类B的proto属性指向父类A，子类B的prototype属性的proto属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 class A {} class B {} // B的实例继承A的实例Object.setPrototypeOf(B.prototype, A.prototype);const b = new B(); // B的实例继承A的静态属性Object.setPrototypeOf(B, A);const b = new B();《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 Object.setPrototypeOf = function (obj, proto) { obj.proto = proto; return obj;}因此，就得到了上面的结果。 Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.proto = A.prototype; Object.setPrototypeOf(B, A);// 等同于B.proto = A;这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（proto属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 Object.create(A.prototype);// 等同于B.prototype.proto = A.prototype;Extends 的继承目标extends关键字后面可以跟多种类型的值。 class B extends A {}上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论三种特殊情况。 第一种特殊情况，子类继承Object类。 class A extends Object {} A.proto === Object // trueA.prototype.proto === Object.prototype // true这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种特殊情况，不存在任何继承。 class A {} A.proto === Function.prototype // trueA.prototype.proto === Object.prototype // true这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.proto指向构造函数（Object）的prototype属性。 第三种特殊情况，子类继承null。 class A extends null {} A.proto === Function.prototype // trueA.prototype.proto === undefined // true这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的proto指向Function.prototype，即实质上执行了下面的代码。 class C extends null { constructor() { return Object.create(null); }}Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 Object.getPrototypeOf(ColorPoint) === Point// true因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 class A {} class B extends A { constructor() { super(); }}上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 class A { constructor() { console.log(new.target.name); }}class B extends A { constructor() { super(); }}new A() // Anew B() // B上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 class A {} class B extends A { m() { super(); // 报错 }}上面代码中，super()用在B类的m方法之中，就会造成句法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 class A { p() { return 2; }} class B extends A { constructor() { super(); console.log(super.p()); // 2 }} let b = new B();上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 class A { constructor() { this.p = 2; }} class B extends A { get m() { return super.p; }} let b = new B();b.m // undefined上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到。 class A {}A.prototype.x = 2; class B extends A { constructor() { super(); console.log(super.x) // 2 }} let b = new B();上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。 ES6 规定，通过super调用父类的方法时，super会绑定子类的this。 class A { constructor() { this.x = 1; } print() { console.log(this.x); }} class B extends A { constructor() { super(); this.x = 2; } m() { super.print(); }} let b = new B();b.m() // 2上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 class A { constructor() { this.x = 1; }} class B extends A { constructor() { super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 }} let b = new B();上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 class Parent { static myMethod(msg) { console.log(‘static’, msg); } myMethod(msg) { console.log(‘instance’, msg); }} class Child extends Parent { static myMethod(msg) { super.myMethod(msg); } myMethod(msg) { super.myMethod(msg); }} Child.myMethod(1); // static 1 var child = new Child();child.myMethod(2); // instance 2上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 class A {} class B extends A { constructor() { super(); console.log(super); // 报错 }}上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 class A {} class B extends A { constructor() { super(); console.log(super.valueOf() instanceof B); // true }} let b = new B();上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 var obj = { toString() { return “MyObject: “ + super.toString(); }}; obj.toString(); // MyObject: [object Object]实例的proto属性子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。 var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, ‘red’); p2.proto === p1.proto // falsep2.proto.proto === p1.proto // true上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的proto.proto属性，可以修改父类实例的行为。 p2.proto.proto.printName = function () { console.log(‘Ha’);}; p1.printName() // “Ha”上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。 Boolean()Number()String()Array()Date()Function()RegExp()Error()Object()以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 function MyArray() { Array.apply(this, arguments);} MyArray.prototype = Object.create(Array.prototype, { constructor: { value: MyArray, writable: true, configurable: true, enumerable: true }});上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。 var colors = new MyArray();colors[0] = “red”;colors.length // 0 colors.length = 0;colors[0] // “red”之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 下面的例子中，我们想让一个普通对象继承Error对象。 var e = {}; Object.getOwnPropertyNames(Error.call(e))// [ ‘stack’ ] Object.getOwnPropertyNames(e)// []上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 class MyArray extends Array { constructor(…args) { super(…args); }} var arr = new MyArray();arr[0] = 12;arr.length // 1 arr.length = 0;arr[0] // undefined上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 class VersionedArray extends Array { constructor() { super(); this.history = [[]]; } commit() { this.history.push(this.slice()); } revert() { this.splice(0, this.length, …this.history[this.history.length - 1]); }} var x = new VersionedArray(); x.push(1);x.push(2);x // [1, 2]x.history // [[]] x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3] x.revert();x // [1, 2]上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。 下面是一个自定义Error子类的例子。 class ExtendableError extends Error { constructor(message) { super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; }} class MyError extends ExtendableError { constructor(m) { super(m); }} var myerror = new MyError(‘ll’);myerror.message // “ll”myerror instanceof Error // truemyerror.name // “MyError”myerror.stack// Error// at MyError.ExtendableError// …注意，继承Object的子类，有一个行为差异。 class NewObj extends Object{ constructor(){ super(…arguments); }}var o = new NewObj({attr: true});console.log(o.attr === true); // false上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。 Class的取值函数（getter）和存值函数（setter）与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 class MyClass { constructor() { // … } get prop() { return ‘getter’; } set prop(value) { console.log(‘setter: ‘+value); }} let inst = new MyClass(); inst.prop = 123;// setter: 123 inst.prop// ‘getter’上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的descriptor对象上的。 class CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; }} var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, “html”);“get” in descriptor // true“set” in descriptor // true上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。 Class 的 Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 class Foo { constructor(…args) { this.args = args; } Symbol.iterator {for (let arg of this.args) { yield arg;}}} for (let x of new Foo(‘hello’, ‘world’)) { console.log(x);}// hello// world上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo { static classMethod() { return ‘hello’; }} Foo.classMethod() // ‘hello’ var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo {} Bar.classMethod(); // ‘hello’上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo { static classMethod() { return super.classMethod() + ‘, too’; }} Bar.classMethod();Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。 class Foo {} Foo.prop = 1;Foo.prop // 1上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。 // 以下两种写法都无效class Foo { // 写法一 prop: 2 // 写法二 static prop: 2} Foo.prop // undefinedES7有一个静态属性的提案，目前Babel转码器支持。 这个提案对实例属性和静态属性，都规定了新的写法。 （1）类的实例属性 类的实例属性可以用等式，写入类的定义之中。 class MyClass { myProp = 42; constructor() { console.log(this.myProp); // 42 }}上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; }}上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。 class ReactCounter extends React.Component { state = { count: 0 };}这种写法比以前更清晰。 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } state;}（2）类的静态属性 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 class MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myStaticProp); // 42 }}同样的，这个新写法大大方便了静态属性的表达。 // 老写法class Foo {}Foo.prop = 1; // 新写法class Foo { static prop = 1;}上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。 类的私有属性目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。 class Point { #x; constructor(x = 0) { #x = +x; } get x() { return #x } set x(value) { #x = +value }}上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。 私有属性可以指定初始值，在构造函数执行时进行初始化。 class Point { #x = 0; constructor() { #x; // 0 }}之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。 class Foo { #a; #b; #sum() { return #a + #b; } printSum() { console.log(#sum()); } constructor(a, b) { #a = a; #b = b; }}new.target属性new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(‘必须使用new生成实例’); }} // 另一种写法function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error(‘必须使用new生成实例’); }} var person = new Person(‘张三’); // 正确var notAPerson = Person.call(person, ‘张三’); // 报错上面代码确保构造函数只能通过new命令调用。 Class内部调用new.target，返回当前Class。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; }} var obj = new Rectangle(3, 4); // 输出 true需要注意的是，子类继承父类时，new.target会返回子类。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); // … }} class Square extends Rectangle { constructor(length) { super(length, length); }} var obj = new Square(3); // 输出 false上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error(‘本类不能实例化’); } }} class Rectangle extends Shape { constructor(length, width) { super(); // … }} var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。 Mixin模式的实现Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。 function mix(…mixins) { class Mix {} for (let mixin of mixins) { copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); } return Mix;} function copyProperties(target, source) { for (let key of Reflect.ownKeys(source)) { if ( key !== “constructor” &amp;&amp; key !== “prototype” &amp;&amp; key !== “name” ) { let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); } }}上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 class DistributedEdit extends mix(Loggable, Serializable) { // …}","tags":[]},{"title":"yilia配置","date":"2017-04-11T02:41:53.000Z","path":"2017/04/11/yilia配置/","text":"主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份 Headermenu: 主页: / 随笔: /tags/随笔/ SubNavsubnav: github: “#” weibo: “#” rss: “#” zhihu: “#” #qq: “#” #weixin: “#” #jianshu: “#” #douban: “#” #segmentfault: “#” #bilibili: “#” #acfun: “#” #mail: “mailto:litten225@qq.com” #facebook: “#” #google: “#” #twitter: “#” #linkedin: “#” rss: /atom.xml 是否需要修改 root 路径如果您的网站存放在子目录中，例如 http://yoursite.com/blog，请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: Content文章太长，截断按钮文字excerpt_link: more 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: ‘展开全文’ 数学公式mathjax: false 是否在新窗口打开链接open_in_new: false 打赏请在需要打赏的文章的md文件头部，设置属性reward: true打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2 打赏wordingreward_wording: ‘谢谢你请我吃糖果’ 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: 微信二维码图片地址weixin: Miscellaneousbaidu_analytics: ‘’google_analytics: ‘’favicon: /favicon.png #你的头像urlavatar: #是否开启分享share_jia: true #是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key #若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: 头像上面的背景颜色 header: ‘#4d4d4d’ 右滑板块背景 slider: ‘linear-gradient(200deg,#a0cfe4,#e8c37e)’ slider的设置slider: 是否默认展开tags板块 showTags: false 智能菜单如不需要，将该对应项置为false比如#smart_menu: friends: falsesmart_menu: innerArchive: ‘所有文章’ friends: ‘友链’ aboutme: ‘关于我’ friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/ aboutme: 很惭愧只做了一点微小的工作谢谢大家","tags":[]},{"title":"我的第一个博客","date":"2017-04-08T03:11:41.000Z","path":"2017/04/08/我的第一个博客/","text":"您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！","tags":[]}]