[{"title":"Hello World","date":"2017-05-08T02:18:40.242Z","path":"2017/05/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"vue.js笔记","date":"2017-05-01T03:29:40.000Z","path":"2017/05/01/vue-js笔记/","text":"每多学一点知识，就少写一行代码。1、Vue.js使用vue-resource实现ajax请求1234567891011121314151617181920/** * Created by gequn06 on 2017/3/20. */import Vue from 'vue/dist/vue.common.js';import VueResource from 'vue-resource';Vue.use(VueResource);new Vue(&#123; el: '#doctorWrap', data: &#123; someData : null &#125;, created :function () &#123; this.$http.get('/public/js/data.json').then(function(response)&#123; console.log(response) // get body data this.someData = response.body.sites; &#125;); &#125;&#125;); 2、Vue.js引用css123&lt;style scoped&gt; @import '../assets/hello.css';&lt;/style&gt; 3、过滤器123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div v-bind:id=\"msg | filterA | filterB\"&gt;111&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hello', data () &#123; return &#123; msg: 'thanks' &#125; &#125;, filters: &#123; filterA: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;, filterB: function (value) &#123; if (!value) return '' value = value.toString(); return value.slice(0, 1) + value.charAt(2).toUpperCase() + value.slice(2); &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 4、Computed Properties and Watchers12345678910111213141516171819&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 5、component lists rendered with v-for should have explicit keys12345678910v-for需要绑定:key&lt;el-select v-model=\"value\" placeholder=\"请选择\" class=\"meeting-duration-select\"&gt; &lt;el-option v-for=\"(item,index) in options\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\"&gt; &lt;/el-option&gt;&lt;/el-select&gt;","tags":[]},{"title":"项目中的常见问题题_vue_store","date":"2017-04-26T02:47:16.000Z","path":"2017/04/26/项目中的常见问题题-vue-store/","text":"我会把我做关于模仿微博的这个项目遇到的一些问题公开在这里，遇到不对的地方请指教，发送邮件wang1348168417@gmail.com，或者扫我的微信二维码。一个简单的状态管理 单一数据源:1234567const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 每当 sourceOfTruth 发生变化, vmA 和 vmB 都会自动更新它们的视图. 子组件可以通过 this.$root.$data 访问数据. 现在我们有了单一的数据源, 但是调试会很困难. 因为无论何时数据源发生变化都会改变程序, 但是没有任何迹象表明变化发生. store pattern为了解决上述问题, 我们可以引入 store pattern:1234567891011121314var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; this.debug &amp;&amp; console.log('setMessageAction triggered with', newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; this.debug &amp;&amp; console.log('clearMessageAction triggered') this.state.message = 'action B triggered' &#125;&#125; 所有的数据改变都发生 store 内. 这种集中的状态管理模式使我们很容易记录变化发生, 如何发生.除了单一的数据源外, 每个 vue 实例或组件也可以有其私有状态:123456789101112var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 使用Vuex12345678910111213141516171819// 如果 Vuex 不是全局的, 那么确保调用 Vue.use(Vuex) 使 Vuex 生效.const store = new Vuex.Store(&#123; // 数据源 state: &#123; count: 0 &#125;, // 数据操作 mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)// 触发数据变化操作store.commit('increment')console.log(store.state.count) // -&gt; 1 Statestore 自动注入到子组件中 通常我们通过计算属性来访问 store 中的数据, 这样就能感知到数据发生变化.根组件的 store 属性会注入到其所有的子组件中. (通过 Vue.use(Vuex) 生效)1234567891011121314151617const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count() &#123; // 子组件通过 this.$store 访问父组件的 store return this.$store.state.count &#125; &#125;&#125;new Vue(&#123; // 父对象中的 store 自动注入到子组件 store, componets: &#123; Counter &#125;&#125;) mapState如果 store 中有许多数据需要访问, 每个数据都需要定义一个计算属性会非常麻烦. Vuex 提供了 mapState 来简化计算属性的定义.123456789101112131415161718import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // es6 箭头函数更加简洁 count: state =&gt; state.count, // 字符串 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了访问组件的 `this`, 必须使用普通的函数 // 箭头函数会绑定 `this` 到 `mapState` 的参数这个对象 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 如果计算属性和 store 中数据是一一对应的, 可以使用更简单的字符串数组:1234computed: mapState([ // map this.count to store.state.count 'count']) es6 的扩展操作符使用 mapState 返回一个对象, 如果组件还有私有的计算属性, 通常我们可以使用 _.extend({localComputed}, mapState(…)) 这种方式合并对象已得到最终的 computed. 使用 es6 的扩展操作符可以简化:1234567computed: &#123; localComputed()&#123; /* ... */&#125;, // 通过扩展操作符扩展 computed 对象 ...mapState(&#123; // ... &#125;)&#125; Getters通常计算属性是基于一段 store 数据的代码, 比如过滤一个列表并计数:12345computed: &#123; doneTodoCount() &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果我们需要复用这段代码, 基本就是重构提取出一个函数, 但是这样还不是很理想.123456789101112131415161718192021Vuex 在 store 中提供了 getters:const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125;, doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; &#125;&#125;)// 通过 `store.getters` 访问store.getters.doneTodosCount 上面的计算属性就可以改成:12345computed: &#123; doneTodoCount() &#123; return this.$store.getters.doneTodoCount &#125;&#125; mapGetters同 state 的 mapState 类似, getters 也有 mapGetters 来简化计算属性的定义12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // mix the getters into computed with object spread operator ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 使用对象可以自定义对应关系1234mapGetters(&#123; // map this.doneCount to store.getters.doneTodosCount doneCount: 'doneTodosCount'&#125;) MutationsVuex 中的 state 只能通过 mutations 来改变. mutations 很像事件, 都有一个类型和处理函数. 处理函数是真正改变 state 的地方, 并以 state 作为第一个参数.1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 改变 state state.count++ &#125; &#125;&#125;) 就是事件一样, 我们不能直接调用处理函数, 而是要通过 store.commit(type) 来触发 mutation 处理函数. store.commit(‘increment’)带 playload commit 我们可以将处理函数的参数放到第二个参数 playload 中:12345678910111213mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123;amount: 10&#125;)对象风格 commitstore.commit(&#123; type: 'increment', playload: &#123; amount: 10 &#125;&#125;) 静默模式默认情况下, 每一次 commit 都会发送到插件 (比如: devtools) 中. 可能你会希望某些 commit 不被记录. 这时候可以传递第三个参数以设置为静默模式:123456789store.commit('increment', &#123; amount: 1&#125;, &#123; silent: true &#125;)// 对象风格 commitstore.commit(&#123; type: 'increment', amount: 1&#125;, &#123; silent: true &#125;) Mutations 要遵守 Vue 的响应式规则 即: 提前初始化所有的状态值添加新的属性到对象时, 你应该:使用 Vue.set(obj, ‘newProp’, 123) 或直接替换新的对象: state.obj = {…state.obj, newProp: 123}使用常量为 Mutations 命名 使用常量为 Mutations 命名是各种 Flux 实现常用的模式. 将所有常量放到一个文件中, 我们能看到整个程序有什么情况数据会发生变化.1234567891011121314151617// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // es6 特性 computed property name // 属性名称运行时确定 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) Mutations 必须是同步的异步 mutations 调用违反了所有的状态变化必须在 store 中进行的规定. 比如:1234567mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125; 当上例中状态变化时, someMutation 已经结束了. 这时候如果有其他状态变化的操作发生, devtools 记录下来的状态变化就是错误的. mapMutations我们可以通过 this.$store.commit(‘xxx’) 在组件中调用 mutations, 一般我们将这些调用分装到 methods 中, 同时 Vuex 也提供了 mapMutations 函数简化 methods 定义:12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // 映射 this.increment() 到 this.$store.commit('increment') ]), ...mapMutations(&#123; add: 'increment' // map this.add() to this.$store.commit('increment') &#125;) &#125;&#125; Actions异步的 mutations 使程序的状态变化难以追踪. 为了解决异步操作, Vuex 引入了 actions.actions 跟 mutations 非常像, 它们的不同之处在于:1234567891011121314151617actions 不改变 state, 而是 commit mutationsactions 可以包含任意的异步操作const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) actions 接收一个 context 对象作为参数, context 可以访问 commit, getters, state, 但是它不是 store 对象.通常, 我们会使用 es6 的参数结构语法来简化代码:12345actions: &#123; increment(&#123;commit&#125;) &#123; commit('increment') &#125;&#125; Dispatching Actionsactions 通过 store.dispatch 来触发: store.dispatch(‘increment’)dispatch 也支持 commit 中的 playload 参数以及对象风格的调用方式.12345678910// dispatch with a payloadstore.dispatch('incrementAsync', &#123; amount: 10&#125;)// dispatch with an objectstore.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) mapActions类似 mapMutations Actions 组合 actions 通常是异步的, 我们怎么来组合多个 actions 来执行复杂的操作? 首先我们需要知道的是 store.dispatch 返回 actions 中处理函数的返回值, 因此我们可以返回一个 Promise:123456789101112131415161718192021222324252627282930actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;, actionB (&#123; dispatch, commit &#125;) &#123; // 组合 return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125;使用 async/await 语法, 可以简化为:// 假设 getData() 和 getOtherData() 返回 Promisesactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // wait for actionA to finish commit('gotOtherData', await getOtherData()) &#125;&#125; Modules当我们的程序足够大时, store 也会变得非常大, 其中的 state, getters, mutations, actions 也会非常大. 因此 Vuex 允许我们将 store 分成几个 modules, 每个 modules 都有自己的 state, getters, mutations, actions 甚至它自己的 modules.12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA's statestore.state.b // -&gt; moduleB's state Modules 当前状态在 modules 中, getters 和 mutations 的第一个参数都是 modules 的 state, 同样 actions 的 context.state 也是 modules 的 state, 根节点的状态可以通过 context.rootState 访问到. getters 的可以通过第三个参数访问 $rootState:12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; ### 命名空间 modules 的 state 放到根节点的对应的属性中, 而 actions, mutations 和 getters 没有命名空间. 所以多个 modules 可以对同一个 commit 或 dispatch 做响应. 因此必须自己通过前缀或后缀来避免命名冲突. 动态 Modules 注册1234store.registerModule('myModule', &#123; // ...&#125;)keep learning","tags":[]},{"title":"Es6新特性","date":"2017-04-18T07:36:32.000Z","path":"2017/04/18/Es6新特性/","text":"####ECMAScript 6简介 ###1.Class基本语法 ##概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。12345678class Bar &#123; doStuff() &#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // \"stuff\" 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。1234567891011121314151617181920class Point &#123; constructor()&#123; // ... &#125; toString()&#123; // ... &#125; toValue()&#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678910111213class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;);prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 class Point { constructor(x, y) { // … } toString() { // … }} Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [“constructor”,”toString”] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。 var Point = function (x, y) { // …}; Point.prototype.toString = function() { // …}; Object.keys(Point.prototype)// [“toString”]Object.getOwnPropertyNames(Point.prototype)// [“constructor”,”toString”] 上面代码采用ES5的写法，toString方法就是可枚举的。 类的属性名，可以采用表达式。 let methodName = “getArea”;class Square{ constructor(length) { // … } methodName { // … }} 上面代码中，Square类的方法名getArea，是从表达式得到的。 constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor() {}constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 class Foo { constructor() { return Object.create(null); }} new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 class Foo { constructor() { return Object.create(null); }} Foo()// TypeError: Class constructor Foo cannot be invoked without ‘new’ 类的实例对象生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 // 报错var point = Point(2, 3); // 正确var point = new Point(2, 3); 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 //定义类class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’; } } var point = new Point(2, 3); point.toString() // (2, 3) point.hasOwnProperty(‘x’) // truepoint.hasOwnProperty(‘y’) // truepoint.hasOwnProperty(‘toString’) // falsepoint.proto.hasOwnProperty(‘toString’) // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。 与ES5一样，类的所有实例共享一个原型对象。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto === p2.proto//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以proto属性是相等的。 这也意味着，可以通过实例的proto属性为Class添加方法。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto.printName = function () { return ‘Oops’ }; p1.printName() // “Oops”p2.printName() // “Oops” var p3 = new Point(4,2);p3.printName() // “Oops” 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。 new Foo(); // ReferenceErrorclass Foo {}上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 { let Foo = class {}; class Bar extends Foo { }}上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 Class表达式与函数一样，类也可以使用表达式的形式定义。 const MyClass = class Me { getClassName() { return Me.name; }};上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined上面代码表示，Me只在Class内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { / … / };采用Class表达式，可以写出立即执行的Class。 let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); }}(‘张三’); person.sayName(); // “张三”上面代码中，person是一个立即执行的类的实例。 私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 class Widget { // 公有方法 foo (baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // …}上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 class Widget { foo (baz) { bar.call(this, baz); } // …} function bar(baz) { return this.snaf = baz;}上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 const bar = Symbol(‘bar’);const snaf = Symbol(‘snaf’); export default class myClass{ // 公有方法 foo(baz) { thisbar; } // 私有方法 bar { return this[snaf] = baz; } // …};上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = ‘there’) { this.print(Hello ${name}); } print(text) { console.log(text); }} const logger = new Logger();const { printName } = logger;printName(); // TypeError: Cannot read property ‘print’ of undefined上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // …}另一种解决方法是使用箭头函数。 class Logger { constructor() { this.printName = (name = ‘there’) =&gt; { this.print(Hello ${name}); }; } // …}还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 function selfish (target) { const cache = new WeakMap(); const handler = { get (target, key) { const value = Reflect.get(target, key); if (typeof value !== ‘function’) { return value; } if (!cache.has(value)) { cache.set(value, value.bind(target)); } return cache.get(value); } }; const proxy = new Proxy(target, handler); return proxy;} const logger = selfish(new Logger());严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。 name属性由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 class Point {}Point.name // “Point”name属性总是返回紧跟在class关键字后面的类名。 Class的继承基本用法Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 class ColorPoint extends Point {}上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ‘ ‘ + super.toString(); // 调用父类的toString() }}上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 class Point { / … / } class ColorPoint extends Point { constructor() { }} let cp = new ColorPoint(); // ReferenceError上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 constructor(…args) { super(…args);}另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 class Point { constructor(x, y) { this.x = x; this.y = y; }} class ColorPoint extends Point { constructor(x, y, color) { this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 }}上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 let cp = new ColorPoint(25, 8, ‘green’); cp instanceof ColorPoint // truecp instanceof Point // true上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。 类的prototype属性和proto属性大多数浏览器的ES5实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 class A {} class B extends A {} B.proto === A // trueB.prototype.proto === A.prototype // true上面代码中，子类B的proto属性指向父类A，子类B的prototype属性的proto属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 class A {} class B {} // B的实例继承A的实例Object.setPrototypeOf(B.prototype, A.prototype);const b = new B(); // B的实例继承A的静态属性Object.setPrototypeOf(B, A);const b = new B();《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 Object.setPrototypeOf = function (obj, proto) { obj.proto = proto; return obj;}因此，就得到了上面的结果。 Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.proto = A.prototype; Object.setPrototypeOf(B, A);// 等同于B.proto = A;这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（proto属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 Object.create(A.prototype);// 等同于B.prototype.proto = A.prototype;Extends 的继承目标extends关键字后面可以跟多种类型的值。 class B extends A {}上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论三种特殊情况。 第一种特殊情况，子类继承Object类。 class A extends Object {} A.proto === Object // trueA.prototype.proto === Object.prototype // true这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种特殊情况，不存在任何继承。 class A {} A.proto === Function.prototype // trueA.prototype.proto === Object.prototype // true这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.proto指向构造函数（Object）的prototype属性。 第三种特殊情况，子类继承null。 class A extends null {} A.proto === Function.prototype // trueA.prototype.proto === undefined // true这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的proto指向Function.prototype，即实质上执行了下面的代码。 class C extends null { constructor() { return Object.create(null); }}Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 Object.getPrototypeOf(ColorPoint) === Point// true因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 class A {} class B extends A { constructor() { super(); }}上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 class A { constructor() { console.log(new.target.name); }}class B extends A { constructor() { super(); }}new A() // Anew B() // B上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 class A {} class B extends A { m() { super(); // 报错 }}上面代码中，super()用在B类的m方法之中，就会造成句法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 class A { p() { return 2; }} class B extends A { constructor() { super(); console.log(super.p()); // 2 }} let b = new B();上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 class A { constructor() { this.p = 2; }} class B extends A { get m() { return super.p; }} let b = new B();b.m // undefined上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到。 class A {}A.prototype.x = 2; class B extends A { constructor() { super(); console.log(super.x) // 2 }} let b = new B();上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。 ES6 规定，通过super调用父类的方法时，super会绑定子类的this。 class A { constructor() { this.x = 1; } print() { console.log(this.x); }} class B extends A { constructor() { super(); this.x = 2; } m() { super.print(); }} let b = new B();b.m() // 2上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 class A { constructor() { this.x = 1; }} class B extends A { constructor() { super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 }} let b = new B();上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 class Parent { static myMethod(msg) { console.log(‘static’, msg); } myMethod(msg) { console.log(‘instance’, msg); }} class Child extends Parent { static myMethod(msg) { super.myMethod(msg); } myMethod(msg) { super.myMethod(msg); }} Child.myMethod(1); // static 1 var child = new Child();child.myMethod(2); // instance 2上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 class A {} class B extends A { constructor() { super(); console.log(super); // 报错 }}上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 class A {} class B extends A { constructor() { super(); console.log(super.valueOf() instanceof B); // true }} let b = new B();上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 var obj = { toString() { return “MyObject: “ + super.toString(); }}; obj.toString(); // MyObject: [object Object]实例的proto属性子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。 var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, ‘red’); p2.proto === p1.proto // falsep2.proto.proto === p1.proto // true上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的proto.proto属性，可以修改父类实例的行为。 p2.proto.proto.printName = function () { console.log(‘Ha’);}; p1.printName() // “Ha”上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。 Boolean()Number()String()Array()Date()Function()RegExp()Error()Object()以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 function MyArray() { Array.apply(this, arguments);} MyArray.prototype = Object.create(Array.prototype, { constructor: { value: MyArray, writable: true, configurable: true, enumerable: true }});上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。 var colors = new MyArray();colors[0] = “red”;colors.length // 0 colors.length = 0;colors[0] // “red”之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 下面的例子中，我们想让一个普通对象继承Error对象。 var e = {}; Object.getOwnPropertyNames(Error.call(e))// [ ‘stack’ ] Object.getOwnPropertyNames(e)// []上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 class MyArray extends Array { constructor(…args) { super(…args); }} var arr = new MyArray();arr[0] = 12;arr.length // 1 arr.length = 0;arr[0] // undefined上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 class VersionedArray extends Array { constructor() { super(); this.history = [[]]; } commit() { this.history.push(this.slice()); } revert() { this.splice(0, this.length, …this.history[this.history.length - 1]); }} var x = new VersionedArray(); x.push(1);x.push(2);x // [1, 2]x.history // [[]] x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3] x.revert();x // [1, 2]上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。 下面是一个自定义Error子类的例子。 class ExtendableError extends Error { constructor(message) { super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; }} class MyError extends ExtendableError { constructor(m) { super(m); }} var myerror = new MyError(‘ll’);myerror.message // “ll”myerror instanceof Error // truemyerror.name // “MyError”myerror.stack// Error// at MyError.ExtendableError// …注意，继承Object的子类，有一个行为差异。 class NewObj extends Object{ constructor(){ super(…arguments); }}var o = new NewObj({attr: true});console.log(o.attr === true); // false上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。 Class的取值函数（getter）和存值函数（setter）与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 class MyClass { constructor() { // … } get prop() { return ‘getter’; } set prop(value) { console.log(‘setter: ‘+value); }} let inst = new MyClass(); inst.prop = 123;// setter: 123 inst.prop// ‘getter’上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的descriptor对象上的。 class CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; }} var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, “html”);“get” in descriptor // true“set” in descriptor // true上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。 Class 的 Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 class Foo { constructor(…args) { this.args = args; } Symbol.iterator {for (let arg of this.args) { yield arg;}}} for (let x of new Foo(‘hello’, ‘world’)) { console.log(x);}// hello// world上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo { static classMethod() { return ‘hello’; }} Foo.classMethod() // ‘hello’ var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo {} Bar.classMethod(); // ‘hello’上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo { static classMethod() { return super.classMethod() + ‘, too’; }} Bar.classMethod();Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。 class Foo {} Foo.prop = 1;Foo.prop // 1上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。 // 以下两种写法都无效class Foo { // 写法一 prop: 2 // 写法二 static prop: 2} Foo.prop // undefinedES7有一个静态属性的提案，目前Babel转码器支持。 这个提案对实例属性和静态属性，都规定了新的写法。 （1）类的实例属性 类的实例属性可以用等式，写入类的定义之中。 class MyClass { myProp = 42; constructor() { console.log(this.myProp); // 42 }}上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; }}上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。 class ReactCounter extends React.Component { state = { count: 0 };}这种写法比以前更清晰。 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } state;}（2）类的静态属性 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 class MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myStaticProp); // 42 }}同样的，这个新写法大大方便了静态属性的表达。 // 老写法class Foo {}Foo.prop = 1; // 新写法class Foo { static prop = 1;}上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。 类的私有属性目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。 class Point { #x; constructor(x = 0) { #x = +x; } get x() { return #x } set x(value) { #x = +value }}上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。 私有属性可以指定初始值，在构造函数执行时进行初始化。 class Point { #x = 0; constructor() { #x; // 0 }}之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。 class Foo { #a; #b; #sum() { return #a + #b; } printSum() { console.log(#sum()); } constructor(a, b) { #a = a; #b = b; }}new.target属性new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(‘必须使用new生成实例’); }} // 另一种写法function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error(‘必须使用new生成实例’); }} var person = new Person(‘张三’); // 正确var notAPerson = Person.call(person, ‘张三’); // 报错上面代码确保构造函数只能通过new命令调用。 Class内部调用new.target，返回当前Class。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; }} var obj = new Rectangle(3, 4); // 输出 true需要注意的是，子类继承父类时，new.target会返回子类。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); // … }} class Square extends Rectangle { constructor(length) { super(length, length); }} var obj = new Square(3); // 输出 false上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error(‘本类不能实例化’); } }} class Rectangle extends Shape { constructor(length, width) { super(); // … }} var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。 Mixin模式的实现Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。 function mix(…mixins) { class Mix {} for (let mixin of mixins) { copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); } return Mix;} function copyProperties(target, source) { for (let key of Reflect.ownKeys(source)) { if ( key !== “constructor” &amp;&amp; key !== “prototype” &amp;&amp; key !== “name” ) { let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); } }}上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 class DistributedEdit extends mix(Loggable, Serializable) { // …}","tags":[]},{"title":"yilia配置","date":"2017-04-11T02:41:53.000Z","path":"2017/04/11/yilia配置/","text":"主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份 Headermenu: 主页: / 随笔: /tags/随笔/ SubNavsubnav: github: “#” weibo: “#” rss: “#” zhihu: “#” #qq: “#” #weixin: “#” #jianshu: “#” #douban: “#” #segmentfault: “#” #bilibili: “#” #acfun: “#” #mail: “mailto:litten225@qq.com” #facebook: “#” #google: “#” #twitter: “#” #linkedin: “#” rss: /atom.xml 是否需要修改 root 路径如果您的网站存放在子目录中，例如 http://yoursite.com/blog，请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: Content文章太长，截断按钮文字excerpt_link: more 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: ‘展开全文’ 数学公式mathjax: false 是否在新窗口打开链接open_in_new: false 打赏请在需要打赏的文章的md文件头部，设置属性reward: true打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2 打赏wordingreward_wording: ‘谢谢你请我吃糖果’ 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: 微信二维码图片地址weixin: Miscellaneousbaidu_analytics: ‘’google_analytics: ‘’favicon: /favicon.png #你的头像urlavatar: #是否开启分享share_jia: true #是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key #若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: 头像上面的背景颜色 header: ‘#4d4d4d’ 右滑板块背景 slider: ‘linear-gradient(200deg,#a0cfe4,#e8c37e)’ slider的设置slider: 是否默认展开tags板块 showTags: false 智能菜单如不需要，将该对应项置为false比如#smart_menu: friends: falsesmart_menu: innerArchive: ‘所有文章’ friends: ‘友链’ aboutme: ‘关于我’ friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/ aboutme: 很惭愧只做了一点微小的工作谢谢大家","tags":[]},{"title":"我的第一个博客","date":"2017-04-08T03:11:41.000Z","path":"2017/04/08/我的第一个博客/","text":"您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！","tags":[]}]