<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jade_Wang</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-19T01:53:03.888Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jade_Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库常用命令小结</title>
    <link href="http://yoursite.com/2017/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%E3%80%81/"/>
    <id>http://yoursite.com/2017/05/19/数据库常用命令小结、/</id>
    <published>2017-05-19T01:26:15.000Z</published>
    <updated>2017-05-19T01:53:03.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-数据库常用命令"><a href="#MySQL-数据库常用命令" class="headerlink" title="MySQL 数据库常用命令"></a>MySQL 数据库常用命令</h2><h3 id="1、MySQL常用命令"><a href="#1、MySQL常用命令" class="headerlink" title="1、MySQL常用命令"></a>1、MySQL常用命令</h3><ul>
<li>create database name; 创建数据库</li>
<li>use databasename; 选择数据库</li>
<li>drop database name 直接删除数据库，不提醒</li>
<li>show tables; 显示表</li>
<li>describe tablename; 表的详细描述</li>
<li>select 中加上distinct去除重复字段</li>
<li>mysqladmin drop databasename 删除数据库前，有提示。</li>
<li>显示当前mysql版本和当前日期</li>
<li>select version(),current_date;<a id="more"></a>
<h3 id="2、修改mysql中root的密码："><a href="#2、修改mysql中root的密码：" class="headerlink" title="2、修改mysql中root的密码："></a>2、修改mysql中root的密码：</h3>shell&gt;mysql -u root -p<br>mysql&gt; update user set password=password(”xueok654123″) where user=’root’;<br>mysql&gt; flush privileges //刷新数据库<br>mysql&gt;use dbname； 打开数据库：<br>mysql&gt;show databases; 显示所有数据库<br>mysql&gt;show tables; 显示数据库mysql中所有的表：先use mysql；然后<br>mysql&gt;describe user; 显示表mysql数据库中user表的列信息）；</li>
</ul>
<h3 id="3、grant"><a href="#3、grant" class="headerlink" title="3、grant"></a>3、grant</h3><p>创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个<br>mysql&gt; grant all privileges on <em>.</em> to user@localhost identified by ’something’ with<br>增加新用户<br>格式：grant select on 数据库.<em> to 用户名@登录主机 identified by “密码”<br>GRANT ALL PRIVILEGES ON </em>.<em> TO monty@localhost IDENTIFIED BY ’something’ WITH GRANT OPTION;<br>GRANT ALL PRIVILEGES ON </em>.<em> TO monty@”%” IDENTIFIED BY ’something’ WITH GRANT OPTION;<br>删除授权：<br>mysql&gt; revoke all privileges on </em>.<em> from root@”%”;<br>mysql&gt; delete from user where user=”root” and host=”%”;<br>mysql&gt; flush privileges;<br>创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandb<br>mysql &gt;grant select, insert, update, delete, create,drop on fangchandb.</em> to custom@ it363.com identified by ‘ passwd’<br>重命名表:<br>mysql &gt; alter table t1 rename t2;</p>
<h3 id="4、mysqldump"><a href="#4、mysqldump" class="headerlink" title="4、mysqldump"></a>4、mysqldump</h3><p>备份数据库<br>shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql<br>恢复数据库<br>shell&gt; mysqladmin -h myhost -u root -p create dbname<br>shell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql<br>如果只想卸出建表指令，则命令如下：<br>shell&gt; mysqladmin -u root -p -d databasename &gt; a.sql<br>如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下：<br>shell&gt; mysqladmin -u root -p -t databasename &gt; a.sql<br>那么如果我只想要数据，而不想要什么sql命令时，应该如何操作呢？<br>　　 mysqldump -T./ phptest driver<br>其中，只有指定了-T参数才可以卸出纯文本文件，表示卸出数据的目录，./表示当前目录，即与mysqldump同一目录。如果不指定driver 表，则将卸出整个数据库的数据。每个表会生成两个文件，一个为.sql文件，包含建表执行。另一个为.txt文件，只包含数据，且没有sql指令。</p>
<h3 id="5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。"><a href="#5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。" class="headerlink" title="5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。"></a>5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。</h3><p>例如，如果在文件my_file.sql 中存放有查<br>询，可如下执行这些查询：<br>例如，如果您想将建表语句提前写在sql.txt中:<br>mysql &gt; mysql -h myhost -u root -p database &lt; sql.txt</p>
<h3 id="常用mysql命令行命令"><a href="#常用mysql命令行命令" class="headerlink" title="常用mysql命令行命令"></a>常用mysql命令行命令</h3><h4 id="1、mysql的启动与停止"><a href="#1、mysql的启动与停止" class="headerlink" title="1、mysql的启动与停止"></a>1、mysql的启动与停止</h4><p>　　启动MYSQL服务 net start mysql<br>　　停止MYSQL服务 net stop mysql</p>
<h4 id="2、-netstat-–na-findstr-3306-查看被监听的端口-findstr用于查找后面的端口是否存在"><a href="#2、-netstat-–na-findstr-3306-查看被监听的端口-findstr用于查找后面的端口是否存在" class="headerlink" title="2、 netstat –na | findstr 3306 查看被监听的端口 , findstr用于查找后面的端口是否存在"></a>2、 netstat –na | findstr 3306 查看被监听的端口 , findstr用于查找后面的端口是否存在</h4><h4 id="3、-在命令行中登陆MYSQL控制台-即使用-MYSQL-COMMEND-LINE-TOOL"><a href="#3、-在命令行中登陆MYSQL控制台-即使用-MYSQL-COMMEND-LINE-TOOL" class="headerlink" title="3、 在命令行中登陆MYSQL控制台 , 即使用 MYSQL COMMEND LINE TOOL"></a>3、 在命令行中登陆MYSQL控制台 , 即使用 MYSQL COMMEND LINE TOOL</h4><p>　　 语法格式 mysql –user=root –password=123456 db_name<br>　　 或 mysql –u root –p123456 db_name</p>
<h4 id="4、-进入MYSQL命令行工具后-使用status-或-s-查看运行环境信息"><a href="#4、-进入MYSQL命令行工具后-使用status-或-s-查看运行环境信息" class="headerlink" title="4、 进入MYSQL命令行工具后 , 使用status; 或/s 查看运行环境信息"></a>4、 进入MYSQL命令行工具后 , 使用status; 或/s 查看运行环境信息</h4><h4 id="5、-切换连接数据库的语法-use-new-dbname"><a href="#5、-切换连接数据库的语法-use-new-dbname" class="headerlink" title="5、 切换连接数据库的语法 : use new_dbname;"></a>5、 切换连接数据库的语法 : use new_dbname;</h4><p>　　 　 </p>
<h4 id="6、-显示所有数据库-show-databases"><a href="#6、-显示所有数据库-show-databases" class="headerlink" title="6、 显示所有数据库 : show databases;"></a>6、 显示所有数据库 : show databases;</h4><p>　　 </p>
<h4 id="7、-显示数据库中的所有表-show-tables"><a href="#7、-显示数据库中的所有表-show-tables" class="headerlink" title="7、 显示数据库中的所有表 : show tables;"></a>7、 显示数据库中的所有表 : show tables;</h4><p>　　 </p>
<h4 id="8、-显示某个表创建时的全部信息-show-create-table-table-name"><a href="#8、-显示某个表创建时的全部信息-show-create-table-table-name" class="headerlink" title="8、 显示某个表创建时的全部信息 : show create table table_name;"></a>8、 显示某个表创建时的全部信息 : show create table table_name;</h4><p>　　 </p>
<h4 id="9、-查看表的具体属性信息及表中各字段的描述"><a href="#9、-查看表的具体属性信息及表中各字段的描述" class="headerlink" title="9、 查看表的具体属性信息及表中各字段的描述"></a>9、 查看表的具体属性信息及表中各字段的描述</h4><p>　　 Describe table_name; 缩写形式 : desc table_name;</p>
<h2 id="MySql中的SQL语句"><a href="#MySql中的SQL语句" class="headerlink" title="MySql中的SQL语句"></a>MySql中的SQL语句</h2><h3 id="1-数据库创建-Create-database-db-name"><a href="#1-数据库创建-Create-database-db-name" class="headerlink" title="1 . 数据库创建 : Create database db_name;"></a>1 . 数据库创建 : Create database db_name;</h3><p>　　数据库删除 : Drop database db_name; 删除时可先判断是否存在，写成 : drop database if exits db_name 
　　 </p>
<h3 id="2-建表-创建数据表的语法-create-table-table-name-字段1-数据类型-字段2-数据类型"><a href="#2-建表-创建数据表的语法-create-table-table-name-字段1-数据类型-字段2-数据类型" class="headerlink" title="2 . 建表 : 创建数据表的语法 : create table table_name (字段1 数据类型 , 字段2 数据类型);"></a>2 . 建表 : 创建数据表的语法 : create table table_name (字段1 数据类型 , 字段2 数据类型);</h3><p>　　 例 : create table mytable (id int , username char(20));<br>　　 删表 : drop table table_name; 例 : drop table mytable; 
　　 </p>
<h3 id="3-添加数据-Insert-into-表名-字段1-字段2-…-values-值1-值2-…"><a href="#3-添加数据-Insert-into-表名-字段1-字段2-…-values-值1-值2-…" class="headerlink" title="3 . 添加数据 : Insert into 表名 [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..);"></a>3 . 添加数据 : Insert into 表名 [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..);</h3><p>　　如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可不写<br>　　 例 : insert into mytable (id,username) values (1,’zhangsan’); 
　　 </p>
<h3 id="4-查询-查询所有数据-select-from-table-name"><a href="#4-查询-查询所有数据-select-from-table-name" class="headerlink" title="4. 查询 : 查询所有数据 : select * from table_name;"></a>4. 查询 : 查询所有数据 : select * from table_name;</h3><p>　　查询指定字段的数据 : select 字段1 , 字段2 from table_name;<br>　　例 : select id,username from mytable where id=1 order by desc;多表查询语句————参照第17条实例<br>　　 ### 　5 . 更新指定数据 , 更新某一个字段的数据（注意，不是更新字段的名字）<br>　　Update table_name set 字段名=’新值’ [, 字段2 =’新值’ , …..][where id=id_num] [order by 字段 顺序]<br>　　例 : update mytable set username=’lisi’ where id=1;<br>　　Order语句是查询的顺序 , 如 : order by id desc(或asc) , 顺序有两种 : desc倒序(100—1,即从最新数据往后查询),asc(从1-100)，Where和order语句也可用于查询select 与删除delete 
　　 </p>
<h3 id="6-删除表中的信息"><a href="#6-删除表中的信息" class="headerlink" title="6 . 删除表中的信息 :"></a>6 . 删除表中的信息 :</h3><p>　　 删除整个表中的信息 : delete from table_name;<br>　　 删除表中指定条件的语句 : delete from table_name where 条件语句 ; 条件语句如 : id=3; 
　　 </p>
<h3 id="7-创建数据库用户"><a href="#7-创建数据库用户" class="headerlink" title="7 . 创建数据库用户"></a>7 . 创建数据库用户</h3><p>　　一次可以创建多个数据库用户如：<br>　　CREATE USER username1 identified BY ‘password’ , username2 IDENTIFIED BY ‘password’…. 
　　 </p>
<h3 id="8-用户的权限控制：grant"><a href="#8-用户的权限控制：grant" class="headerlink" title="8 . 用户的权限控制：grant"></a>8 . 用户的权限控制：grant</h3><p>　　 库，表级的权限控制 : 将某个库中的某个表的控制权赋予某个用户<br>　　 Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; 
　　 </p>
<h3 id="9-表结构的修改"><a href="#9-表结构的修改" class="headerlink" title="9 . 表结构的修改"></a>9 . 表结构的修改</h3><p>　　（1）增加一个字段格式：<br>　　alter table table_name add column (字段名 字段类型); —-此方法带括号<br>　　（2）指定字段插入的位置：<br>　　alter table table_name add column 字段名 字段类型 after 某字段；<br>　　删除一个字段：<br>　　alter table table_name drop字段名;<br>　　（3）修改字段名称/类型<br>　　alter table table_name change 旧字段名 新字段名 新字段的类型;<br>　　（4）改表的名字<br>　　alter table table_name rename to new_table_name;<br>　　（5）一次性清空表中的所有数据<br>　　truncate table table_name; 此方法也会使表中的取号器(ID)从1开始 
　　 </p>
<h3 id="10-增加主键，外键，约束，索引。。。。-使用方法见17实例"><a href="#10-增加主键，外键，约束，索引。。。。-使用方法见17实例" class="headerlink" title="10 . 增加主键，外键，约束，索引。。。。(使用方法见17实例)"></a>10 . 增加主键，外键，约束，索引。。。。(使用方法见17实例)</h3><p>　　① 约束（主键Primary key、唯一性Unique、非空Not Null）<br>　　② 自动增张 auto_increment<br>　　③外键Foreign key—–与reference table_name(col_name列名)配合使用，建表时单独使用<br>　　④ 删除多个表中有关联的数据—-设置foreign key 为set null —具体设置参考帮助文档 
　　 </p>
<h3 id="11-查看数据库当前引擎"><a href="#11-查看数据库当前引擎" class="headerlink" title="11 . 查看数据库当前引擎"></a>11 . 查看数据库当前引擎</h3><p>　　 SHOW CREATE TABLE table_name;<br>　　 修改数据库引擎<br>　　 ALTER TABLE table_name ENGINE=MyISAM | InnoDB; 
　　 </p>
<h3 id="12-SQL语句运用实例"><a href="#12-SQL语句运用实例" class="headerlink" title="12 . SQL语句运用实例:"></a>12 . SQL语句运用实例:</h3><p>　　<strong> –1 建users表<br>　　create table users (id int primary key auto_increment,nikename varchar(20) not null unique,password varchar(100) not null,address varchar(200), reg_date timestamp not null default CURRENT_TIMESTAMP);<br>　　<br>　　–2 建articles表,在建表时设置外键<br>　　create table articles (id int primary key auto_increment,content longtext not null,userid int,constraint foreign key (userid) references users(id) on delete set null);<br>　　<br>　　———————————————————————–<br>　　–2.1 建articles表,建表时不设置外键<br>　　 create table articles (id int primary key auto_increment,content longtext not null,userid int);<br>　　–2.2 给articles表设置外键<br>　　 alter table articles add constraint foreign key (userid) references users(id) on delete set null;<br>　　————————————————————————<br>　　<br>　　–3. 向users表中插入数据,同时插入多条<br>　　insert into users (id,nikename,password,address) values (1,’lyh1’,’1234’,null),(10,’lyh22’,’4321’,’湖北武汉’),(null,’lyh333’,’5678’, ‘北京海淀’);<br>　　<br>　　–4. 向article中插入三条数据<br>　　insert into articles (id,content,userid) values (2,’hahahahahaha’,11),(null,’xixixixixix’,10),(13,’aiaiaiaiaiaiaiaiaiaiaiaia’,1),(14,’hohoahaoaoooooooooo’,10);<br>　　<br>　　–5. 进行多表查询，选择users表中ID=10的用户发布的所有留言及该用户的所有信息<br>　　select articles.id,articles.content,users.<em> from users,articles where users.id=10 and articles.userid=users.id order by articles.id desc;<br>　　<br>　　–6. 查看数据库引擎类型<br>　　show create table users;<br>　　<br>　　–7. 修改数据库引擎类型<br>　　alter table users engine=MyISAM; —因为users表中ID被设置成外键，执行此句会出错<br>　　<br>　　–8. 同表查询,已知一个条件的情况下.查询ID号大于用户lyh1的ID号的所有用户<br>　　select a.id,a.nikename,a.address from users a,users b where b.nikename=’lyh1’ and a.id&gt;b.id;<br>　　——也可写成<br>　　select id,nikename,address from users where id&gt;(select id from users where nikename=’lyh1’);<br>　　<br>　　–9. 显示年龄比领导还大的员工：<br>　　select a.name from users a,users b where a.managerid=b.id and a.age&gt;b.age;<br>　　<br>　　查询编号为2的发帖人: 先查articles表,得到发帖人的编号,再根据编号查users得到的用户名。<br>　　接着用关联查询.<br>　　select </em> from articles,users得到笛卡儿积,再加order by articles.id以便观察<br>　　<br>　　使用select <em> from articles,users where articles.id=2 筛选出2号帖子与每个用户的组合记录<br>　　<br>　　再使用select </em> from articles,users where articles.id=2 and articles.userid=users.id选出users.id等于2号帖的发帖人id的记录.<br>　　<br>　　只取用户名:select user where user.id=(select userid from articles where article.id =2)<br>　　<br>　　找出年龄比小王还大的人:假设小王是28岁,先想找出年龄大于28的人<br>　　select <em> from users where age&gt;(select age from users where name=’xiaowang’);<br>　　**</em></strong>要查询的记录需要参照表里面的其他记录:<br>　　select a.name from users a,users b where b.name=’xiaowang’ and a.age&gt;b.age<br>　　<br>　　表里的每个用户都想pk一下.select a.nickname,b.nickname from users a,users b where a.id&gt;b.id ;<br>　　<br>　　更保险的语句:select a.nickname,b.nickname from (select <em> from users order by id) a,(se<br>　　lect </em> from users order by id) b where a.id&gt;b.id ;<br>　　<br>　　再查询某个人发的所有帖子.<br>　　select b.* from articles a , articles b where a.id=2 and a.userid=b.userid<br>　　<br>　　说明: 表之间存在着关系，ER概念的解释，用access中的示例数据库演示表之间的关系.只有innodb引擎才支持foreign key，mysql的任何引擎目前都不支持check约束。 </p>
<h3 id="字符集出现错误解决办法"><a href="#字符集出现错误解决办法" class="headerlink" title="字符集出现错误解决办法"></a>字符集出现错误解决办法</h3><h4 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a>出现的问题：</h4><p>　　mysql&gt; update users<br>　　-&gt; set username=’关羽’<br>　　-&gt; where userid=2;<br>　　ERROR 1366 (HY000): Incorrect string value: ‘/xB9/xD8/xD3/xF0’ for column ‘usern<br>　　ame’ at row 1<br>　　向表中插入中文字符时，出现错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　mysql&gt; select * from users; </div><div class="line">　　+--------+----------+ </div><div class="line">　　| userid | username | </div><div class="line">　　+--------+----------+ </div><div class="line">　　| 2 | ???? | </div><div class="line">　　| 3 | ???? | </div><div class="line">　　| 4 | ?í?ù | </div><div class="line">　　+--------+----------+</div></pre></td></tr></table></figure></p>
<p>　　3 rows in set (0.00 sec)<br>　　表中的中文字符位乱码。<br>　　解决办法：<br>　　使用命令：<br>　　mysql&gt; status;<br>　　————–<br>　　mysql Ver 14.12 Distrib 5.0.45, for Win32 (ia32)<br>　　<br>　　Connection id: 8<br>　　Current database: test<br>　　Current user: root@localhost<br>　　SSL: Not in use<br>　　Using delimiter: ;<br>　　Server version: 5.0.45-community-nt MySQL Community Edition (GPL)<br>　　Protocol version: 10<br>　　Connection: localhost via TCP/IP<br>　　Server characterset: latin1<br>　　Db characterset: latin1<br>　　Client characterset: gbk<br>　　Conn. characterset: gbk<br>　　TCP port: 3306<br>　　Uptime: 7 hours 39 min 19 sec<br>　　Threads: 2 Questions: 174 Slow queries: 0 Opens: 57 Flush tables: 1 Open ta<br>　　bles: 1 Queries per second avg: 0.006<br>　　————–<br>　　查看mysql发现Server characterset，Db characterset的字符集设成了latin1，所以出现中文乱码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　mysql&gt; show tables; </div><div class="line">　　+----------------+ </div><div class="line">　　| Tables_in_test | </div><div class="line">　　+----------------+ </div><div class="line">　　| users | </div><div class="line">　　+----------------+ </div><div class="line">　　1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>　　更改表的字符集。<br>　　mysql&gt; alter table users character set GBK;<br>　　Query OK, 3 rows affected (0.08 sec)<br>　　Records: 3 Duplicates: 0 Warnings: 0<br>　　<br>　　查看表的结构：<br>　　mysql&gt; show create users;<br>　　ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that<br>　　corresponds to your MySQL server version for the right syntax to use near ‘users<br>　　‘ at line 1<br>　　mysql&gt; show create table users;<br>　　+——-+———————————————————————–<br>　　——————————————————————————+<br>　　| Table | Create Table<br>　　|<br>　　+——-+———————————————————————–<br>　　——————————————————————————+<br>　　| users | CREATE TABLE <code>users</code> (<br>　　<code>userid</code> int(11) default NULL,<br>　　<code>username</code> char(20) character set latin1 default NULL<br>　　) ENGINE=InnoDB DEFAULT CHARSET=gbk |<br>　　+——-+———————————————————————–<br>　　——————————————————————————+<br>　　1 row in set (0.00 sec)<br>　　<br>　　mysql&gt; desc users;<br>　　+———-+———-+——+—–+———+——-+<br>　　| Field | Type | Null | Key | Default | Extra |<br>　　+———-+———-+——+—–+———+——-+<br>　　| userid | int(11) | YES | | NULL | |<br>　　| username | char(20) | YES | | NULL | |<br>　　+———-+———-+——+—–+———+——-+<br>　　2 rows in set (0.02 sec)<br>　　<br>　　这时向表中插入中文然后有错误。<br>　　mysql&gt; insert into users values(88,’中文’);<br>　　ERROR 1366 (HY000): Incorrect string value: ‘/xD6/xD0/xCE/xC4’ for column ‘usern<br>　　ame’ at row 1<br>　　mysql&gt; insert into users values(88,’中文’);<br>　　ERROR 1366 (HY000): Incorrect string value: ‘/xD6/xD0/xCE/xC4’ for column ‘usern<br>　　ame’ at row 1<br>　　<br>　　还要更改users表的username的字符集。<br>　　mysql&gt; alter table users modify username char(20) character set gbk;<br>　　ERROR 1366 (HY000): Incorrect string value: ‘/xC0/xEE/xCB/xC4’ for column ‘usern<br>　　ame’ at row 1<br>　　mysql&gt; alter table users modify username char(20) character set gbk;<br>　　ERROR 1366 (HY000): Incorrect string value: ‘/xC0/xEE/xCB/xC4’ for column ‘usern<br>　　ame’ at row 1<br>　　<br>　　因为表中已经有数据，所以更改username字符集的操作没有成<strong><em><br>　　清空users表中的数据<br>　　mysql&gt; truncate table users;<br>　　Query OK, 3 rows affected (0.01 sec)<br>　　<br>　　从新更改user表中username的字符集<br>　　mysql&gt; alter table users modify username char(20) character set gbk;<br>　　Query OK, 0 rows affected (0.06 sec)<br>　　Records: 0 Duplicates: 0 Warnings: 0<br>　　<br>　　这时再插入中文字符，插入成</em></strong>。<br>　　mysql&gt; insert into users values(88,’中文’);<br>　　Query OK, 1 row affected (0.01 sec)<br>　　<br>　　mysql&gt; select * from users;<br>　　+——–+———-+<br>　　| userid | username |<br>　　+——–+———-+<br>　　| 88 | 中文 |<br>　　+——–+———-+<br>　　1 row in set (0.00 sec)<br>　　mysql&gt;</p>
<h1 id="转载声明：本文转自http-hi-baidu-com-zhjlabm-blog-item-b939fc3307a1d445ad4b5fbd-html"><a href="#转载声明：本文转自http-hi-baidu-com-zhjlabm-blog-item-b939fc3307a1d445ad4b5fbd-html" class="headerlink" title="转载声明：本文转自http://hi.baidu.com/zhjlabm/blog/item/b939fc3307a1d445ad4b5fbd.html"></a>转载声明：本文转自<a href="http://hi.baidu.com/zhjlabm/blog/item/b939fc3307a1d445ad4b5fbd.html" target="_blank" rel="external">http://hi.baidu.com/zhjlabm/blog/item/b939fc3307a1d445ad4b5fbd.html</a></h1><h3 id="学习MySQL常用操作命令"><a href="#学习MySQL常用操作命令" class="headerlink" title="学习MySQL常用操作命令"></a>学习MySQL常用操作命令</h3><h4 id="1、启动MySQL服务器"><a href="#1、启动MySQL服务器" class="headerlink" title="1、启动MySQL服务器"></a>1、启动MySQL服务器</h4><p>实际上上篇已讲到如何启动MySQL。两种方法： 一是用winmysqladmin，如果机器启动时已自动运行，则可直接进入下一步操作。 二是在DOS方式下运行 d:mysqlbinmysqld</p>
<h4 id="2、进入mysql交互操作界面"><a href="#2、进入mysql交互操作界面" class="headerlink" title="2、进入mysql交互操作界面"></a>2、进入mysql交互操作界面</h4><p>在DOS方式下，运行： d:mysqlbinmysql<br>出现: mysql 的提示符，此时已进入mysql的交互操作方式。<br>如果出现 “ERROR 2003: Can′t connect to MySQL server on ′localhost′ (10061)“，<br>说明你的MySQL还没有启动。</p>
<h4 id="3、退出MySQL操作界面"><a href="#3、退出MySQL操作界面" class="headerlink" title="3、退出MySQL操作界面"></a>3、退出MySQL操作界面</h4><p>在mysql&gt;提示符下输入quit可以随时退出交互操作界面：<br>mysql&gt; quit<br>Bye<br>你也可以用control-D退出。</p>
<h4 id="4、第一条命令"><a href="#4、第一条命令" class="headerlink" title="4、第一条命令"></a>4、第一条命令</h4><p>mysql&gt; select version(),current_date();<br>+—————-+—————–+<br>| version() | current_date() |<br>+—————-+—————–+<br>| 3.23.25a-debug | 2001-05-17 |<br>+—————-+—————–+<br>1 row in set (0.01 sec)<br>mysql&gt;</p>
<p>此命令要求mysql服务器告诉你它的版本号和当前日期。尝试用不同大小写操作上述命令，看结果如何。结果说明mysql命令的大小写结果是一致的。<br>练习如下操作：<br>mysql&gt;Select (20+5)<em>4;<br>mysql&gt;Select (20+5)</em>4,sin(pi()/3);<br>mysql&gt;Select (20+5)*4 AS Result,sin(pi()/3); (AS: 指定假名为Result) </p>
<h4 id="5、多行语句"><a href="#5、多行语句" class="headerlink" title="5、多行语句"></a>5、多行语句</h4><pre><code>一条命令可以分成多行输入，直到出现分号“；”为止： 
</code></pre><p><ccid_nobr></ccid_nobr></p>
<p><table width="400" border="1" cellspacing="0" cellpadding="2" bordercolorlight="black" bordercolordark="#FFFFFF" align="center"></table></p>
<p><tr></tr></p>
<p><td bgcolor="e6e6e6" class="code" style="font-size:9pt"></td></p>
<p><pre><ccid_code> mysql&gt; select<br>-&gt; USER()<br>-&gt; ,<br>-&gt; now()<br>-&gt;;<br>+——————–+———————+<br>| USER() | now() |<br>+——————–+———————+<br>| ODBC@localhost | 2001-05-17 22:59:15 |<br>+——————–+———————+<br>1 row in set (0.06 sec)<br>mysql&gt;</ccid_code></pre></p>
<p>注意中间的逗号和最后的分号的使用方法。</p>
<h4 id="6、一行多命令"><a href="#6、一行多命令" class="headerlink" title="6、一行多命令"></a>6、一行多命令</h4><p>输入如下命令：<br>mysql&gt; SELECT USER(); SELECT NOW();<br>+——————+<br>| USER() |<br>+——————+<br>| ODBC@localhost |<br>+——————+<br>1 row in set (0.00 sec)<br>+———————+<br>| NOW() |<br>+———————+<br>| 2001-05-17 23:06:15 |<br>+———————+<br>1 row in set (0.00 sec)<br>mysql&gt;</p>
<p>注意中间的分号，命令之间用分号隔开。</p>
<h4 id="7、显示当前存在的数据库"><a href="#7、显示当前存在的数据库" class="headerlink" title="7、显示当前存在的数据库"></a>7、显示当前存在的数据库</h4><p>mysql&gt; show databases;<br>+———-+<br>| Database |<br>+———-+<br>| mysql |<br>| test |<br>+———-+<br>2 row in set (0.06 sec)<br>mysql&gt;</p>
<h4 id="8、选择数据库并显示当前选择的数据库"><a href="#8、选择数据库并显示当前选择的数据库" class="headerlink" title="8、选择数据库并显示当前选择的数据库"></a>8、选择数据库并显示当前选择的数据库</h4><p>mysql&gt; USE mysql<br>Database changed<br>mysql&gt;<br>(USE 和 QUIT 命令不需要分号结束。）<br>mysql&gt; select database();<br>+—————+<br>| database() |<br>+—————+<br>| mysql |<br>+—————+<br>1 row in set (0.00 sec)</p>
<h4 id="9、显示当前数据库中存在的表"><a href="#9、显示当前数据库中存在的表" class="headerlink" title="9、显示当前数据库中存在的表"></a>9、显示当前数据库中存在的表</h4><p>mysql&gt; SHOW TABLES;</p>
<h4 id="10、显示表-db-的内容"><a href="#10、显示表-db-的内容" class="headerlink" title="10、显示表(db)的内容"></a>10、显示表(db)的内容</h4><p>mysql&gt;select * from db;</p>
<h4 id="11、命令的取消"><a href="#11、命令的取消" class="headerlink" title="11、命令的取消"></a>11、命令的取消</h4><p>当命令输入错误而又无法改变（多行语句情形）时，只要在分号出现前就可以用 c来取消该条命令<br>mysql&gt; select *<br>-&gt; user()<br>-&gt; c<br>mysql&gt;<br>这是一些最常用的最基本的操作命令，通过多次练习就可以牢牢掌捂了</p>
<p>==========================================================================</p>
<h3 id="mysql命令"><a href="#mysql命令" class="headerlink" title="mysql命令"></a>mysql命令</h3><p>测试环境：mysql 5.0.45<br>【注：可以在mysql中通过mysql&gt; SELECT VERSION();来查看数据库版本】<br>整理：leo</p>
<h4 id="一、连接MYSQL。"><a href="#一、连接MYSQL。" class="headerlink" title="一、连接MYSQL。"></a>一、连接MYSQL。</h4><p>格式： mysql -h主机地址 -u用户名 －p用户密码</p>
<ul>
<li>1、连接到本机上的MYSQL。<br>首先打开DOS窗口，然后进入目录mysql/bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码.<br>如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt;</li>
<li>2、连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令：<br>mysql -h110.110.110.110 -u root -p 123; （注:u与root之间可以不用加空格，其它也一样）</li>
<li>3、退出MYSQL命令： exit （回车）</li>
</ul>
<h4 id="二、修改密码。"><a href="#二、修改密码。" class="headerlink" title="二、修改密码。"></a>二、修改密码。</h4><p>格式：mysqladmin -u用户名 -p旧密码 password 新密码</p>
<ul>
<li>1、给root加个密码ab12。首先在DOS下进入目录mysql/bin，然后键入以下命令<br>mysqladmin -u root -password ab12<br>注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。</li>
<li>2、再将root的密码改为djg345。<br>mysqladmin -u root -p ab12 password djg345<h4 id="三、增加新用户。"><a href="#三、增加新用户。" class="headerlink" title="三、增加新用户。"></a>三、增加新用户。</h4>（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）<br>格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”</li>
<li><p>1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：<br>grant select,insert,update,delete on <em>.</em> to [email=test1@”%]test1@”%[/email]” Identified by “abc”;<br>但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。</p>
</li>
<li><p>2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），<br>这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。<br>grant select,insert,update,delete on mydb.<em> to [email=test2@localhost]test2@localhost[/email] identified by “abc”;<br>如果你不想test2有密码，可以再打一个命令将密码消掉。<br>grant select,insert,update,delete on mydb.</em> to [email=test2@localhost]test2@localhost[/email] identified by “”;</p>
<h3 id="下篇我是MYSQL中有关数据库方面的操作。注意：你必须首先登录到MYSQL中，以下操作都是在MYSQL的提示符下进行的，而且每个命令以分号结束。"><a href="#下篇我是MYSQL中有关数据库方面的操作。注意：你必须首先登录到MYSQL中，以下操作都是在MYSQL的提示符下进行的，而且每个命令以分号结束。" class="headerlink" title="下篇我是MYSQL中有关数据库方面的操作。注意：你必须首先登录到MYSQL中，以下操作都是在MYSQL的提示符下进行的，而且每个命令以分号结束。"></a>下篇我是MYSQL中有关数据库方面的操作。注意：你必须首先登录到MYSQL中，以下操作都是在MYSQL的提示符下进行的，而且每个命令以分号结束。</h3><h4 id="一、操作技巧"><a href="#一、操作技巧" class="headerlink" title="一、操作技巧"></a>一、操作技巧</h4></li>
<li>1、如果你打命令时，回车后发现忘记加分号，你无须重打一遍命令，只要打个分号回车就可以了。<br>也就是说你可以把一个完整的命令分成几行来打，完后用分号作结束标志就OK。</li>
<li>2、你可以使用光标上下键调出以前的命令。<h4 id="二、显示命令"><a href="#二、显示命令" class="headerlink" title="二、显示命令"></a>二、显示命令</h4></li>
<li><p>1、显示当前数据库服务器中的数据库列表：<br>mysql&gt; SHOW DATABASES;<br>注意：mysql库里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p>
</li>
<li><p>2、显示数据库中的数据表：<br>mysql&gt; USE 库名；<br>mysql&gt; SHOW TABLES;</p>
</li>
<li><p>3、显示数据表的结构：<br>mysql&gt; DESCRIBE 表名;</p>
</li>
<li><p>4、建立数据库：<br>mysql&gt; CREATE DATABASE 库名;</p>
</li>
<li><p>5、建立数据表：<br>mysql&gt; USE 库名;<br>mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1));</p>
</li>
<li><p>6、删除数据库：<br>mysql&gt; DROP DATABASE 库名;</p>
</li>
<li><p>7、删除数据表：<br>mysql&gt; DROP TABLE 表名；</p>
</li>
<li><p>8、将表中记录清空：<br>mysql&gt; DELETE FROM 表名;</p>
</li>
<li><p>9、显示表中的记录：<br>mysql&gt; SELECT * FROM 表名;</p>
</li>
<li><p>10、往表中插入记录：<br>mysql&gt; INSERT INTO 表名 VALUES (”hyq”,”M”);</p>
</li>
<li><p>11、更新表中数据：<br>mysql-&gt; UPDATE 表名 SET 字段名1=’a’,字段名2=’b’ WHERE 字段名3=’c’;</p>
</li>
<li><p>12、用文本方式将数据装入数据表中：<br>mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE 表名;</p>
</li>
<li><p>13、导入.sql文件命令：<br>mysql&gt; USE 数据库名;<br>mysql&gt; SOURCE d:/mysql.sql;</p>
</li>
<li><p>14、命令行修改root密码：<br>mysql&gt; UPDATE mysql.user SET password=PASSWORD(’新密码’) WHERE User=’root’;<br>mysql&gt; FLUSH PRIVILEGES;</p>
</li>
<li><p>15、显示use的数据库名：<br>mysql&gt; SELECT DATABASE();</p>
</li>
<li><p>16、显示当前的user：<br>mysql&gt; SELECT USER();</p>
<h4 id="三、一个建库和建表以及插入数据的实例"><a href="#三、一个建库和建表以及插入数据的实例" class="headerlink" title="三、一个建库和建表以及插入数据的实例"></a>三、一个建库和建表以及插入数据的实例</h4><p>drop database if exists school; //如果存在SCHOOL则删除<br>create database school;           //建立库SCHOOL<br>use school;   //打开库SCHOOL<br>create table teacher //建立表TEACHER<br>(<br>id int(3) auto_increment not null primary key,<br>name char(10) not null,<br>address varchar(50) default ‘深圳’,<br>year date<br>); //建表结束<br>//以下为插入字段<br>insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);<br>insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′);</p>
</li>
</ul>
<h3 id="如果你在mysql提示符键入上面的命令也可以，但不方便调试。"><a href="#如果你在mysql提示符键入上面的命令也可以，但不方便调试。" class="headerlink" title="如果你在mysql提示符键入上面的命令也可以，但不方便调试。"></a>如果你在mysql提示符键入上面的命令也可以，但不方便调试。</h3><ul>
<li>（1）你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c://下，并在DOS状态进入目录[url=file:////mysql//bin]//mysql//bin[/url]，然后键入以下命令：<br>mysql -uroot -p密码 &lt; c://school.sql<br>如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。</li>
<li>（2）或者进入命令行后使用 mysql&gt; source c://school.sql; 也可以将school.sql文件导入数据库中。</li>
</ul>
<h3 id="将文本数据转到数据库中"><a href="#将文本数据转到数据库中" class="headerlink" title="将文本数据转到数据库中"></a>将文本数据转到数据库中</h3><ul>
<li>1、文本数据应符合的格式：字段数据之间用tab键隔开，null值用[url=file:////n]//n[/url]来代替.例：<br>3 rose 大连二中 1976-10-10<br>4 mike 大连一中 1975-12-23<br>假设你把这两组数据存为school.txt文件，放在c盘根目录下。</li>
<li>2、数据传入命令 load data local infile “c://school.txt” into table 表名;<br>注意：你最好将文件复制到[url=file:////mysql//bin]//mysql//bin[/url]目录下，并且要先用use命令打表所在的库。</li>
</ul>
<h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><ul>
<li>1.导出整个数据库<br>导出文件默认是存在mysql/bin目录下<br>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名<br>mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql</li>
<li>2.导出一个表<br>mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名<br>mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql</li>
<li>3.导出一个数据库结构<br>mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql<br>-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table</li>
<li>4.带语言参数导出<br>mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql</li>
</ul>
<h3 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h3><p>例如：数据库名为 dbTest<br>首先，进入mysql<br>mysql -uroot -p123456<br>然后，创建数据库<br>create dbTest<br>exit<br>最后，导入数据库<br>mysql -uroot -p123456 dbTest &lt; dbTest_bk.sql</p>
<h3 id="数据库及表导出导入示例："><a href="#数据库及表导出导入示例：" class="headerlink" title="数据库及表导出导入示例："></a>数据库及表导出导入示例：</h3><h4 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h4><p>mysqldump -u root -p123456 gameTop &gt; gameTop_db.sql</p>
<p>导出数据库的表<br>mysqldump -u -p123456 root gameTop gametop800 &gt; gameTop_table.sql</p>
<p>导出数据库的特定表<br>mysqldump -u root -p123456  gameTop –table gametop800  &gt; gameTop_table.sql</p>
<h4 id="导出数据库（只导结构，不要数据）"><a href="#导出数据库（只导结构，不要数据）" class="headerlink" title="导出数据库（只导结构，不要数据）"></a>导出数据库（只导结构，不要数据）</h4><p>mysqldump -u root -p123456 –opt -d gameTop &gt; gameTop_db.sql<br>或者<br>mysqldump -u root -p123456  -d gameTop &gt; gameTop_db.sql</p>
<p>导出数据库（只导数据，不要结构）<br>mysqldump -u root -p123456  -t gameTop &gt; gameTop_db.sql</p>
<h5 id="注：不加-d-和-t-则既导出结构，也导出数据"><a href="#注：不加-d-和-t-则既导出结构，也导出数据" class="headerlink" title="注：不加 -d 和 -t 则既导出结构，也导出数据"></a>注：不加 -d 和 -t 则既导出结构，也导出数据</h5><p>mysqldump导出抛出异常：<br>mysqldump: Got error: 1044: Access denied for user ‘username’@’%’ to database ‘dbname’ when using LOCK TABLES<br>解决办法，添加参数 –skip-lock-tables：<br>mysqldump –skip-lock-tables -h172.88.12.102 -username-pAnJnVs3C2tYXyTwV dbname&gt; dbname_bk.sql</p>
<hr>
<h4 id="导入数据库："><a href="#导入数据库：" class="headerlink" title="导入数据库："></a>导入数据库：</h4><p>登录MySQL:      mysql -uroot -p123456<br>创建数据库：    create database gameTop;</p>
<p>导入数据库：<br>mysql -uroot -p123456 gameTop &lt; gameTop_db.sql</p>
<p>导入数据库表：<br>mysql -uroot -p123456 gameTop  gametop800 &lt;  gameTop_table.sql</p>
<p>导入数据库表：<br>mysql -uroot -p123456 gameTop  &lt; gameTop_table.sql   （不指定表名）</p>
<h1 id="转载声明：本文转自http-blog-csdn-net-networld2002-archive-2009-04-23-4103407-aspx"><a href="#转载声明：本文转自http-blog-csdn-net-networld2002-archive-2009-04-23-4103407-aspx" class="headerlink" title="转载声明：本文转自http://blog.csdn.net/networld2002/archive/2009/04/23/4103407.aspx"></a>转载声明：本文转自<a href="http://blog.csdn.net/networld2002/archive/2009/04/23/4103407.aspx" target="_blank" rel="external">http://blog.csdn.net/networld2002/archive/2009/04/23/4103407.aspx</a></h1><ul>
<li><p>1:使用SHOW语句找出在服务器上当前存在什么数据库：<br>mysql&gt; SHOW DATABASES;</p>
</li>
<li><p>2:创建一个数据库MYSQLDATA<br>mysql&gt; CREATE DATABASE MYSQLDATA;</p>
</li>
<li><p>3:选择你所创建的数据库<br>mysql&gt; USE MYSQLDATA; (按回车键出现Database changed 时说明操作成功！)</p>
</li>
<li><p>4:查看现在的数据库中存在什么表<br>mysql&gt; SHOW TABLES;</p>
</li>
<li><p>5:创建一个数据库表<br>mysql&gt; CREATE TABLE MYTABLE (name VARCHAR(20), sex CHAR(1));</p>
</li>
<li><p>6:显示表的结构：<br>mysql&gt; DESCRIBE MYTABLE;</p>
</li>
<li><p>7:往表中加入记录<br>mysql&gt; insert into MYTABLE values (”hyq”,”M”);</p>
</li>
<li>8:用文本方式将数据装入数据库表中（例如D:/mysql.txt）<br>mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE MYTABLE;</li>
<li><p>9:导入.sql文件命令（例如D:/mysql.sql）<br>mysql&gt;use database;<br>mysql&gt;source d:/mysql.sql;</p>
</li>
<li><p>10:删除表<br>mysql&gt;drop TABLE MYTABLE;</p>
</li>
<li><p>11:清空表<br>mysql&gt;delete from MYTABLE;</p>
</li>
<li><p>12:更新表中数据<br>mysql&gt;update MYTABLE set sex=”f” where name=’hyq’;</p>
</li>
</ul>
<h2 id="以下是无意中在网络看到的使用MySql的管理心得"><a href="#以下是无意中在网络看到的使用MySql的管理心得" class="headerlink" title="以下是无意中在网络看到的使用MySql的管理心得,"></a>以下是无意中在网络看到的使用MySql的管理心得,</h2><p>在windows中MySql以服务形式存在，在使用前应确保此服务已经启动，未启动可用net start mysql命令启动。而Linux中启动时可用“/etc/rc.d/init.d/mysqld start”命令，注意启动者应具有管理员权限。<br>刚安装好的MySql包含一个含空密码的root帐户和一个匿名帐户，这是很大的安全隐患，对于一些重要的应用我们应将安全性尽可能提高，在这里应把匿名帐户删除、 root帐户设置密码，可用如下命令进行：<br>use mysql;<br>delete from User where User=””;<br>update User set Password=PASSWORD(’newpassword’) where User=’root’;</p>
<p>如果要对用户所用的登录终端进行限制，可以更新User表中相应用户的Host字段，在进行了以上更改后应重新启动数据库服务，此时登录时可用如下类似命令：<br>mysql -uroot -p;<br>mysql -uroot -pnewpassword;<br>mysql mydb -uroot -p;<br>mysql mydb -uroot -pnewpassword;<br>上面命令参数是常用参数的一部分，详细情况可参考文档。此处的mydb是要登录的数据库的名称。<br>在 进行开发和实际应用中，用户不应该只用root用户进行连接数据库，虽然使用root用户进行测试时很方便，但会给系统带来重大安全隐患，也不利于管理技 术的提高。我们给一个应用中使用的用户赋予最恰当的数据库权限。如一个只进行数据插入的用户不应赋予其删除数据的权限。<br>MySql的用户管理是通过 User表来实现的，添加新用户常用的方法有两个，一是在User表插入相应的数据行，同时设置相应的权限；二是通过GRANT命令创建具有某种权限的用 户。<br>其中GRANT的常用用法如下：</p>
<p>grant all on mydb.<em> to NewUserName@HostName identified by “password” ;<br>grant usage on </em>.<em> to NewUserName@HostName identified by “password”;<br>grant select,insert,update on mydb.</em> to NewUserName@HostName identified by “password”;<br>grant update,delete on mydb.TestTable to NewUserName@HostName identified by “password”;</p>
<p>若 要给此用户赋予他在相应对象上的权限的管理能力，可在GRANT后面添加WITH GRANT OPTION选项。而对于用插入User表添加的用户，Password字段应用PASSWORD 函数进行更新加密，以防不轨之人窃看密码。对于那些已经不用的用户应给予清除，权限过界的用户应及时回收权限，回收权限可以通过更新User表相应字段， 也可以使用REVOKE操作。<br>下面给出本人从其它资料(www.cn-Java.com)获得的对常用权限的解释：<br>全局管理权限：<br>FILE: 在MySQL服务器上读写文件。<br>PROCESS: 显示或杀死属于其它用户的服务线程。<br>RELOAD: 重载访问控制表，刷新日志等。<br>SHUTDOWN: 关闭MySQL服务。<br>数据库/数据表/数据列权限：<br>ALTER: 修改已存在的数据表(例如增加/删除列)和索引。<br>CREATE: 建立新的数据库或数据表。<br>DELETE: 删除表的记录。<br>DROP: 删除数据表或数据库。<br>INDEX: 建立或删除索引。<br>INSERT: 增加表的记录。<br>SELECT: 显示/搜索表的记录。<br>UPDATE: 修改表中已存在的记录。<br>特别的权限：<br>ALL: 允许做任何事(和root一样)。<br>USAGE: 只允许登录–其它什么也不允许做。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL-数据库常用命令&quot;&gt;&lt;a href=&quot;#MySQL-数据库常用命令&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据库常用命令&quot;&gt;&lt;/a&gt;MySQL 数据库常用命令&lt;/h2&gt;&lt;h3 id=&quot;1、MySQL常用命令&quot;&gt;&lt;a href=&quot;#1、MySQL常用命令&quot; class=&quot;headerlink&quot; title=&quot;1、MySQL常用命令&quot;&gt;&lt;/a&gt;1、MySQL常用命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;create database name; 创建数据库&lt;/li&gt;
&lt;li&gt;use databasename; 选择数据库&lt;/li&gt;
&lt;li&gt;drop database name 直接删除数据库，不提醒&lt;/li&gt;
&lt;li&gt;show tables; 显示表&lt;/li&gt;
&lt;li&gt;describe tablename; 表的详细描述&lt;/li&gt;
&lt;li&gt;select 中加上distinct去除重复字段&lt;/li&gt;
&lt;li&gt;mysqladmin drop databasename 删除数据库前，有提示。&lt;/li&gt;
&lt;li&gt;显示当前mysql版本和当前日期&lt;/li&gt;
&lt;li&gt;select version(),current_date;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/05/08/hello-world/"/>
    <id>http://yoursite.com/2017/05/08/hello-world/</id>
    <published>2017-05-08T02:18:40.242Z</published>
    <updated>2017-05-08T02:18:40.243Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js笔记</title>
    <link href="http://yoursite.com/2017/05/01/vue-js%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/05/01/vue-js笔记/</id>
    <published>2017-05-01T03:29:40.000Z</published>
    <updated>2017-05-16T03:32:59.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每多学一点知识，就少写一行代码。"><a href="#每多学一点知识，就少写一行代码。" class="headerlink" title="每多学一点知识，就少写一行代码。"></a>每多学一点知识，就少写一行代码。</h1><h2 id="1、Vue-js使用vue-resource实现ajax请求"><a href="#1、Vue-js使用vue-resource实现ajax请求" class="headerlink" title="1、Vue.js使用vue-resource实现ajax请求"></a>1、Vue.js使用vue-resource实现ajax请求</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by gequn06 on 2017/3/20.</div><div class="line"> */</div><div class="line">import Vue from 'vue/dist/vue.common.js';</div><div class="line">import VueResource from 'vue-resource';</div><div class="line">Vue.use(VueResource);</div><div class="line">new Vue(&#123;</div><div class="line">    el: '#doctorWrap',</div><div class="line">    data: &#123;</div><div class="line">        someData : null</div><div class="line">    &#125;,</div><div class="line">    created :function () &#123;</div><div class="line">        this.$http.get('/public/js/data.json').then(function(response)&#123;</div><div class="line">            console.log(response)</div><div class="line">            // get body data</div><div class="line">            this.someData = response.body.sites;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、Vue-js引用css"><a href="#2、Vue-js引用css" class="headerlink" title="2、Vue.js引用css"></a>2、Vue.js引用css</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line">  @import '../assets/hello.css';</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="3、过滤器"><a href="#3、过滤器" class="headerlink" title="3、过滤器"></a>3、过滤器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"msg | filterA | filterB"</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'hello'</span>,</div><div class="line">  data () &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">msg</span>: <span class="string">'thanks'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">filters</span>: &#123;</div><div class="line">    <span class="attr">filterA</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></div><div class="line">      value = value.toString()</div><div class="line">      <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">filterB</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></div><div class="line">      value = value.toString();</div><div class="line">      <span class="keyword">return</span> value.slice(<span class="number">0</span>, <span class="number">1</span>) + value.charAt(<span class="number">2</span>).toUpperCase() + value.slice(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="4、Computed-Properties-and-Watchers"><a href="#4、Computed-Properties-and-Watchers" class="headerlink" title="4、Computed Properties and Watchers"></a>4、Computed Properties and Watchers</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#example'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">message</span>: <span class="string">'Hello'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    <span class="comment">// a computed getter</span></div><div class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// `this` points to the vm instance</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="5、component-lists-rendered-with-v-for-should-have-explicit-keys"><a href="#5、component-lists-rendered-with-v-for-should-have-explicit-keys" class="headerlink" title="5、component lists rendered with v-for should have explicit keys"></a>5、component lists rendered with v-for should have explicit keys</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">v-for需要绑定:key</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">el-select</span> <span class="attr">v-model</span>=<span class="string">"value"</span> <span class="attr">placeholder</span>=<span class="string">"请选择"</span>  <span class="attr">class</span>=<span class="string">"meeting-duration-select"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">el-option</span></span></div><div class="line">            <span class="attr">v-for</span>=<span class="string">"(item,index) in options"</span></div><div class="line">            <span class="attr">:key</span>=<span class="string">"item.value"</span></div><div class="line">            <span class="attr">:label</span>=<span class="string">"item.label"</span></div><div class="line">            <span class="attr">:value</span>=<span class="string">"item.value"</span>&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">el-option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">el-select</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每多学一点知识，就少写一行代码。&quot;&gt;&lt;a href=&quot;#每多学一点知识，就少写一行代码。&quot; class=&quot;headerlink&quot; title=&quot;每多学一点知识，就少写一行代码。&quot;&gt;&lt;/a&gt;每多学一点知识，就少写一行代码。&lt;/h1&gt;&lt;h2 id=&quot;1、Vue-js使用vue-resource实现ajax请求&quot;&gt;&lt;a href=&quot;#1、Vue-js使用vue-resource实现ajax请求&quot; class=&quot;headerlink&quot; title=&quot;1、Vue.js使用vue-resource实现ajax请求&quot;&gt;&lt;/a&gt;1、Vue.js使用vue-resource实现ajax请求&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * Created by gequn06 on 2017/3/20.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import Vue from &#39;vue/dist/vue.common.js&#39;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import VueResource from &#39;vue-resource&#39;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Vue.use(VueResource);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    el: &#39;#doctorWrap&#39;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    data: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        someData : null&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    created :function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        this.$http.get(&#39;/public/js/data.json&#39;).then(function(response)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            console.log(response)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            // get body data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            this.someData = response.body.sites;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目中的常见问题题_vue_store</title>
    <link href="http://yoursite.com/2017/04/26/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%A2%98-vue-store/"/>
    <id>http://yoursite.com/2017/04/26/项目中的常见问题题-vue-store/</id>
    <published>2017-04-26T02:47:16.000Z</published>
    <updated>2017-05-16T03:24:17.462Z</updated>
    
    <content type="html"><![CDATA[<p>我会把我做关于模仿微博的这个项目遇到的一些问题公开在这里，遇到不对的地方请指教，发送<a href="https://www.wang1348168417@gmail.com" target="_blank" rel="external">邮件wang1348168417@gmail.com</a>，或者扫我的微信二维码。<br>一个简单的状态管理</p>
<h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源:"></a>单一数据源:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const sourceOfTruth = &#123;&#125;</div><div class="line">const vmA = new Vue(&#123;</div><div class="line">  data: sourceOfTruth</div><div class="line">&#125;)</div><div class="line">const vmB = new Vue(&#123;</div><div class="line">  data: sourceOfTruth</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>每当 sourceOfTruth 发生变化, vmA 和 vmB 都会自动更新它们的视图. 子组件可以通过 this.$root.$data 访问数据. 现在我们有了单一的数据源, 但是调试会很困难. 因为无论何时数据源发生变化都会改变程序, 但是没有任何迹象表明变化发生.<a id="more"></a></p>
<h3 id="store-pattern"><a href="#store-pattern" class="headerlink" title="store pattern"></a>store pattern</h3><p>为了解决上述问题, 我们可以引入 store pattern:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var store = &#123;</div><div class="line">  debug: true,</div><div class="line">  state: &#123;</div><div class="line">    message: 'Hello!'</div><div class="line">  &#125;,</div><div class="line">  setMessageAction (newValue) &#123;</div><div class="line">    this.debug &amp;&amp; console.log('setMessageAction triggered with', newValue)</div><div class="line">    this.state.message = newValue</div><div class="line">  &#125;,</div><div class="line">  clearMessageAction () &#123;</div><div class="line">    this.debug &amp;&amp; console.log('clearMessageAction triggered')</div><div class="line">    this.state.message = 'action B triggered'</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所有的数据改变都发生 store 内. 这种集中的状态管理模式使我们很容易记录变化发生, 如何发生.<br>除了单一的数据源外, 每个 vue 实例或组件也可以有其私有状态:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var vmA = new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    privateState: &#123;&#125;,</div><div class="line">    sharedState: store.state</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">var vmB = new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    privateState: &#123;&#125;,</div><div class="line">    sharedState: store.state</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 如果 Vuex 不是全局的, 那么确保调用 Vue.use(Vuex) 使 Vuex 生效.</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  // 数据源</div><div class="line">  state: &#123;</div><div class="line">    count: 0</div><div class="line">  &#125;,</div><div class="line">  // 数据操作</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 触发数据变化操作</div><div class="line">store.commit('increment')</div><div class="line"></div><div class="line">console.log(store.state.count) // -&gt; 1</div></pre></td></tr></table></figure>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>store 自动注入到子组件中</p>
<p>通常我们通过计算属性来访问 store 中的数据, 这样就能感知到数据发生变化.<br>根组件的 store 属性会注入到其所有的子组件中. (通过 Vue.use(Vuex) 生效)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const Counter = &#123;</div><div class="line">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</div><div class="line">    computed: &#123;</div><div class="line">        count() &#123;</div><div class="line">            // 子组件通过 this.$store 访问父组件的 store</div><div class="line">            return this.$store.state.count</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">    // 父对象中的 store 自动注入到子组件</div><div class="line">    store,</div><div class="line">    componets: &#123;</div><div class="line">        Counter</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>如果 store 中有许多数据需要访问, 每个数据都需要定义一个计算属性会非常麻烦. Vuex 提供了 mapState 来简化计算属性的定义.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import &#123; mapState &#125; from 'vuex'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  computed: mapState(&#123;</div><div class="line">    // es6 箭头函数更加简洁</div><div class="line">    count: state =&gt; state.count,</div><div class="line"></div><div class="line">    // 字符串 'count' 等同于 `state =&gt; state.count`</div><div class="line">    countAlias: 'count',</div><div class="line"></div><div class="line">    // 为了访问组件的 `this`, 必须使用普通的函数</div><div class="line">    // 箭头函数会绑定 `this` 到 `mapState` 的参数这个对象</div><div class="line">    countPlusLocalState (state) &#123;</div><div class="line">      return state.count + this.localCount</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果计算属性和 store 中数据是一一对应的, 可以使用更简单的字符串数组:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">computed: mapState([</div><div class="line">  // map this.count to store.state.count</div><div class="line">  'count'</div><div class="line">])</div></pre></td></tr></table></figure></p>
<h3 id="es6-的扩展操作符"><a href="#es6-的扩展操作符" class="headerlink" title="es6 的扩展操作符"></a>es6 的扩展操作符</h3><p>使用 mapState 返回一个对象, 如果组件还有私有的计算属性, 通常我们可以使用 _.extend({localComputed}, mapState(…)) 这种方式合并对象已得到最终的 computed. 使用 es6 的扩展操作符可以简化:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    localComputed()&#123; /* ... */&#125;,</div><div class="line">    // 通过扩展操作符扩展 computed 对象</div><div class="line">    ...mapState(&#123;</div><div class="line">        // ...</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p>通常计算属性是基于一段 store 数据的代码, 比如过滤一个列表并计数:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodoCount() &#123;</div><div class="line">        return this.$store.state.todos.filter(todo =&gt; todo.done).length</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们需要复用这段代码, 基本就是重构提取出一个函数, 但是这样还不是很理想.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Vuex 在 store 中提供了 getters:</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    todos: [</div><div class="line">      &#123; id: 1, text: '...', done: true &#125;,</div><div class="line">      &#123; id: 2, text: '...', done: false &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    doneTodos: state =&gt; &#123;</div><div class="line">      return state.todos.filter(todo =&gt; todo.done)</div><div class="line">    &#125;,</div><div class="line">    doneTodosCount: (state, getters) =&gt; &#123;</div><div class="line">        return getters.doneTodos.length</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 通过 `store.getters` 访问</div><div class="line">store.getters.doneTodosCount</div></pre></td></tr></table></figure></p>
<p>上面的计算属性就可以改成:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodoCount() &#123;</div><div class="line">        return this.$store.getters.doneTodoCount</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><p>同 state 的 mapState 类似, getters 也有 mapGetters 来简化计算属性的定义<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; mapGetters &#125; from 'vuex'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  computed: &#123;</div><div class="line">    // mix the getters into computed with object spread operator</div><div class="line">    ...mapGetters([</div><div class="line">      'doneTodosCount',</div><div class="line">      'anotherGetter',</div><div class="line">      // ...</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用对象可以自定义对应关系<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mapGetters(&#123;</div><div class="line">  // map this.doneCount to store.getters.doneTodosCount</div><div class="line">  doneCount: 'doneTodosCount'</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>Vuex 中的 state 只能通过 mutations 来改变. mutations 很像事件, 都有一个类型和处理函数. 处理函数是真正改变 state 的地方, 并以 state 作为第一个参数.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: 1</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      // 改变 state</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>就是事件一样, 我们不能直接调用处理函数, 而是要通过 store.commit(type) 来触发 mutation 处理函数.</p>
<p>store.commit(‘increment’)<br>带 playload commit</p>
<p>我们可以将处理函数的参数放到第二个参数 playload 中:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  increment (state, payload) &#123;</div><div class="line">    state.count += payload.amount</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit('increment', &#123;amount: 10&#125;)</div><div class="line">对象风格 commit</div><div class="line"></div><div class="line">store.commit(&#123;</div><div class="line">    type: 'increment',</div><div class="line">    playload: &#123; amount: 10 &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="静默模式"><a href="#静默模式" class="headerlink" title="静默模式"></a>静默模式</h3><p>默认情况下, 每一次 commit 都会发送到插件 (比如: devtools) 中. 可能你会希望某些 commit 不被记录. 这时候可以传递第三个参数以设置为静默模式:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">store.commit('increment', &#123;</div><div class="line">  amount: 1</div><div class="line">&#125;, &#123; silent: true &#125;)</div><div class="line"></div><div class="line">// 对象风格 commit</div><div class="line">store.commit(&#123;</div><div class="line">  type: 'increment',</div><div class="line">  amount: 1</div><div class="line">&#125;, &#123; silent: true &#125;)</div></pre></td></tr></table></figure></p>
<p>Mutations 要遵守 Vue 的响应式规则</p>
<p>即:</p>
<p>提前初始化所有的状态值<br>添加新的属性到对象时, 你应该:<br>使用 Vue.set(obj, ‘newProp’, 123) 或<br>直接替换新的对象: state.obj = {…state.obj, newProp: 123}<br>使用常量为 Mutations 命名</p>
<p>使用常量为 Mutations 命名是各种 Flux 实现常用的模式. 将所有常量放到一个文件中, 我们能看到整个程序有什么情况数据会发生变化.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// mutation-types.js</div><div class="line">export const SOME_MUTATION = 'SOME_MUTATION'</div><div class="line"></div><div class="line">// store.js</div><div class="line">import Vuex from 'vuex'</div><div class="line">import &#123; SOME_MUTATION &#125; from './mutation-types'</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    // es6 特性 computed property name</div><div class="line">    // 属性名称运行时确定</div><div class="line">    [SOME_MUTATION] (state) &#123;</div><div class="line">      // mutate state</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="Mutations-必须是同步的"><a href="#Mutations-必须是同步的" class="headerlink" title="Mutations 必须是同步的"></a>Mutations 必须是同步的</h3><p>异步 mutations 调用违反了所有的状态变化必须在 store 中进行的规定. 比如:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  someMutation (state) &#123;</div><div class="line">    api.callAsyncMethod(() =&gt; &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上例中状态变化时, someMutation 已经结束了. 这时候如果有其他状态变化的操作发生, devtools 记录下来的状态变化就是错误的.</p>
<h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>我们可以通过 this.$store.commit(‘xxx’) 在组件中调用 mutations, 一般我们将这些调用分装到 methods 中, 同时 Vuex 也提供了 mapMutations 函数简化 methods 定义:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; mapMutations &#125; from 'vuex'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      'increment' // 映射 this.increment() 到 this.$store.commit('increment')</div><div class="line">    ]),</div><div class="line">    ...mapMutations(&#123;</div><div class="line">      add: 'increment' // map this.add() to this.$store.commit('increment')</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>异步的 mutations 使程序的状态变化难以追踪. 为了解决异步操作, Vuex 引入了 actions.<br>actions 跟 mutations 非常像, 它们的不同之处在于:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">actions 不改变 state, 而是 commit mutations</div><div class="line">actions 可以包含任意的异步操作</div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: 0</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    increment (context) &#123;</div><div class="line">      context.commit('increment')</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>actions 接收一个 context 对象作为参数, context 可以访问 commit, getters, state, 但是它不是 store 对象.<br>通常, 我们会使用 es6 的参数结构语法来简化代码:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    increment(&#123;commit&#125;) &#123;</div><div class="line">        commit('increment')</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Dispatching-Actions"><a href="#Dispatching-Actions" class="headerlink" title="Dispatching Actions"></a>Dispatching Actions</h3><p>actions 通过 store.dispatch 来触发:</p>
<p>store.dispatch(‘increment’)<br>dispatch 也支持 commit 中的 playload 参数以及对象风格的调用方式.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// dispatch with a payload</div><div class="line">store.dispatch('incrementAsync', &#123;</div><div class="line">  amount: 10</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// dispatch with an object</div><div class="line">store.dispatch(&#123;</div><div class="line">  type: 'incrementAsync',</div><div class="line">  amount: 10</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><p>类似 mapMutations</p>
<p>Actions 组合</p>
<p>actions 通常是异步的, 我们怎么来组合多个 actions 来执行复杂的操作?</p>
<p>首先我们需要知道的是 store.dispatch 返回 actions 中处理函数的返回值, 因此我们可以返回一个 Promise:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  actionA (&#123; commit &#125;) &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        commit('someMutation')</div><div class="line">        resolve()</div><div class="line">      &#125;, 1000)</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    // 组合</div><div class="line">    return dispatch('actionA').then(() =&gt; &#123;</div><div class="line">      commit('someOtherMutation')</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">使用 async/await 语法, 可以简化为:</div><div class="line"></div><div class="line">// 假设 getData() 和 getOtherData() 返回 Promises</div><div class="line"></div><div class="line">actions: &#123;</div><div class="line">  async actionA (&#123; commit &#125;) &#123;</div><div class="line">    commit('gotData', await getData())</div><div class="line">  &#125;,</div><div class="line">  async actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    await dispatch('actionA') // wait for actionA to finish</div><div class="line">    commit('gotOtherData', await getOtherData())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>当我们的程序足够大时, store 也会变得非常大, 其中的 state, getters, mutations, actions 也会非常大.</p>
<p>因此 Vuex 允许我们将 store 分成几个 modules, 每个 modules 都有自己的 state, getters, mutations, actions 甚至它自己的 modules.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;,</div><div class="line">  getters: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const moduleB = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    a: moduleA,</div><div class="line">    b: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.state.a // -&gt; moduleA's state</div><div class="line">store.state.b // -&gt; moduleB's state</div></pre></td></tr></table></figure></p>
<h3 id="Modules-当前状态"><a href="#Modules-当前状态" class="headerlink" title="Modules 当前状态"></a>Modules 当前状态</h3><p>在 modules 中, getters 和 mutations 的第一个参数都是 modules 的 state, 同样 actions 的 context.state 也是 modules 的 state, 根节点的状态可以通过 context.rootState 访问到. getters 的可以通过第三个参数访问 $rootState:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  // ...</div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      return state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###　命名空间</p>
<p>modules 的 state 放到根节点的对应的属性中, 而 actions, mutations 和 getters 没有命名空间. 所以多个 modules 可以对同一个 commit 或 dispatch 做响应. 因此必须自己通过前缀或后缀来避免命名冲突.</p>
<p>动态 Modules 注册<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.registerModule('myModule', &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div><div class="line">keep learning</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我会把我做关于模仿微博的这个项目遇到的一些问题公开在这里，遇到不对的地方请指教，发送&lt;a href=&quot;https://www.wang1348168417@gmail.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;邮件wang1348168417@gmail.com&lt;/a&gt;，或者扫我的微信二维码。&lt;br&gt;一个简单的状态管理&lt;/p&gt;
&lt;h3 id=&quot;单一数据源&quot;&gt;&lt;a href=&quot;#单一数据源&quot; class=&quot;headerlink&quot; title=&quot;单一数据源:&quot;&gt;&lt;/a&gt;单一数据源:&lt;/h3&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;const sourceOfTruth = &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;const vmA = new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  data: sourceOfTruth&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;const vmB = new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  data: sourceOfTruth&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每当 sourceOfTruth 发生变化, vmA 和 vmB 都会自动更新它们的视图. 子组件可以通过 this.$root.$data 访问数据. 现在我们有了单一的数据源, 但是调试会很困难. 因为无论何时数据源发生变化都会改变程序, 但是没有任何迹象表明变化发生.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Es6新特性</title>
    <link href="http://yoursite.com/2017/04/18/Es6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/04/18/Es6新特性/</id>
    <published>2017-04-18T07:36:32.000Z</published>
    <updated>2017-05-16T03:24:10.644Z</updated>
    
    <content type="html"><![CDATA[<p>####ECMAScript 6简介</p>
<p>###1.Class基本语法</p>
<p>##概述<br>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x;</div><div class="line">  <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。</p>
<p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6的类，完全可以看作构造函数的另一种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></div><div class="line">Point === Point.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">  doStuff() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar();</div><div class="line">b.doStuff() <span class="comment">// "stuff"</span></div></pre></td></tr></table></figure></p>
<p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toValue()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">Point.prototype = &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div><div class="line"></div><div class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;);</div><div class="line">prototype对象的<span class="keyword">constructor</span>属性，直接指向“类”的本身，这与ES5的行为是一致的。</div><div class="line"></div><div class="line">Point.prototype.<span class="keyword">constructor</span> === Point // true</div></pre></td></tr></table></figure></p>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<p>class Point {<br>  constructor(x, y) {<br>    // …<br>  }</p>
<p>  toString() {<br>    // …<br>  }<br>}</p>
<p>Object.keys(Point.prototype)<br>// []<br>Object.getOwnPropertyNames(Point.prototype)<br>// [“constructor”,”toString”]</p>
<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>
<p>var Point = function (x, y) {<br>  // …<br>};</p>
<p>Point.prototype.toString = function() {<br>  // …<br>};</p>
<p>Object.keys(Point.prototype)<br>// [“toString”]<br>Object.getOwnPropertyNames(Point.prototype)<br>// [“constructor”,”toString”]</p>
<p>上面代码采用ES5的写法，toString方法就是可枚举的。</p>
<p>类的属性名，可以采用表达式。</p>
<p>let methodName = “getArea”;<br>class Square{<br>  constructor(length) {<br>    // …<br>  }</p>
<p>  <a href="">methodName</a> {<br>    // …<br>  }<br>}</p>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<p>constructor方法<br>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<p>constructor() {}<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<p>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}</p>
<p>new Foo() instanceof Foo<br>// false</p>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<p>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}</p>
<p>Foo()<br>// TypeError: Class constructor Foo cannot be invoked without ‘new’</p>
<p>类的实例对象<br>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p>
<p>// 报错<br>var point = Point(2, 3);</p>
<p>// 正确<br>var point = new Point(2, 3);</p>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<p>//定义类<br>class Point {</p>
<p>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }</p>
<p>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }</p>
<p>}</p>
<p>var point = new Point(2, 3);</p>
<p>point.toString() // (2, 3)</p>
<p>point.hasOwnProperty(‘x’) // true<br>point.hasOwnProperty(‘y’) // true<br>point.hasOwnProperty(‘toString’) // false<br>point.<strong>proto</strong>.hasOwnProperty(‘toString’) // true</p>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。</p>
<p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p>
<p>p1.<strong>proto</strong> === p2.<strong>proto</strong><br>//true</p>
<p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以<strong>proto</strong>属性是相等的。</p>
<p>这也意味着，可以通过实例的<strong>proto</strong>属性为Class添加方法。</p>
<p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p>
<p>p1.<strong>proto</strong>.printName = function () { return ‘Oops’ };</p>
<p>p1.printName() // “Oops”<br>p2.printName() // “Oops”</p>
<p>var p3 = new Point(4,2);<br>p3.printName() // “Oops”</p>
<p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的<strong>proto</strong>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p>
<p>不存在变量提升<br>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<p>new Foo(); // ReferenceError<br>class Foo {}<br>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p>{<br>  let Foo = class {};<br>  class Bar extends Foo {<br>  }<br>}<br>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p>
<p>Class表达式<br>与函数一样，类也可以使用表达式的形式定义。</p>
<p>const MyClass = class Me {<br>  getClassName() {<br>    return Me.name;<br>  }<br>};<br>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<p>let inst = new MyClass();<br>inst.getClassName() // Me<br>Me.name // ReferenceError: Me is not defined<br>上面代码表示，Me只在Class内部有定义。</p>
<p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p>
<p>const MyClass = class { /<em> … </em>/ };<br>采用Class表达式，可以写出立即执行的Class。</p>
<p>let person = new class {<br>  constructor(name) {<br>    this.name = name;<br>  }</p>
<p>  sayName() {<br>    console.log(this.name);<br>  }<br>}(‘张三’);</p>
<p>person.sayName(); // “张三”<br>上面代码中，person是一个立即执行的类的实例。</p>
<p>私有方法<br>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<p>class Widget {</p>
<p>  // 公有方法<br>  foo (baz) {<br>    this._bar(baz);<br>  }</p>
<p>  // 私有方法<br>  _bar(baz) {<br>    return this.snaf = baz;<br>  }</p>
<p>  // …<br>}<br>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<p>class Widget {<br>  foo (baz) {<br>    bar.call(this, baz);<br>  }</p>
<p>  // …<br>}</p>
<p>function bar(baz) {<br>  return this.snaf = baz;<br>}<br>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</p>
<p>const bar = Symbol(‘bar’);<br>const snaf = Symbol(‘snaf’);</p>
<p>export default class myClass{</p>
<p>  // 公有方法<br>  foo(baz) {<br>    this<a href="baz">bar</a>;<br>  }</p>
<p>  // 私有方法<br>  <a href="baz">bar</a> {<br>    return this[snaf] = baz;<br>  }</p>
<p>  // …<br>};<br>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<p>this的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<p>class Logger {<br>  printName(name = ‘there’) {<br>    this.print(<code>Hello ${name}</code>);<br>  }</p>
<p>  print(text) {<br>    console.log(text);<br>  }<br>}</p>
<p>const logger = new Logger();<br>const { printName } = logger;<br>printName(); // TypeError: Cannot read property ‘print’ of undefined<br>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p>
<p>class Logger {<br>  constructor() {<br>    this.printName = this.printName.bind(this);<br>  }</p>
<p>  // …<br>}<br>另一种解决方法是使用箭头函数。</p>
<p>class Logger {<br>  constructor() {<br>    this.printName = (name = ‘there’) =&gt; {<br>      this.print(<code>Hello ${name}</code>);<br>    };<br>  }</p>
<p>  // …<br>}<br>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p>
<p>function selfish (target) {<br>  const cache = new WeakMap();<br>  const handler = {<br>    get (target, key) {<br>      const value = Reflect.get(target, key);<br>      if (typeof value !== ‘function’) {<br>        return value;<br>      }<br>      if (!cache.has(value)) {<br>        cache.set(value, value.bind(target));<br>      }<br>      return cache.get(value);<br>    }<br>  };<br>  const proxy = new Proxy(target, handler);<br>  return proxy;<br>}</p>
<p>const logger = selfish(new Logger());<br>严格模式<br>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<p>name属性<br>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<p>class Point {}<br>Point.name // “Point”<br>name属性总是返回紧跟在class关键字后面的类名。</p>
<p>Class的继承<br>基本用法<br>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<p>class ColorPoint extends Point {}<br>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p>
<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); // 调用父类的constructor(x, y)<br>    this.color = color;<br>  }</p>
<p>  toString() {<br>    return this.color + ‘ ‘ + super.toString(); // 调用父类的toString()<br>  }<br>}<br>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>class Point { /<em> … </em>/ }</p>
<p>class ColorPoint extends Point {<br>  constructor() {<br>  }<br>}</p>
<p>let cp = new ColorPoint(); // ReferenceError<br>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</p>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<p>constructor(…args) {<br>  super(…args);<br>}<br>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<p>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>}</p>
<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    this.color = color; // ReferenceError<br>    super(x, y);<br>    this.color = color; // 正确<br>  }<br>}<br>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p>
<p>下面是生成子类实例的代码。</p>
<p>let cp = new ColorPoint(25, 8, ‘green’);</p>
<p>cp instanceof ColorPoint // true<br>cp instanceof Point // true<br>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p>
<p>类的prototype属性和<strong>proto</strong>属性<br>大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</p>
<p>class A {<br>}</p>
<p>class B extends A {<br>}</p>
<p>B.<strong>proto</strong> === A // true<br>B.prototype.<strong>proto</strong> === A.prototype // true<br>上面代码中，子类B的<strong>proto</strong>属性指向父类A，子类B的prototype属性的<strong>proto</strong>属性指向父类A的prototype属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<p>class A {<br>}</p>
<p>class B {<br>}</p>
<p>// B的实例继承A的实例<br>Object.setPrototypeOf(B.prototype, A.prototype);<br>const b = new B();</p>
<p>// B的实例继承A的静态属性<br>Object.setPrototypeOf(B, A);<br>const b = new B();<br>《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。</p>
<p>Object.setPrototypeOf = function (obj, proto) {<br>  obj.<strong>proto</strong> = proto;<br>  return obj;<br>}<br>因此，就得到了上面的结果。</p>
<p>Object.setPrototypeOf(B.prototype, A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;</p>
<p>Object.setPrototypeOf(B, A);<br>// 等同于<br>B.<strong>proto</strong> = A;<br>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</p>
<p>Object.create(A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;<br>Extends 的继承目标<br>extends关键字后面可以跟多种类型的值。</p>
<p>class B extends A {<br>}<br>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</p>
<p>下面，讨论三种特殊情况。</p>
<p>第一种特殊情况，子类继承Object类。</p>
<p>class A extends Object {<br>}</p>
<p>A.<strong>proto</strong> === Object // true<br>A.prototype.<strong>proto</strong> === Object.prototype // true<br>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p>
<p>第二种特殊情况，不存在任何继承。</p>
<p>class A {<br>}</p>
<p>A.<strong>proto</strong> === Function.prototype // true<br>A.prototype.<strong>proto</strong> === Object.prototype // true<br>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.<strong>proto</strong>指向构造函数（Object）的prototype属性。</p>
<p>第三种特殊情况，子类继承null。</p>
<p>class A extends null {<br>}</p>
<p>A.<strong>proto</strong> === Function.prototype // true<br>A.prototype.<strong>proto</strong> === undefined // true<br>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的<strong>proto</strong>指向Function.prototype，即实质上执行了下面的代码。</p>
<p>class C extends null {<br>  constructor() { return Object.create(null); }<br>}<br>Object.getPrototypeOf()<br>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<p>Object.getPrototypeOf(ColorPoint) === Point<br>// true<br>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<p>super 关键字<br>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
<p>class A {<br>  constructor() {<br>    console.log(new.target.name);<br>  }<br>}<br>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>new A() // A<br>new B() // B<br>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</p>
<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  m() {<br>    super(); // 报错<br>  }<br>}<br>上面代码中，super()用在B类的m方法之中，就会造成句法错误。</p>
<p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<p>class A {<br>  p() {<br>    return 2;<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.p()); // 2<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</p>
<p>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>
<p>class A {<br>  constructor() {<br>    this.p = 2;<br>  }<br>}</p>
<p>class B extends A {<br>  get m() {<br>    return super.p;<br>  }<br>}</p>
<p>let b = new B();<br>b.m // undefined<br>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，super就可以取到。</p>
<p>class A {}<br>A.prototype.x = 2;</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.x) // 2<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。</p>
<p>ES6 规定，通过super调用父类的方法时，super会绑定子类的this。</p>
<p>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>  print() {<br>    console.log(this.x);<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>  }<br>  m() {<br>    super.print();<br>  }<br>}</p>
<p>let b = new B();<br>b.m() // 2<br>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</p>
<p>由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>
<p>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>    super.x = 3;<br>    console.log(super.x); // undefined<br>    console.log(this.x); // 3<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p>
<p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>
<p>class Parent {<br>  static myMethod(msg) {<br>    console.log(‘static’, msg);<br>  }</p>
<p>  myMethod(msg) {<br>    console.log(‘instance’, msg);<br>  }<br>}</p>
<p>class Child extends Parent {<br>  static myMethod(msg) {<br>    super.myMethod(msg);<br>  }</p>
<p>  myMethod(msg) {<br>    super.myMethod(msg);<br>  }<br>}</p>
<p>Child.myMethod(1); // static 1</p>
<p>var child = new Child();<br>child.myMethod(2); // instance 2<br>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super); // 报错<br>  }<br>}<br>上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.valueOf() instanceof B); // true<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
<p>var obj = {<br>  toString() {<br>    return “MyObject: “ + super.toString();<br>  }<br>};</p>
<p>obj.toString(); // MyObject: [object Object]<br>实例的<strong>proto</strong>属性<br>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<p>var p1 = new Point(2, 3);<br>var p2 = new ColorPoint(2, 3, ‘red’);</p>
<p>p2.<strong>proto</strong> === p1.<strong>proto</strong> // false<br>p2.<strong>proto</strong>.<strong>proto</strong> === p1.<strong>proto</strong> // true<br>上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。</p>
<p>p2.<strong>proto</strong>.<strong>proto</strong>.printName = function () {<br>  console.log(‘Ha’);<br>};</p>
<p>p1.printName() // “Ha”<br>上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</p>
<p>原生构造函数的继承<br>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p>
<p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()<br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。</p>
<p>function MyArray() {<br>  Array.apply(this, arguments);<br>}</p>
<p>MyArray.prototype = Object.create(Array.prototype, {<br>  constructor: {<br>    value: MyArray,<br>    writable: true,<br>    configurable: true,<br>    enumerable: true<br>  }<br>});<br>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p>
<p>var colors = new MyArray();<br>colors[0] = “red”;<br>colors.length  // 0</p>
<p>colors.length = 0;<br>colors[0]  // “red”<br>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>
<p>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承Error对象。</p>
<p>var e = {};</p>
<p>Object.getOwnPropertyNames(Error.call(e))<br>// [ ‘stack’ ]</p>
<p>Object.getOwnPropertyNames(e)<br>// []<br>上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<p>class MyArray extends Array {<br>  constructor(…args) {<br>    super(…args);<br>  }<br>}</p>
<p>var arr = new MyArray();<br>arr[0] = 12;<br>arr.length // 1</p>
<p>arr.length = 0;<br>arr[0] // undefined<br>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p>
<p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<p>class VersionedArray extends Array {<br>  constructor() {<br>    super();<br>    this.history = [[]];<br>  }<br>  commit() {<br>    this.history.push(this.slice());<br>  }<br>  revert() {<br>    this.splice(0, this.length, …this.history[this.history.length - 1]);<br>  }<br>}</p>
<p>var x = new VersionedArray();</p>
<p>x.push(1);<br>x.push(2);<br>x // [1, 2]<br>x.history // [[]]</p>
<p>x.commit();<br>x.history // [[], [1, 2]]<br>x.push(3);<br>x // [1, 2, 3]</p>
<p>x.revert();<br>x // [1, 2]<br>上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义Error子类的例子。</p>
<p>class ExtendableError extends Error {<br>  constructor(message) {<br>    super();<br>    this.message = message;<br>    this.stack = (new Error()).stack;<br>    this.name = this.constructor.name;<br>  }<br>}</p>
<p>class MyError extends ExtendableError {<br>  constructor(m) {<br>    super(m);<br>  }<br>}</p>
<p>var myerror = new MyError(‘ll’);<br>myerror.message // “ll”<br>myerror instanceof Error // true<br>myerror.name // “MyError”<br>myerror.stack<br>// Error<br>//     at MyError.ExtendableError<br>//     …<br>注意，继承Object的子类，有一个行为差异。</p>
<p>class NewObj extends Object{<br>  constructor(){<br>    super(…arguments);<br>  }<br>}<br>var o = new NewObj({attr: true});<br>console.log(o.attr === true);  // false<br>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。</p>
<p>Class的取值函数（getter）和存值函数（setter）<br>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<p>class MyClass {<br>  constructor() {<br>    // …<br>  }<br>  get prop() {<br>    return ‘getter’;<br>  }<br>  set prop(value) {<br>    console.log(‘setter: ‘+value);<br>  }<br>}</p>
<p>let inst = new MyClass();</p>
<p>inst.prop = 123;<br>// setter: 123</p>
<p>inst.prop<br>// ‘getter’<br>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>
<p>class CustomHTMLElement {<br>  constructor(element) {<br>    this.element = element;<br>  }</p>
<p>  get html() {<br>    return this.element.innerHTML;<br>  }</p>
<p>  set html(value) {<br>    this.element.innerHTML = value;<br>  }<br>}</p>
<p>var descriptor = Object.getOwnPropertyDescriptor(<br>  CustomHTMLElement.prototype, “html”);<br>“get” in descriptor  // true<br>“set” in descriptor  // true<br>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>
<p>Class 的 Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<p>class Foo {<br>  constructor(…args) {<br>    this.args = args;<br>  }</p>
<ul>
<li><a href="">Symbol.iterator</a> {<br>for (let arg of this.args) {<br>  yield arg;<br>}<br>}<br>}</li>
</ul>
<p>for (let x of new Foo(‘hello’, ‘world’)) {<br>  console.log(x);<br>}<br>// hello<br>// world<br>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。</p>
<p>Class 的静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>Foo.classMethod() // ‘hello’</p>
<p>var foo = new Foo();<br>foo.classMethod()<br>// TypeError: foo.classMethod is not a function<br>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>父类的静态方法，可以被子类继承。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>class Bar extends Foo {<br>}</p>
<p>Bar.classMethod(); // ‘hello’<br>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p>
<p>静态方法也是可以从super对象上调用的。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>class Bar extends Foo {<br>  static classMethod() {<br>    return super.classMethod() + ‘, too’;<br>  }<br>}</p>
<p>Bar.classMethod();<br>Class的静态属性和实例属性<br>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<p>class Foo {<br>}</p>
<p>Foo.prop = 1;<br>Foo.prop // 1<br>上面的写法为Foo类定义了一个静态属性prop。</p>
<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<p>// 以下两种写法都无效<br>class Foo {<br>  // 写法一<br>  prop: 2</p>
<p>  // 写法二<br>  static prop: 2<br>}</p>
<p>Foo.prop // undefined<br>ES7有一个静态属性的提案，目前Babel转码器支持。</p>
<p>这个提案对实例属性和静态属性，都规定了新的写法。</p>
<p>（1）类的实例属性</p>
<p>类的实例属性可以用等式，写入类的定义之中。</p>
<p>class MyClass {<br>  myProp = 42;</p>
<p>  constructor() {<br>    console.log(this.myProp); // 42<br>  }<br>}<br>上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。</p>
<p>以前，我们定义实例属性，只能写在类的constructor方法里面。</p>
<p>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>}<br>上面代码中，构造方法constructor里面，定义了this.state属性。</p>
<p>有了新的写法以后，可以不在constructor方法里面定义。</p>
<p>class ReactCounter extends React.Component {<br>  state = {<br>    count: 0<br>  };<br>}<br>这种写法比以前更清晰。</p>
<p>为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</p>
<p>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>  state;<br>}<br>（2）类的静态属性</p>
<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>
<p>class MyClass {<br>  static myStaticProp = 42;</p>
<p>  constructor() {<br>    console.log(MyClass.myStaticProp); // 42<br>  }<br>}<br>同样的，这个新写法大大方便了静态属性的表达。</p>
<p>// 老写法<br>class Foo {<br>}<br>Foo.prop = 1;</p>
<p>// 新写法<br>class Foo {<br>  static prop = 1;<br>}<br>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<p>类的私有属性<br>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。</p>
<p>class Point {</p>
<p>  #x;</p>
<p>  constructor(x = 0) {</p>
<pre><code>#x = +x;
</code></pre><p>  }</p>
<p>  get x() { return #x }<br>  set x(value) { #x = +value }<br>}<br>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p>
<p>私有属性可以指定初始值，在构造函数执行时进行初始化。</p>
<p>class Point {</p>
<p>  #x = 0;<br>  constructor() {</p>
<pre><code>#x; // 0
</code></pre><p>  }<br>}<br>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。</p>
<p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。</p>
<p>class Foo {</p>
<p>  #a;</p>
<p>  #b;</p>
<p>  #sum() { return #a + #b; }<br>  printSum() { console.log(#sum()); }<br>  constructor(a, b) { #a = a; #b = b; }<br>}<br>new.target属性<br>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<p>function Person(name) {<br>  if (new.target !== undefined) {<br>    this.name = name;<br>  } else {<br>    throw new Error(‘必须使用new生成实例’);<br>  }<br>}</p>
<p>// 另一种写法<br>function Person(name) {<br>  if (new.target === Person) {<br>    this.name = name;<br>  } else {<br>    throw new Error(‘必须使用new生成实例’);<br>  }<br>}</p>
<p>var person = new Person(‘张三’); // 正确<br>var notAPerson = Person.call(person, ‘张三’);  // 报错<br>上面代码确保构造函数只能通过new命令调用。</p>
<p>Class内部调用new.target，返回当前Class。</p>
<p>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    this.length = length;<br>    this.width = width;<br>  }<br>}</p>
<p>var obj = new Rectangle(3, 4); // 输出 true<br>需要注意的是，子类继承父类时，new.target会返回子类。</p>
<p>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    // …<br>  }<br>}</p>
<p>class Square extends Rectangle {<br>  constructor(length) {<br>    super(length, length);<br>  }<br>}</p>
<p>var obj = new Square(3); // 输出 false<br>上面代码中，new.target会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<p>class Shape {<br>  constructor() {<br>    if (new.target === Shape) {<br>      throw new Error(‘本类不能实例化’);<br>    }<br>  }<br>}</p>
<p>class Rectangle extends Shape {<br>  constructor(length, width) {<br>    super();<br>    // …<br>  }<br>}</p>
<p>var x = new Shape();  // 报错<br>var y = new Rectangle(3, 4);  // 正确<br>上面代码中，Shape类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用new.target会报错。</p>
<p>Mixin模式的实现<br>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p>
<p>function mix(…mixins) {<br>  class Mix {}</p>
<p>  for (let mixin of mixins) {<br>    copyProperties(Mix, mixin);<br>    copyProperties(Mix.prototype, mixin.prototype);<br>  }</p>
<p>  return Mix;<br>}</p>
<p>function copyProperties(target, source) {<br>  for (let key of Reflect.ownKeys(source)) {<br>    if ( key !== “constructor”<br>      &amp;&amp; key !== “prototype”<br>      &amp;&amp; key !== “name”<br>    ) {<br>      let desc = Object.getOwnPropertyDescriptor(source, key);<br>      Object.defineProperty(target, key, desc);<br>    }<br>  }<br>}<br>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<p>class DistributedEdit extends mix(Loggable, Serializable) {<br>  // …<br>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####ECMAScript 6简介&lt;/p&gt;
&lt;p&gt;###1.Class基本语法&lt;/p&gt;
&lt;p&gt;##概述&lt;br&gt;JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Point.prototype.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;(&#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&#39;, &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&#39;)&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。&lt;/p&gt;
&lt;p&gt;ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>yilia配置</title>
    <link href="http://yoursite.com/2017/04/11/yilia%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/04/11/yilia配置/</id>
    <published>2017-04-11T02:41:53.000Z</published>
    <updated>2017-05-16T03:23:52.809Z</updated>
    
    <content type="html"><![CDATA[<p>主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>menu:<br>  主页: /<br>  随笔: /tags/随笔/</p>
<h1 id="SubNav"><a href="#SubNav" class="headerlink" title="SubNav"></a>SubNav</h1><p>subnav:<br>  github: “#”<br>  weibo: “#”<br>  rss: “#”<a id="more"></a><br>  zhihu: “#”</p>
<p>  #qq: “#”</p>
<p>  #weixin: “#”</p>
<p>  #jianshu: “#”</p>
<p>  #douban: “#”</p>
<p>  #segmentfault: “#”</p>
<p>  #bilibili: “#”</p>
<p>  #acfun: “#”</p>
<p>  #mail: “mailto:litten225@qq.com”</p>
<p>  #facebook: “#”</p>
<p>  #google: “#”</p>
<p>  #twitter: “#”</p>
<p>  #linkedin: “#”</p>
<p>rss: /atom.xml</p>
<h1 id="是否需要修改-root-路径"><a href="#是否需要修改-root-路径" class="headerlink" title="是否需要修改 root 路径"></a>是否需要修改 root 路径</h1><h1 id="如果您的网站存放在子目录中，例如-http-yoursite-com-blog，"><a href="#如果您的网站存放在子目录中，例如-http-yoursite-com-blog，" class="headerlink" title="如果您的网站存放在子目录中，例如 http://yoursite.com/blog，"></a>如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，">http://yoursite.com/blog，</a></h1><h1 id="请将您的-url-设为-http-yoursite-com-blog-并把-root-设为-blog-。"><a href="#请将您的-url-设为-http-yoursite-com-blog-并把-root-设为-blog-。" class="headerlink" title="请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。"></a>请将您的 url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</h1><p>root: </p>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h1 id="文章太长，截断按钮文字"><a href="#文章太长，截断按钮文字" class="headerlink" title="文章太长，截断按钮文字"></a>文章太长，截断按钮文字</h1><p>excerpt_link: more</p>
<h1 id="文章卡片右下角常驻链接，不需要请设置为false"><a href="#文章卡片右下角常驻链接，不需要请设置为false" class="headerlink" title="文章卡片右下角常驻链接，不需要请设置为false"></a>文章卡片右下角常驻链接，不需要请设置为false</h1><p>show_all_link: ‘展开全文’</p>
<h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>mathjax: false</p>
<h1 id="是否在新窗口打开链接"><a href="#是否在新窗口打开链接" class="headerlink" title="是否在新窗口打开链接"></a>是否在新窗口打开链接</h1><p>open_in_new: false</p>
<h1 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h1><h1 id="请在需要打赏的文章的md文件头部，设置属性reward-true"><a href="#请在需要打赏的文章的md文件头部，设置属性reward-true" class="headerlink" title="请在需要打赏的文章的md文件头部，设置属性reward: true"></a>请在需要打赏的文章的md文件头部，设置属性reward: true</h1><h1 id="打赏基础设定：0-关闭打赏；-1-文章对应的md文件里有reward-true属性，才有打赏；-2-所有文章均有打赏"><a href="#打赏基础设定：0-关闭打赏；-1-文章对应的md文件里有reward-true属性，才有打赏；-2-所有文章均有打赏" class="headerlink" title="打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏"></a>打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</h1><p>reward_type: 2</p>
<h1 id="打赏wording"><a href="#打赏wording" class="headerlink" title="打赏wording"></a>打赏wording</h1><p>reward_wording: ‘谢谢你请我吃糖果’</p>
<h1 id="支付宝二维码图片地址，跟你设置头像的方式一样。比如：-assets-img-alipay-jpg"><a href="#支付宝二维码图片地址，跟你设置头像的方式一样。比如：-assets-img-alipay-jpg" class="headerlink" title="支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg"></a>支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</h1><p>alipay: </p>
<h1 id="微信二维码图片地址"><a href="#微信二维码图片地址" class="headerlink" title="微信二维码图片地址"></a>微信二维码图片地址</h1><p>weixin: </p>
<h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><p>baidu_analytics: ‘’<br>google_analytics: ‘’<br>favicon: /favicon.png</p>
<p>#你的头像url<br>avatar:</p>
<p>#是否开启分享<br>share_jia: true</p>
<p>#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key</p>
<p>#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论<br>duoshuo: false</p>
<h1 id="样式定制-一般不需要修改，除非有很强的定制欲望…"><a href="#样式定制-一般不需要修改，除非有很强的定制欲望…" class="headerlink" title="样式定制 - 一般不需要修改，除非有很强的定制欲望…"></a>样式定制 - 一般不需要修改，除非有很强的定制欲望…</h1><p>style:</p>
<h1 id="头像上面的背景颜色"><a href="#头像上面的背景颜色" class="headerlink" title="头像上面的背景颜色"></a>头像上面的背景颜色</h1><p>  header: ‘#4d4d4d’</p>
<h1 id="右滑板块背景"><a href="#右滑板块背景" class="headerlink" title="右滑板块背景"></a>右滑板块背景</h1><p>  slider: ‘linear-gradient(200deg,#a0cfe4,#e8c37e)’</p>
<h1 id="slider的设置"><a href="#slider的设置" class="headerlink" title="slider的设置"></a>slider的设置</h1><p>slider:</p>
<h1 id="是否默认展开tags板块"><a href="#是否默认展开tags板块" class="headerlink" title="是否默认展开tags板块"></a>是否默认展开tags板块</h1><p>  showTags: false</p>
<h1 id="智能菜单"><a href="#智能菜单" class="headerlink" title="智能菜单"></a>智能菜单</h1><h1 id="如不需要，将该对应项置为false"><a href="#如不需要，将该对应项置为false" class="headerlink" title="如不需要，将该对应项置为false"></a>如不需要，将该对应项置为false</h1><h1 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h1><p>#smart_menu:</p>
<h1 id="friends-false"><a href="#friends-false" class="headerlink" title="friends: false"></a>friends: false</h1><p>smart_menu:<br>  innerArchive: ‘所有文章’<br>  friends: ‘友链’<br>  aboutme: ‘关于我’</p>
<p>friends:<br>  友情链接1: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接2: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接3: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接4: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接5: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接6: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></p>
<p>aboutme: 很惭愧<br><br>只做了一点微小的工作<br>谢谢大家</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份&lt;/p&gt;
&lt;h1 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; title=&quot;Header&quot;&gt;&lt;/a&gt;Header&lt;/h1&gt;&lt;p&gt;menu:&lt;br&gt;  主页: /&lt;br&gt;  随笔: /tags/随笔/&lt;/p&gt;
&lt;h1 id=&quot;SubNav&quot;&gt;&lt;a href=&quot;#SubNav&quot; class=&quot;headerlink&quot; title=&quot;SubNav&quot;&gt;&lt;/a&gt;SubNav&lt;/h1&gt;&lt;p&gt;subnav:&lt;br&gt;  github: “#”&lt;br&gt;  weibo: “#”&lt;br&gt;  rss: “#”
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一个博客</title>
    <link href="http://yoursite.com/2017/04/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/04/08/我的第一个博客/</id>
    <published>2017-04-08T03:11:41.000Z</published>
    <updated>2017-05-16T03:23:59.532Z</updated>
    
    <content type="html"><![CDATA[<p>您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
