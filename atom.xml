<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jade_Wang</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-16T02:43:10.616Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jade_Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>yilia配置</title>
    <link href="http://yoursite.com/2017/05/16/yilia%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/05/16/yilia配置/</id>
    <published>2017-05-16T02:41:53.000Z</published>
    <updated>2017-05-16T02:43:10.616Z</updated>
    
    <content type="html"><![CDATA[<p>主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>menu:<br>  主页: /<br>  随笔: /tags/随笔/</p>
<h1 id="SubNav"><a href="#SubNav" class="headerlink" title="SubNav"></a>SubNav</h1><p>subnav:<br>  github: “#”<br>  weibo: “#”<br>  rss: “#”<a id="more"></a><br>  zhihu: “#”</p>
<p>  #qq: “#”</p>
<p>  #weixin: “#”</p>
<p>  #jianshu: “#”</p>
<p>  #douban: “#”</p>
<p>  #segmentfault: “#”</p>
<p>  #bilibili: “#”</p>
<p>  #acfun: “#”</p>
<p>  #mail: “mailto:litten225@qq.com”</p>
<p>  #facebook: “#”</p>
<p>  #google: “#”</p>
<p>  #twitter: “#”</p>
<p>  #linkedin: “#”</p>
<p>rss: /atom.xml</p>
<h1 id="是否需要修改-root-路径"><a href="#是否需要修改-root-路径" class="headerlink" title="是否需要修改 root 路径"></a>是否需要修改 root 路径</h1><h1 id="如果您的网站存放在子目录中，例如-http-yoursite-com-blog，"><a href="#如果您的网站存放在子目录中，例如-http-yoursite-com-blog，" class="headerlink" title="如果您的网站存放在子目录中，例如 http://yoursite.com/blog，"></a>如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，">http://yoursite.com/blog，</a></h1><h1 id="请将您的-url-设为-http-yoursite-com-blog-并把-root-设为-blog-。"><a href="#请将您的-url-设为-http-yoursite-com-blog-并把-root-设为-blog-。" class="headerlink" title="请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。"></a>请将您的 url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</h1><p>root: </p>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h1 id="文章太长，截断按钮文字"><a href="#文章太长，截断按钮文字" class="headerlink" title="文章太长，截断按钮文字"></a>文章太长，截断按钮文字</h1><p>excerpt_link: more</p>
<h1 id="文章卡片右下角常驻链接，不需要请设置为false"><a href="#文章卡片右下角常驻链接，不需要请设置为false" class="headerlink" title="文章卡片右下角常驻链接，不需要请设置为false"></a>文章卡片右下角常驻链接，不需要请设置为false</h1><p>show_all_link: ‘展开全文’</p>
<h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>mathjax: false</p>
<h1 id="是否在新窗口打开链接"><a href="#是否在新窗口打开链接" class="headerlink" title="是否在新窗口打开链接"></a>是否在新窗口打开链接</h1><p>open_in_new: false</p>
<h1 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h1><h1 id="请在需要打赏的文章的md文件头部，设置属性reward-true"><a href="#请在需要打赏的文章的md文件头部，设置属性reward-true" class="headerlink" title="请在需要打赏的文章的md文件头部，设置属性reward: true"></a>请在需要打赏的文章的md文件头部，设置属性reward: true</h1><h1 id="打赏基础设定：0-关闭打赏；-1-文章对应的md文件里有reward-true属性，才有打赏；-2-所有文章均有打赏"><a href="#打赏基础设定：0-关闭打赏；-1-文章对应的md文件里有reward-true属性，才有打赏；-2-所有文章均有打赏" class="headerlink" title="打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏"></a>打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</h1><p>reward_type: 2</p>
<h1 id="打赏wording"><a href="#打赏wording" class="headerlink" title="打赏wording"></a>打赏wording</h1><p>reward_wording: ‘谢谢你请我吃糖果’</p>
<h1 id="支付宝二维码图片地址，跟你设置头像的方式一样。比如：-assets-img-alipay-jpg"><a href="#支付宝二维码图片地址，跟你设置头像的方式一样。比如：-assets-img-alipay-jpg" class="headerlink" title="支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg"></a>支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</h1><p>alipay: </p>
<h1 id="微信二维码图片地址"><a href="#微信二维码图片地址" class="headerlink" title="微信二维码图片地址"></a>微信二维码图片地址</h1><p>weixin: </p>
<h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><p>baidu_analytics: ‘’<br>google_analytics: ‘’<br>favicon: /favicon.png</p>
<p>#你的头像url<br>avatar:</p>
<p>#是否开启分享<br>share_jia: true</p>
<p>#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key</p>
<p>#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论<br>duoshuo: false</p>
<h1 id="样式定制-一般不需要修改，除非有很强的定制欲望…"><a href="#样式定制-一般不需要修改，除非有很强的定制欲望…" class="headerlink" title="样式定制 - 一般不需要修改，除非有很强的定制欲望…"></a>样式定制 - 一般不需要修改，除非有很强的定制欲望…</h1><p>style:</p>
<h1 id="头像上面的背景颜色"><a href="#头像上面的背景颜色" class="headerlink" title="头像上面的背景颜色"></a>头像上面的背景颜色</h1><p>  header: ‘#4d4d4d’</p>
<h1 id="右滑板块背景"><a href="#右滑板块背景" class="headerlink" title="右滑板块背景"></a>右滑板块背景</h1><p>  slider: ‘linear-gradient(200deg,#a0cfe4,#e8c37e)’</p>
<h1 id="slider的设置"><a href="#slider的设置" class="headerlink" title="slider的设置"></a>slider的设置</h1><p>slider:</p>
<h1 id="是否默认展开tags板块"><a href="#是否默认展开tags板块" class="headerlink" title="是否默认展开tags板块"></a>是否默认展开tags板块</h1><p>  showTags: false</p>
<h1 id="智能菜单"><a href="#智能菜单" class="headerlink" title="智能菜单"></a>智能菜单</h1><h1 id="如不需要，将该对应项置为false"><a href="#如不需要，将该对应项置为false" class="headerlink" title="如不需要，将该对应项置为false"></a>如不需要，将该对应项置为false</h1><h1 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h1><p>#smart_menu:</p>
<h1 id="friends-false"><a href="#friends-false" class="headerlink" title="friends: false"></a>friends: false</h1><p>smart_menu:<br>  innerArchive: ‘所有文章’<br>  friends: ‘友链’<br>  aboutme: ‘关于我’</p>
<p>friends:<br>  友情链接1: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接2: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接3: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接4: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接5: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接6: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></p>
<p>aboutme: 很惭愧<br><br>只做了一点微小的工作<br>谢谢大家</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份&lt;/p&gt;
&lt;h1 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; title=&quot;Header&quot;&gt;&lt;/a&gt;Header&lt;/h1&gt;&lt;p&gt;menu:&lt;br&gt;  主页: /&lt;br&gt;  随笔: /tags/随笔/&lt;/p&gt;
&lt;h1 id=&quot;SubNav&quot;&gt;&lt;a href=&quot;#SubNav&quot; class=&quot;headerlink&quot; title=&quot;SubNav&quot;&gt;&lt;/a&gt;SubNav&lt;/h1&gt;&lt;p&gt;subnav:&lt;br&gt;  github: “#”&lt;br&gt;  weibo: “#”&lt;br&gt;  rss: “#”
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Es6新特性</title>
    <link href="http://yoursite.com/2017/05/08/Es6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/05/08/Es6新特性/</id>
    <published>2017-05-08T07:36:32.000Z</published>
    <updated>2017-05-16T02:26:26.842Z</updated>
    
    <content type="html"><![CDATA[<p>####ECMAScript 6简介</p>
<p>###1.Class基本语法</p>
<p>##概述<br>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x;</div><div class="line">  <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。</p>
<p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6的类，完全可以看作构造函数的另一种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></div><div class="line">Point === Point.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">  doStuff() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar();</div><div class="line">b.doStuff() <span class="comment">// "stuff"</span></div></pre></td></tr></table></figure></p>
<p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toValue()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">Point.prototype = &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div><div class="line"></div><div class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;);</div><div class="line">prototype对象的<span class="keyword">constructor</span>属性，直接指向“类”的本身，这与ES5的行为是一致的。</div><div class="line"></div><div class="line">Point.prototype.<span class="keyword">constructor</span> === Point // true</div></pre></td></tr></table></figure></p>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<p>class Point {<br>  constructor(x, y) {<br>    // …<br>  }</p>
<p>  toString() {<br>    // …<br>  }<br>}</p>
<p>Object.keys(Point.prototype)<br>// []<br>Object.getOwnPropertyNames(Point.prototype)<br>// [“constructor”,”toString”]</p>
<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>
<p>var Point = function (x, y) {<br>  // …<br>};</p>
<p>Point.prototype.toString = function() {<br>  // …<br>};</p>
<p>Object.keys(Point.prototype)<br>// [“toString”]<br>Object.getOwnPropertyNames(Point.prototype)<br>// [“constructor”,”toString”]</p>
<p>上面代码采用ES5的写法，toString方法就是可枚举的。</p>
<p>类的属性名，可以采用表达式。</p>
<p>let methodName = “getArea”;<br>class Square{<br>  constructor(length) {<br>    // …<br>  }</p>
<p>  <a href="">methodName</a> {<br>    // …<br>  }<br>}</p>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<p>constructor方法<br>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<p>constructor() {}<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<p>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}</p>
<p>new Foo() instanceof Foo<br>// false</p>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<p>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}</p>
<p>Foo()<br>// TypeError: Class constructor Foo cannot be invoked without ‘new’</p>
<p>类的实例对象<br>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p>
<p>// 报错<br>var point = Point(2, 3);</p>
<p>// 正确<br>var point = new Point(2, 3);</p>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<p>//定义类<br>class Point {</p>
<p>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }</p>
<p>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }</p>
<p>}</p>
<p>var point = new Point(2, 3);</p>
<p>point.toString() // (2, 3)</p>
<p>point.hasOwnProperty(‘x’) // true<br>point.hasOwnProperty(‘y’) // true<br>point.hasOwnProperty(‘toString’) // false<br>point.<strong>proto</strong>.hasOwnProperty(‘toString’) // true</p>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。</p>
<p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p>
<p>p1.<strong>proto</strong> === p2.<strong>proto</strong><br>//true</p>
<p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以<strong>proto</strong>属性是相等的。</p>
<p>这也意味着，可以通过实例的<strong>proto</strong>属性为Class添加方法。</p>
<p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p>
<p>p1.<strong>proto</strong>.printName = function () { return ‘Oops’ };</p>
<p>p1.printName() // “Oops”<br>p2.printName() // “Oops”</p>
<p>var p3 = new Point(4,2);<br>p3.printName() // “Oops”</p>
<p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的<strong>proto</strong>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p>
<p>不存在变量提升<br>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<p>new Foo(); // ReferenceError<br>class Foo {}<br>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p>{<br>  let Foo = class {};<br>  class Bar extends Foo {<br>  }<br>}<br>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p>
<p>Class表达式<br>与函数一样，类也可以使用表达式的形式定义。</p>
<p>const MyClass = class Me {<br>  getClassName() {<br>    return Me.name;<br>  }<br>};<br>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<p>let inst = new MyClass();<br>inst.getClassName() // Me<br>Me.name // ReferenceError: Me is not defined<br>上面代码表示，Me只在Class内部有定义。</p>
<p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p>
<p>const MyClass = class { /<em> … </em>/ };<br>采用Class表达式，可以写出立即执行的Class。</p>
<p>let person = new class {<br>  constructor(name) {<br>    this.name = name;<br>  }</p>
<p>  sayName() {<br>    console.log(this.name);<br>  }<br>}(‘张三’);</p>
<p>person.sayName(); // “张三”<br>上面代码中，person是一个立即执行的类的实例。</p>
<p>私有方法<br>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<p>class Widget {</p>
<p>  // 公有方法<br>  foo (baz) {<br>    this._bar(baz);<br>  }</p>
<p>  // 私有方法<br>  _bar(baz) {<br>    return this.snaf = baz;<br>  }</p>
<p>  // …<br>}<br>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<p>class Widget {<br>  foo (baz) {<br>    bar.call(this, baz);<br>  }</p>
<p>  // …<br>}</p>
<p>function bar(baz) {<br>  return this.snaf = baz;<br>}<br>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</p>
<p>const bar = Symbol(‘bar’);<br>const snaf = Symbol(‘snaf’);</p>
<p>export default class myClass{</p>
<p>  // 公有方法<br>  foo(baz) {<br>    this<a href="baz">bar</a>;<br>  }</p>
<p>  // 私有方法<br>  <a href="baz">bar</a> {<br>    return this[snaf] = baz;<br>  }</p>
<p>  // …<br>};<br>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<p>this的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<p>class Logger {<br>  printName(name = ‘there’) {<br>    this.print(<code>Hello ${name}</code>);<br>  }</p>
<p>  print(text) {<br>    console.log(text);<br>  }<br>}</p>
<p>const logger = new Logger();<br>const { printName } = logger;<br>printName(); // TypeError: Cannot read property ‘print’ of undefined<br>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p>
<p>class Logger {<br>  constructor() {<br>    this.printName = this.printName.bind(this);<br>  }</p>
<p>  // …<br>}<br>另一种解决方法是使用箭头函数。</p>
<p>class Logger {<br>  constructor() {<br>    this.printName = (name = ‘there’) =&gt; {<br>      this.print(<code>Hello ${name}</code>);<br>    };<br>  }</p>
<p>  // …<br>}<br>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p>
<p>function selfish (target) {<br>  const cache = new WeakMap();<br>  const handler = {<br>    get (target, key) {<br>      const value = Reflect.get(target, key);<br>      if (typeof value !== ‘function’) {<br>        return value;<br>      }<br>      if (!cache.has(value)) {<br>        cache.set(value, value.bind(target));<br>      }<br>      return cache.get(value);<br>    }<br>  };<br>  const proxy = new Proxy(target, handler);<br>  return proxy;<br>}</p>
<p>const logger = selfish(new Logger());<br>严格模式<br>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<p>name属性<br>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<p>class Point {}<br>Point.name // “Point”<br>name属性总是返回紧跟在class关键字后面的类名。</p>
<p>Class的继承<br>基本用法<br>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<p>class ColorPoint extends Point {}<br>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p>
<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); // 调用父类的constructor(x, y)<br>    this.color = color;<br>  }</p>
<p>  toString() {<br>    return this.color + ‘ ‘ + super.toString(); // 调用父类的toString()<br>  }<br>}<br>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>class Point { /<em> … </em>/ }</p>
<p>class ColorPoint extends Point {<br>  constructor() {<br>  }<br>}</p>
<p>let cp = new ColorPoint(); // ReferenceError<br>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</p>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<p>constructor(…args) {<br>  super(…args);<br>}<br>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<p>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>}</p>
<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    this.color = color; // ReferenceError<br>    super(x, y);<br>    this.color = color; // 正确<br>  }<br>}<br>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p>
<p>下面是生成子类实例的代码。</p>
<p>let cp = new ColorPoint(25, 8, ‘green’);</p>
<p>cp instanceof ColorPoint // true<br>cp instanceof Point // true<br>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p>
<p>类的prototype属性和<strong>proto</strong>属性<br>大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</p>
<p>class A {<br>}</p>
<p>class B extends A {<br>}</p>
<p>B.<strong>proto</strong> === A // true<br>B.prototype.<strong>proto</strong> === A.prototype // true<br>上面代码中，子类B的<strong>proto</strong>属性指向父类A，子类B的prototype属性的<strong>proto</strong>属性指向父类A的prototype属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<p>class A {<br>}</p>
<p>class B {<br>}</p>
<p>// B的实例继承A的实例<br>Object.setPrototypeOf(B.prototype, A.prototype);<br>const b = new B();</p>
<p>// B的实例继承A的静态属性<br>Object.setPrototypeOf(B, A);<br>const b = new B();<br>《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。</p>
<p>Object.setPrototypeOf = function (obj, proto) {<br>  obj.<strong>proto</strong> = proto;<br>  return obj;<br>}<br>因此，就得到了上面的结果。</p>
<p>Object.setPrototypeOf(B.prototype, A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;</p>
<p>Object.setPrototypeOf(B, A);<br>// 等同于<br>B.<strong>proto</strong> = A;<br>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</p>
<p>Object.create(A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;<br>Extends 的继承目标<br>extends关键字后面可以跟多种类型的值。</p>
<p>class B extends A {<br>}<br>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</p>
<p>下面，讨论三种特殊情况。</p>
<p>第一种特殊情况，子类继承Object类。</p>
<p>class A extends Object {<br>}</p>
<p>A.<strong>proto</strong> === Object // true<br>A.prototype.<strong>proto</strong> === Object.prototype // true<br>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p>
<p>第二种特殊情况，不存在任何继承。</p>
<p>class A {<br>}</p>
<p>A.<strong>proto</strong> === Function.prototype // true<br>A.prototype.<strong>proto</strong> === Object.prototype // true<br>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.<strong>proto</strong>指向构造函数（Object）的prototype属性。</p>
<p>第三种特殊情况，子类继承null。</p>
<p>class A extends null {<br>}</p>
<p>A.<strong>proto</strong> === Function.prototype // true<br>A.prototype.<strong>proto</strong> === undefined // true<br>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的<strong>proto</strong>指向Function.prototype，即实质上执行了下面的代码。</p>
<p>class C extends null {<br>  constructor() { return Object.create(null); }<br>}<br>Object.getPrototypeOf()<br>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<p>Object.getPrototypeOf(ColorPoint) === Point<br>// true<br>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<p>super 关键字<br>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
<p>class A {<br>  constructor() {<br>    console.log(new.target.name);<br>  }<br>}<br>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>new A() // A<br>new B() // B<br>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</p>
<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  m() {<br>    super(); // 报错<br>  }<br>}<br>上面代码中，super()用在B类的m方法之中，就会造成句法错误。</p>
<p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<p>class A {<br>  p() {<br>    return 2;<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.p()); // 2<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</p>
<p>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>
<p>class A {<br>  constructor() {<br>    this.p = 2;<br>  }<br>}</p>
<p>class B extends A {<br>  get m() {<br>    return super.p;<br>  }<br>}</p>
<p>let b = new B();<br>b.m // undefined<br>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，super就可以取到。</p>
<p>class A {}<br>A.prototype.x = 2;</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.x) // 2<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。</p>
<p>ES6 规定，通过super调用父类的方法时，super会绑定子类的this。</p>
<p>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>  print() {<br>    console.log(this.x);<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>  }<br>  m() {<br>    super.print();<br>  }<br>}</p>
<p>let b = new B();<br>b.m() // 2<br>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</p>
<p>由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>
<p>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>    super.x = 3;<br>    console.log(super.x); // undefined<br>    console.log(this.x); // 3<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p>
<p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>
<p>class Parent {<br>  static myMethod(msg) {<br>    console.log(‘static’, msg);<br>  }</p>
<p>  myMethod(msg) {<br>    console.log(‘instance’, msg);<br>  }<br>}</p>
<p>class Child extends Parent {<br>  static myMethod(msg) {<br>    super.myMethod(msg);<br>  }</p>
<p>  myMethod(msg) {<br>    super.myMethod(msg);<br>  }<br>}</p>
<p>Child.myMethod(1); // static 1</p>
<p>var child = new Child();<br>child.myMethod(2); // instance 2<br>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super); // 报错<br>  }<br>}<br>上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.valueOf() instanceof B); // true<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
<p>var obj = {<br>  toString() {<br>    return “MyObject: “ + super.toString();<br>  }<br>};</p>
<p>obj.toString(); // MyObject: [object Object]<br>实例的<strong>proto</strong>属性<br>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<p>var p1 = new Point(2, 3);<br>var p2 = new ColorPoint(2, 3, ‘red’);</p>
<p>p2.<strong>proto</strong> === p1.<strong>proto</strong> // false<br>p2.<strong>proto</strong>.<strong>proto</strong> === p1.<strong>proto</strong> // true<br>上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。</p>
<p>p2.<strong>proto</strong>.<strong>proto</strong>.printName = function () {<br>  console.log(‘Ha’);<br>};</p>
<p>p1.printName() // “Ha”<br>上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</p>
<p>原生构造函数的继承<br>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p>
<p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()<br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。</p>
<p>function MyArray() {<br>  Array.apply(this, arguments);<br>}</p>
<p>MyArray.prototype = Object.create(Array.prototype, {<br>  constructor: {<br>    value: MyArray,<br>    writable: true,<br>    configurable: true,<br>    enumerable: true<br>  }<br>});<br>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p>
<p>var colors = new MyArray();<br>colors[0] = “red”;<br>colors.length  // 0</p>
<p>colors.length = 0;<br>colors[0]  // “red”<br>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>
<p>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承Error对象。</p>
<p>var e = {};</p>
<p>Object.getOwnPropertyNames(Error.call(e))<br>// [ ‘stack’ ]</p>
<p>Object.getOwnPropertyNames(e)<br>// []<br>上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<p>class MyArray extends Array {<br>  constructor(…args) {<br>    super(…args);<br>  }<br>}</p>
<p>var arr = new MyArray();<br>arr[0] = 12;<br>arr.length // 1</p>
<p>arr.length = 0;<br>arr[0] // undefined<br>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p>
<p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<p>class VersionedArray extends Array {<br>  constructor() {<br>    super();<br>    this.history = [[]];<br>  }<br>  commit() {<br>    this.history.push(this.slice());<br>  }<br>  revert() {<br>    this.splice(0, this.length, …this.history[this.history.length - 1]);<br>  }<br>}</p>
<p>var x = new VersionedArray();</p>
<p>x.push(1);<br>x.push(2);<br>x // [1, 2]<br>x.history // [[]]</p>
<p>x.commit();<br>x.history // [[], [1, 2]]<br>x.push(3);<br>x // [1, 2, 3]</p>
<p>x.revert();<br>x // [1, 2]<br>上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义Error子类的例子。</p>
<p>class ExtendableError extends Error {<br>  constructor(message) {<br>    super();<br>    this.message = message;<br>    this.stack = (new Error()).stack;<br>    this.name = this.constructor.name;<br>  }<br>}</p>
<p>class MyError extends ExtendableError {<br>  constructor(m) {<br>    super(m);<br>  }<br>}</p>
<p>var myerror = new MyError(‘ll’);<br>myerror.message // “ll”<br>myerror instanceof Error // true<br>myerror.name // “MyError”<br>myerror.stack<br>// Error<br>//     at MyError.ExtendableError<br>//     …<br>注意，继承Object的子类，有一个行为差异。</p>
<p>class NewObj extends Object{<br>  constructor(){<br>    super(…arguments);<br>  }<br>}<br>var o = new NewObj({attr: true});<br>console.log(o.attr === true);  // false<br>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。</p>
<p>Class的取值函数（getter）和存值函数（setter）<br>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<p>class MyClass {<br>  constructor() {<br>    // …<br>  }<br>  get prop() {<br>    return ‘getter’;<br>  }<br>  set prop(value) {<br>    console.log(‘setter: ‘+value);<br>  }<br>}</p>
<p>let inst = new MyClass();</p>
<p>inst.prop = 123;<br>// setter: 123</p>
<p>inst.prop<br>// ‘getter’<br>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>
<p>class CustomHTMLElement {<br>  constructor(element) {<br>    this.element = element;<br>  }</p>
<p>  get html() {<br>    return this.element.innerHTML;<br>  }</p>
<p>  set html(value) {<br>    this.element.innerHTML = value;<br>  }<br>}</p>
<p>var descriptor = Object.getOwnPropertyDescriptor(<br>  CustomHTMLElement.prototype, “html”);<br>“get” in descriptor  // true<br>“set” in descriptor  // true<br>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>
<p>Class 的 Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<p>class Foo {<br>  constructor(…args) {<br>    this.args = args;<br>  }</p>
<ul>
<li><a href="">Symbol.iterator</a> {<br>for (let arg of this.args) {<br>  yield arg;<br>}<br>}<br>}</li>
</ul>
<p>for (let x of new Foo(‘hello’, ‘world’)) {<br>  console.log(x);<br>}<br>// hello<br>// world<br>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。</p>
<p>Class 的静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>Foo.classMethod() // ‘hello’</p>
<p>var foo = new Foo();<br>foo.classMethod()<br>// TypeError: foo.classMethod is not a function<br>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>父类的静态方法，可以被子类继承。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>class Bar extends Foo {<br>}</p>
<p>Bar.classMethod(); // ‘hello’<br>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p>
<p>静态方法也是可以从super对象上调用的。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>class Bar extends Foo {<br>  static classMethod() {<br>    return super.classMethod() + ‘, too’;<br>  }<br>}</p>
<p>Bar.classMethod();<br>Class的静态属性和实例属性<br>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<p>class Foo {<br>}</p>
<p>Foo.prop = 1;<br>Foo.prop // 1<br>上面的写法为Foo类定义了一个静态属性prop。</p>
<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<p>// 以下两种写法都无效<br>class Foo {<br>  // 写法一<br>  prop: 2</p>
<p>  // 写法二<br>  static prop: 2<br>}</p>
<p>Foo.prop // undefined<br>ES7有一个静态属性的提案，目前Babel转码器支持。</p>
<p>这个提案对实例属性和静态属性，都规定了新的写法。</p>
<p>（1）类的实例属性</p>
<p>类的实例属性可以用等式，写入类的定义之中。</p>
<p>class MyClass {<br>  myProp = 42;</p>
<p>  constructor() {<br>    console.log(this.myProp); // 42<br>  }<br>}<br>上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。</p>
<p>以前，我们定义实例属性，只能写在类的constructor方法里面。</p>
<p>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>}<br>上面代码中，构造方法constructor里面，定义了this.state属性。</p>
<p>有了新的写法以后，可以不在constructor方法里面定义。</p>
<p>class ReactCounter extends React.Component {<br>  state = {<br>    count: 0<br>  };<br>}<br>这种写法比以前更清晰。</p>
<p>为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</p>
<p>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>  state;<br>}<br>（2）类的静态属性</p>
<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>
<p>class MyClass {<br>  static myStaticProp = 42;</p>
<p>  constructor() {<br>    console.log(MyClass.myStaticProp); // 42<br>  }<br>}<br>同样的，这个新写法大大方便了静态属性的表达。</p>
<p>// 老写法<br>class Foo {<br>}<br>Foo.prop = 1;</p>
<p>// 新写法<br>class Foo {<br>  static prop = 1;<br>}<br>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<p>类的私有属性<br>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。</p>
<p>class Point {</p>
<p>  #x;</p>
<p>  constructor(x = 0) {</p>
<pre><code>#x = +x;
</code></pre><p>  }</p>
<p>  get x() { return #x }<br>  set x(value) { #x = +value }<br>}<br>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p>
<p>私有属性可以指定初始值，在构造函数执行时进行初始化。</p>
<p>class Point {</p>
<p>  #x = 0;<br>  constructor() {</p>
<pre><code>#x; // 0
</code></pre><p>  }<br>}<br>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。</p>
<p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。</p>
<p>class Foo {</p>
<p>  #a;</p>
<p>  #b;</p>
<p>  #sum() { return #a + #b; }<br>  printSum() { console.log(#sum()); }<br>  constructor(a, b) { #a = a; #b = b; }<br>}<br>new.target属性<br>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<p>function Person(name) {<br>  if (new.target !== undefined) {<br>    this.name = name;<br>  } else {<br>    throw new Error(‘必须使用new生成实例’);<br>  }<br>}</p>
<p>// 另一种写法<br>function Person(name) {<br>  if (new.target === Person) {<br>    this.name = name;<br>  } else {<br>    throw new Error(‘必须使用new生成实例’);<br>  }<br>}</p>
<p>var person = new Person(‘张三’); // 正确<br>var notAPerson = Person.call(person, ‘张三’);  // 报错<br>上面代码确保构造函数只能通过new命令调用。</p>
<p>Class内部调用new.target，返回当前Class。</p>
<p>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    this.length = length;<br>    this.width = width;<br>  }<br>}</p>
<p>var obj = new Rectangle(3, 4); // 输出 true<br>需要注意的是，子类继承父类时，new.target会返回子类。</p>
<p>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    // …<br>  }<br>}</p>
<p>class Square extends Rectangle {<br>  constructor(length) {<br>    super(length, length);<br>  }<br>}</p>
<p>var obj = new Square(3); // 输出 false<br>上面代码中，new.target会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<p>class Shape {<br>  constructor() {<br>    if (new.target === Shape) {<br>      throw new Error(‘本类不能实例化’);<br>    }<br>  }<br>}</p>
<p>class Rectangle extends Shape {<br>  constructor(length, width) {<br>    super();<br>    // …<br>  }<br>}</p>
<p>var x = new Shape();  // 报错<br>var y = new Rectangle(3, 4);  // 正确<br>上面代码中，Shape类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用new.target会报错。</p>
<p>Mixin模式的实现<br>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p>
<p>function mix(…mixins) {<br>  class Mix {}</p>
<p>  for (let mixin of mixins) {<br>    copyProperties(Mix, mixin);<br>    copyProperties(Mix.prototype, mixin.prototype);<br>  }</p>
<p>  return Mix;<br>}</p>
<p>function copyProperties(target, source) {<br>  for (let key of Reflect.ownKeys(source)) {<br>    if ( key !== “constructor”<br>      &amp;&amp; key !== “prototype”<br>      &amp;&amp; key !== “name”<br>    ) {<br>      let desc = Object.getOwnPropertyDescriptor(source, key);<br>      Object.defineProperty(target, key, desc);<br>    }<br>  }<br>}<br>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<p>class DistributedEdit extends mix(Loggable, Serializable) {<br>  // …<br>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####ECMAScript 6简介&lt;/p&gt;
&lt;p&gt;###1.Class基本语法&lt;/p&gt;
&lt;p&gt;##概述&lt;br&gt;JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Point.prototype.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;(&#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&#39;, &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&#39;)&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。&lt;/p&gt;
&lt;p&gt;ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一个博客</title>
    <link href="http://yoursite.com/2017/05/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/05/08/我的第一个博客/</id>
    <published>2017-05-08T03:11:41.000Z</published>
    <updated>2017-05-08T03:13:07.007Z</updated>
    
    <content type="html"><![CDATA[<p>您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/05/08/hello-world/"/>
    <id>http://yoursite.com/2017/05/08/hello-world/</id>
    <published>2017-05-08T02:18:40.242Z</published>
    <updated>2017-05-08T02:18:40.243Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
