<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jade_Wang</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-08T02:18:40.243Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jade_Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/05/08/hello-world/"/>
    <id>http://yoursite.com/2017/05/08/hello-world/</id>
    <published>2017-05-08T02:18:40.242Z</published>
    <updated>2017-05-08T02:18:40.243Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js笔记</title>
    <link href="http://yoursite.com/2017/05/01/vue-js%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/05/01/vue-js笔记/</id>
    <published>2017-05-01T03:29:40.000Z</published>
    <updated>2017-05-16T03:32:59.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每多学一点知识，就少写一行代码。"><a href="#每多学一点知识，就少写一行代码。" class="headerlink" title="每多学一点知识，就少写一行代码。"></a>每多学一点知识，就少写一行代码。</h1><h2 id="1、Vue-js使用vue-resource实现ajax请求"><a href="#1、Vue-js使用vue-resource实现ajax请求" class="headerlink" title="1、Vue.js使用vue-resource实现ajax请求"></a>1、Vue.js使用vue-resource实现ajax请求</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by gequn06 on 2017/3/20.</div><div class="line"> */</div><div class="line">import Vue from 'vue/dist/vue.common.js';</div><div class="line">import VueResource from 'vue-resource';</div><div class="line">Vue.use(VueResource);</div><div class="line">new Vue(&#123;</div><div class="line">    el: '#doctorWrap',</div><div class="line">    data: &#123;</div><div class="line">        someData : null</div><div class="line">    &#125;,</div><div class="line">    created :function () &#123;</div><div class="line">        this.$http.get('/public/js/data.json').then(function(response)&#123;</div><div class="line">            console.log(response)</div><div class="line">            // get body data</div><div class="line">            this.someData = response.body.sites;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、Vue-js引用css"><a href="#2、Vue-js引用css" class="headerlink" title="2、Vue.js引用css"></a>2、Vue.js引用css</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line">  @import '../assets/hello.css';</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="3、过滤器"><a href="#3、过滤器" class="headerlink" title="3、过滤器"></a>3、过滤器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"msg | filterA | filterB"</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">export default &#123;</div><div class="line">  name: 'hello',</div><div class="line">  data () &#123;</div><div class="line">    return &#123;</div><div class="line">      msg: 'thanks'</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  filters: &#123;</div><div class="line">    filterA: function (value) &#123;</div><div class="line">      if (!value) return ''</div><div class="line">      value = value.toString()</div><div class="line">      return value.charAt(0).toUpperCase() + value.slice(1)</div><div class="line">    &#125;,</div><div class="line">    filterB: function (value) &#123;</div><div class="line">      if (!value) return ''</div><div class="line">      value = value.toString();</div><div class="line">      return value.slice(0, 1) + value.charAt(2).toUpperCase() + value.slice(2);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="4、Computed-Properties-and-Watchers"><a href="#4、Computed-Properties-and-Watchers" class="headerlink" title="4、Computed Properties and Watchers"></a>4、Computed Properties and Watchers</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: '#example',</div><div class="line">  data: &#123;</div><div class="line">    message: 'Hello'</div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    // a computed getter</div><div class="line">    reversedMessage: function () &#123;</div><div class="line">      // `this` points to the vm instance</div><div class="line">      return this.message.split('').reverse().join('')</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="5、component-lists-rendered-with-v-for-should-have-explicit-keys"><a href="#5、component-lists-rendered-with-v-for-should-have-explicit-keys" class="headerlink" title="5、component lists rendered with v-for should have explicit keys"></a>5、component lists rendered with v-for should have explicit keys</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">v-for需要绑定:key</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">el-select</span> <span class="attr">v-model</span>=<span class="string">"value"</span> <span class="attr">placeholder</span>=<span class="string">"请选择"</span>  <span class="attr">class</span>=<span class="string">"meeting-duration-select"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">el-option</span></span></div><div class="line">            <span class="attr">v-for</span>=<span class="string">"(item,index) in options"</span></div><div class="line">            <span class="attr">:key</span>=<span class="string">"item.value"</span></div><div class="line">            <span class="attr">:label</span>=<span class="string">"item.label"</span></div><div class="line">            <span class="attr">:value</span>=<span class="string">"item.value"</span>&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">el-option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">el-select</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每多学一点知识，就少写一行代码。&quot;&gt;&lt;a href=&quot;#每多学一点知识，就少写一行代码。&quot; class=&quot;headerlink&quot; title=&quot;每多学一点知识，就少写一行代码。&quot;&gt;&lt;/a&gt;每多学一点知识，就少写一行代码。&lt;/h1&gt;&lt;h2 id=&quot;1、Vue-js使用vue-resource实现ajax请求&quot;&gt;&lt;a href=&quot;#1、Vue-js使用vue-resource实现ajax请求&quot; class=&quot;headerlink&quot; title=&quot;1、Vue.js使用vue-resource实现ajax请求&quot;&gt;&lt;/a&gt;1、Vue.js使用vue-resource实现ajax请求&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * Created by gequn06 on 2017/3/20.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import Vue from &#39;vue/dist/vue.common.js&#39;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import VueResource from &#39;vue-resource&#39;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Vue.use(VueResource);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    el: &#39;#doctorWrap&#39;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    data: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        someData : null&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    created :function () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        this.$http.get(&#39;/public/js/data.json&#39;).then(function(response)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            console.log(response)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            // get body data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            this.someData = response.body.sites;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目中的常见问题题_vue_store</title>
    <link href="http://yoursite.com/2017/04/26/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%A2%98-vue-store/"/>
    <id>http://yoursite.com/2017/04/26/项目中的常见问题题-vue-store/</id>
    <published>2017-04-26T02:47:16.000Z</published>
    <updated>2017-05-16T03:24:17.462Z</updated>
    
    <content type="html"><![CDATA[<p>我会把我做关于模仿微博的这个项目遇到的一些问题公开在这里，遇到不对的地方请指教，发送<a href="https://www.wang1348168417@gmail.com" target="_blank" rel="external">邮件wang1348168417@gmail.com</a>，或者扫我的微信二维码。<br>一个简单的状态管理</p>
<h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源:"></a>单一数据源:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const sourceOfTruth = &#123;&#125;</div><div class="line">const vmA = new Vue(&#123;</div><div class="line">  data: sourceOfTruth</div><div class="line">&#125;)</div><div class="line">const vmB = new Vue(&#123;</div><div class="line">  data: sourceOfTruth</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>每当 sourceOfTruth 发生变化, vmA 和 vmB 都会自动更新它们的视图. 子组件可以通过 this.$root.$data 访问数据. 现在我们有了单一的数据源, 但是调试会很困难. 因为无论何时数据源发生变化都会改变程序, 但是没有任何迹象表明变化发生.<a id="more"></a></p>
<h3 id="store-pattern"><a href="#store-pattern" class="headerlink" title="store pattern"></a>store pattern</h3><p>为了解决上述问题, 我们可以引入 store pattern:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var store = &#123;</div><div class="line">  debug: true,</div><div class="line">  state: &#123;</div><div class="line">    message: 'Hello!'</div><div class="line">  &#125;,</div><div class="line">  setMessageAction (newValue) &#123;</div><div class="line">    this.debug &amp;&amp; console.log('setMessageAction triggered with', newValue)</div><div class="line">    this.state.message = newValue</div><div class="line">  &#125;,</div><div class="line">  clearMessageAction () &#123;</div><div class="line">    this.debug &amp;&amp; console.log('clearMessageAction triggered')</div><div class="line">    this.state.message = 'action B triggered'</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所有的数据改变都发生 store 内. 这种集中的状态管理模式使我们很容易记录变化发生, 如何发生.<br>除了单一的数据源外, 每个 vue 实例或组件也可以有其私有状态:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var vmA = new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    privateState: &#123;&#125;,</div><div class="line">    sharedState: store.state</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">var vmB = new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    privateState: &#123;&#125;,</div><div class="line">    sharedState: store.state</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 如果 Vuex 不是全局的, 那么确保调用 Vue.use(Vuex) 使 Vuex 生效.</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  // 数据源</div><div class="line">  state: &#123;</div><div class="line">    count: 0</div><div class="line">  &#125;,</div><div class="line">  // 数据操作</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 触发数据变化操作</div><div class="line">store.commit('increment')</div><div class="line"></div><div class="line">console.log(store.state.count) // -&gt; 1</div></pre></td></tr></table></figure>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>store 自动注入到子组件中</p>
<p>通常我们通过计算属性来访问 store 中的数据, 这样就能感知到数据发生变化.<br>根组件的 store 属性会注入到其所有的子组件中. (通过 Vue.use(Vuex) 生效)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const Counter = &#123;</div><div class="line">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</div><div class="line">    computed: &#123;</div><div class="line">        count() &#123;</div><div class="line">            // 子组件通过 this.$store 访问父组件的 store</div><div class="line">            return this.$store.state.count</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">    // 父对象中的 store 自动注入到子组件</div><div class="line">    store,</div><div class="line">    componets: &#123;</div><div class="line">        Counter</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>如果 store 中有许多数据需要访问, 每个数据都需要定义一个计算属性会非常麻烦. Vuex 提供了 mapState 来简化计算属性的定义.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import &#123; mapState &#125; from 'vuex'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  computed: mapState(&#123;</div><div class="line">    // es6 箭头函数更加简洁</div><div class="line">    count: state =&gt; state.count,</div><div class="line"></div><div class="line">    // 字符串 'count' 等同于 `state =&gt; state.count`</div><div class="line">    countAlias: 'count',</div><div class="line"></div><div class="line">    // 为了访问组件的 `this`, 必须使用普通的函数</div><div class="line">    // 箭头函数会绑定 `this` 到 `mapState` 的参数这个对象</div><div class="line">    countPlusLocalState (state) &#123;</div><div class="line">      return state.count + this.localCount</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果计算属性和 store 中数据是一一对应的, 可以使用更简单的字符串数组:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">computed: mapState([</div><div class="line">  // map this.count to store.state.count</div><div class="line">  'count'</div><div class="line">])</div></pre></td></tr></table></figure></p>
<h3 id="es6-的扩展操作符"><a href="#es6-的扩展操作符" class="headerlink" title="es6 的扩展操作符"></a>es6 的扩展操作符</h3><p>使用 mapState 返回一个对象, 如果组件还有私有的计算属性, 通常我们可以使用 _.extend({localComputed}, mapState(…)) 这种方式合并对象已得到最终的 computed. 使用 es6 的扩展操作符可以简化:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    localComputed()&#123; /* ... */&#125;,</div><div class="line">    // 通过扩展操作符扩展 computed 对象</div><div class="line">    ...mapState(&#123;</div><div class="line">        // ...</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p>通常计算属性是基于一段 store 数据的代码, 比如过滤一个列表并计数:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodoCount() &#123;</div><div class="line">        return this.$store.state.todos.filter(todo =&gt; todo.done).length</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们需要复用这段代码, 基本就是重构提取出一个函数, 但是这样还不是很理想.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Vuex 在 store 中提供了 getters:</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    todos: [</div><div class="line">      &#123; id: 1, text: '...', done: true &#125;,</div><div class="line">      &#123; id: 2, text: '...', done: false &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    doneTodos: state =&gt; &#123;</div><div class="line">      return state.todos.filter(todo =&gt; todo.done)</div><div class="line">    &#125;,</div><div class="line">    doneTodosCount: (state, getters) =&gt; &#123;</div><div class="line">        return getters.doneTodos.length</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 通过 `store.getters` 访问</div><div class="line">store.getters.doneTodosCount</div></pre></td></tr></table></figure></p>
<p>上面的计算属性就可以改成:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodoCount() &#123;</div><div class="line">        return this.$store.getters.doneTodoCount</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><p>同 state 的 mapState 类似, getters 也有 mapGetters 来简化计算属性的定义<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; mapGetters &#125; from 'vuex'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  computed: &#123;</div><div class="line">    // mix the getters into computed with object spread operator</div><div class="line">    ...mapGetters([</div><div class="line">      'doneTodosCount',</div><div class="line">      'anotherGetter',</div><div class="line">      // ...</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用对象可以自定义对应关系<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mapGetters(&#123;</div><div class="line">  // map this.doneCount to store.getters.doneTodosCount</div><div class="line">  doneCount: 'doneTodosCount'</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>Vuex 中的 state 只能通过 mutations 来改变. mutations 很像事件, 都有一个类型和处理函数. 处理函数是真正改变 state 的地方, 并以 state 作为第一个参数.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: 1</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      // 改变 state</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>就是事件一样, 我们不能直接调用处理函数, 而是要通过 store.commit(type) 来触发 mutation 处理函数.</p>
<p>store.commit(‘increment’)<br>带 playload commit</p>
<p>我们可以将处理函数的参数放到第二个参数 playload 中:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  increment (state, payload) &#123;</div><div class="line">    state.count += payload.amount</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit('increment', &#123;amount: 10&#125;)</div><div class="line">对象风格 commit</div><div class="line"></div><div class="line">store.commit(&#123;</div><div class="line">    type: 'increment',</div><div class="line">    playload: &#123; amount: 10 &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="静默模式"><a href="#静默模式" class="headerlink" title="静默模式"></a>静默模式</h3><p>默认情况下, 每一次 commit 都会发送到插件 (比如: devtools) 中. 可能你会希望某些 commit 不被记录. 这时候可以传递第三个参数以设置为静默模式:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">store.commit('increment', &#123;</div><div class="line">  amount: 1</div><div class="line">&#125;, &#123; silent: true &#125;)</div><div class="line"></div><div class="line">// 对象风格 commit</div><div class="line">store.commit(&#123;</div><div class="line">  type: 'increment',</div><div class="line">  amount: 1</div><div class="line">&#125;, &#123; silent: true &#125;)</div></pre></td></tr></table></figure></p>
<p>Mutations 要遵守 Vue 的响应式规则</p>
<p>即:</p>
<p>提前初始化所有的状态值<br>添加新的属性到对象时, 你应该:<br>使用 Vue.set(obj, ‘newProp’, 123) 或<br>直接替换新的对象: state.obj = {…state.obj, newProp: 123}<br>使用常量为 Mutations 命名</p>
<p>使用常量为 Mutations 命名是各种 Flux 实现常用的模式. 将所有常量放到一个文件中, 我们能看到整个程序有什么情况数据会发生变化.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// mutation-types.js</div><div class="line">export const SOME_MUTATION = 'SOME_MUTATION'</div><div class="line"></div><div class="line">// store.js</div><div class="line">import Vuex from 'vuex'</div><div class="line">import &#123; SOME_MUTATION &#125; from './mutation-types'</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    // es6 特性 computed property name</div><div class="line">    // 属性名称运行时确定</div><div class="line">    [SOME_MUTATION] (state) &#123;</div><div class="line">      // mutate state</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="Mutations-必须是同步的"><a href="#Mutations-必须是同步的" class="headerlink" title="Mutations 必须是同步的"></a>Mutations 必须是同步的</h3><p>异步 mutations 调用违反了所有的状态变化必须在 store 中进行的规定. 比如:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  someMutation (state) &#123;</div><div class="line">    api.callAsyncMethod(() =&gt; &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上例中状态变化时, someMutation 已经结束了. 这时候如果有其他状态变化的操作发生, devtools 记录下来的状态变化就是错误的.</p>
<h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>我们可以通过 this.$store.commit(‘xxx’) 在组件中调用 mutations, 一般我们将这些调用分装到 methods 中, 同时 Vuex 也提供了 mapMutations 函数简化 methods 定义:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; mapMutations &#125; from 'vuex'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      'increment' // 映射 this.increment() 到 this.$store.commit('increment')</div><div class="line">    ]),</div><div class="line">    ...mapMutations(&#123;</div><div class="line">      add: 'increment' // map this.add() to this.$store.commit('increment')</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>异步的 mutations 使程序的状态变化难以追踪. 为了解决异步操作, Vuex 引入了 actions.<br>actions 跟 mutations 非常像, 它们的不同之处在于:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">actions 不改变 state, 而是 commit mutations</div><div class="line">actions 可以包含任意的异步操作</div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: 0</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    increment (context) &#123;</div><div class="line">      context.commit('increment')</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>actions 接收一个 context 对象作为参数, context 可以访问 commit, getters, state, 但是它不是 store 对象.<br>通常, 我们会使用 es6 的参数结构语法来简化代码:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    increment(&#123;commit&#125;) &#123;</div><div class="line">        commit('increment')</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Dispatching-Actions"><a href="#Dispatching-Actions" class="headerlink" title="Dispatching Actions"></a>Dispatching Actions</h3><p>actions 通过 store.dispatch 来触发:</p>
<p>store.dispatch(‘increment’)<br>dispatch 也支持 commit 中的 playload 参数以及对象风格的调用方式.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// dispatch with a payload</div><div class="line">store.dispatch('incrementAsync', &#123;</div><div class="line">  amount: 10</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// dispatch with an object</div><div class="line">store.dispatch(&#123;</div><div class="line">  type: 'incrementAsync',</div><div class="line">  amount: 10</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><p>类似 mapMutations</p>
<p>Actions 组合</p>
<p>actions 通常是异步的, 我们怎么来组合多个 actions 来执行复杂的操作?</p>
<p>首先我们需要知道的是 store.dispatch 返回 actions 中处理函数的返回值, 因此我们可以返回一个 Promise:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  actionA (&#123; commit &#125;) &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        commit('someMutation')</div><div class="line">        resolve()</div><div class="line">      &#125;, 1000)</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    // 组合</div><div class="line">    return dispatch('actionA').then(() =&gt; &#123;</div><div class="line">      commit('someOtherMutation')</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">使用 async/await 语法, 可以简化为:</div><div class="line"></div><div class="line">// 假设 getData() 和 getOtherData() 返回 Promises</div><div class="line"></div><div class="line">actions: &#123;</div><div class="line">  async actionA (&#123; commit &#125;) &#123;</div><div class="line">    commit('gotData', await getData())</div><div class="line">  &#125;,</div><div class="line">  async actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    await dispatch('actionA') // wait for actionA to finish</div><div class="line">    commit('gotOtherData', await getOtherData())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>当我们的程序足够大时, store 也会变得非常大, 其中的 state, getters, mutations, actions 也会非常大.</p>
<p>因此 Vuex 允许我们将 store 分成几个 modules, 每个 modules 都有自己的 state, getters, mutations, actions 甚至它自己的 modules.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;,</div><div class="line">  getters: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const moduleB = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    a: moduleA,</div><div class="line">    b: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.state.a // -&gt; moduleA's state</div><div class="line">store.state.b // -&gt; moduleB's state</div></pre></td></tr></table></figure></p>
<h3 id="Modules-当前状态"><a href="#Modules-当前状态" class="headerlink" title="Modules 当前状态"></a>Modules 当前状态</h3><p>在 modules 中, getters 和 mutations 的第一个参数都是 modules 的 state, 同样 actions 的 context.state 也是 modules 的 state, 根节点的状态可以通过 context.rootState 访问到. getters 的可以通过第三个参数访问 $rootState:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  // ...</div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      return state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###　命名空间</p>
<p>modules 的 state 放到根节点的对应的属性中, 而 actions, mutations 和 getters 没有命名空间. 所以多个 modules 可以对同一个 commit 或 dispatch 做响应. 因此必须自己通过前缀或后缀来避免命名冲突.</p>
<p>动态 Modules 注册<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.registerModule('myModule', &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div><div class="line">keep learning</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我会把我做关于模仿微博的这个项目遇到的一些问题公开在这里，遇到不对的地方请指教，发送&lt;a href=&quot;https://www.wang1348168417@gmail.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;邮件wang1348168417@gmail.com&lt;/a&gt;，或者扫我的微信二维码。&lt;br&gt;一个简单的状态管理&lt;/p&gt;
&lt;h3 id=&quot;单一数据源&quot;&gt;&lt;a href=&quot;#单一数据源&quot; class=&quot;headerlink&quot; title=&quot;单一数据源:&quot;&gt;&lt;/a&gt;单一数据源:&lt;/h3&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;const sourceOfTruth = &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;const vmA = new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  data: sourceOfTruth&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;const vmB = new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  data: sourceOfTruth&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每当 sourceOfTruth 发生变化, vmA 和 vmB 都会自动更新它们的视图. 子组件可以通过 this.$root.$data 访问数据. 现在我们有了单一的数据源, 但是调试会很困难. 因为无论何时数据源发生变化都会改变程序, 但是没有任何迹象表明变化发生.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Es6新特性</title>
    <link href="http://yoursite.com/2017/04/18/Es6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/04/18/Es6新特性/</id>
    <published>2017-04-18T07:36:32.000Z</published>
    <updated>2017-05-16T03:24:10.644Z</updated>
    
    <content type="html"><![CDATA[<p>####ECMAScript 6简介</p>
<p>###1.Class基本语法</p>
<p>##概述<br>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x;</div><div class="line">  <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。</p>
<p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6的类，完全可以看作构造函数的另一种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></div><div class="line">Point === Point.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">  doStuff() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar();</div><div class="line">b.doStuff() <span class="comment">// "stuff"</span></div></pre></td></tr></table></figure></p>
<p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toValue()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">Point.prototype = &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div><div class="line"></div><div class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;);</div><div class="line">prototype对象的<span class="keyword">constructor</span>属性，直接指向“类”的本身，这与ES5的行为是一致的。</div><div class="line"></div><div class="line">Point.prototype.<span class="keyword">constructor</span> === Point // true</div></pre></td></tr></table></figure></p>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<p>class Point {<br>  constructor(x, y) {<br>    // …<br>  }</p>
<p>  toString() {<br>    // …<br>  }<br>}</p>
<p>Object.keys(Point.prototype)<br>// []<br>Object.getOwnPropertyNames(Point.prototype)<br>// [“constructor”,”toString”]</p>
<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>
<p>var Point = function (x, y) {<br>  // …<br>};</p>
<p>Point.prototype.toString = function() {<br>  // …<br>};</p>
<p>Object.keys(Point.prototype)<br>// [“toString”]<br>Object.getOwnPropertyNames(Point.prototype)<br>// [“constructor”,”toString”]</p>
<p>上面代码采用ES5的写法，toString方法就是可枚举的。</p>
<p>类的属性名，可以采用表达式。</p>
<p>let methodName = “getArea”;<br>class Square{<br>  constructor(length) {<br>    // …<br>  }</p>
<p>  <a href="">methodName</a> {<br>    // …<br>  }<br>}</p>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<p>constructor方法<br>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<p>constructor() {}<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<p>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}</p>
<p>new Foo() instanceof Foo<br>// false</p>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<p>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}</p>
<p>Foo()<br>// TypeError: Class constructor Foo cannot be invoked without ‘new’</p>
<p>类的实例对象<br>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p>
<p>// 报错<br>var point = Point(2, 3);</p>
<p>// 正确<br>var point = new Point(2, 3);</p>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<p>//定义类<br>class Point {</p>
<p>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }</p>
<p>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }</p>
<p>}</p>
<p>var point = new Point(2, 3);</p>
<p>point.toString() // (2, 3)</p>
<p>point.hasOwnProperty(‘x’) // true<br>point.hasOwnProperty(‘y’) // true<br>point.hasOwnProperty(‘toString’) // false<br>point.<strong>proto</strong>.hasOwnProperty(‘toString’) // true</p>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。</p>
<p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p>
<p>p1.<strong>proto</strong> === p2.<strong>proto</strong><br>//true</p>
<p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以<strong>proto</strong>属性是相等的。</p>
<p>这也意味着，可以通过实例的<strong>proto</strong>属性为Class添加方法。</p>
<p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p>
<p>p1.<strong>proto</strong>.printName = function () { return ‘Oops’ };</p>
<p>p1.printName() // “Oops”<br>p2.printName() // “Oops”</p>
<p>var p3 = new Point(4,2);<br>p3.printName() // “Oops”</p>
<p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的<strong>proto</strong>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p>
<p>不存在变量提升<br>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<p>new Foo(); // ReferenceError<br>class Foo {}<br>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p>{<br>  let Foo = class {};<br>  class Bar extends Foo {<br>  }<br>}<br>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p>
<p>Class表达式<br>与函数一样，类也可以使用表达式的形式定义。</p>
<p>const MyClass = class Me {<br>  getClassName() {<br>    return Me.name;<br>  }<br>};<br>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<p>let inst = new MyClass();<br>inst.getClassName() // Me<br>Me.name // ReferenceError: Me is not defined<br>上面代码表示，Me只在Class内部有定义。</p>
<p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p>
<p>const MyClass = class { /<em> … </em>/ };<br>采用Class表达式，可以写出立即执行的Class。</p>
<p>let person = new class {<br>  constructor(name) {<br>    this.name = name;<br>  }</p>
<p>  sayName() {<br>    console.log(this.name);<br>  }<br>}(‘张三’);</p>
<p>person.sayName(); // “张三”<br>上面代码中，person是一个立即执行的类的实例。</p>
<p>私有方法<br>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<p>class Widget {</p>
<p>  // 公有方法<br>  foo (baz) {<br>    this._bar(baz);<br>  }</p>
<p>  // 私有方法<br>  _bar(baz) {<br>    return this.snaf = baz;<br>  }</p>
<p>  // …<br>}<br>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<p>class Widget {<br>  foo (baz) {<br>    bar.call(this, baz);<br>  }</p>
<p>  // …<br>}</p>
<p>function bar(baz) {<br>  return this.snaf = baz;<br>}<br>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</p>
<p>const bar = Symbol(‘bar’);<br>const snaf = Symbol(‘snaf’);</p>
<p>export default class myClass{</p>
<p>  // 公有方法<br>  foo(baz) {<br>    this<a href="baz">bar</a>;<br>  }</p>
<p>  // 私有方法<br>  <a href="baz">bar</a> {<br>    return this[snaf] = baz;<br>  }</p>
<p>  // …<br>};<br>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<p>this的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<p>class Logger {<br>  printName(name = ‘there’) {<br>    this.print(<code>Hello ${name}</code>);<br>  }</p>
<p>  print(text) {<br>    console.log(text);<br>  }<br>}</p>
<p>const logger = new Logger();<br>const { printName } = logger;<br>printName(); // TypeError: Cannot read property ‘print’ of undefined<br>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p>
<p>class Logger {<br>  constructor() {<br>    this.printName = this.printName.bind(this);<br>  }</p>
<p>  // …<br>}<br>另一种解决方法是使用箭头函数。</p>
<p>class Logger {<br>  constructor() {<br>    this.printName = (name = ‘there’) =&gt; {<br>      this.print(<code>Hello ${name}</code>);<br>    };<br>  }</p>
<p>  // …<br>}<br>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p>
<p>function selfish (target) {<br>  const cache = new WeakMap();<br>  const handler = {<br>    get (target, key) {<br>      const value = Reflect.get(target, key);<br>      if (typeof value !== ‘function’) {<br>        return value;<br>      }<br>      if (!cache.has(value)) {<br>        cache.set(value, value.bind(target));<br>      }<br>      return cache.get(value);<br>    }<br>  };<br>  const proxy = new Proxy(target, handler);<br>  return proxy;<br>}</p>
<p>const logger = selfish(new Logger());<br>严格模式<br>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<p>name属性<br>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<p>class Point {}<br>Point.name // “Point”<br>name属性总是返回紧跟在class关键字后面的类名。</p>
<p>Class的继承<br>基本用法<br>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<p>class ColorPoint extends Point {}<br>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p>
<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); // 调用父类的constructor(x, y)<br>    this.color = color;<br>  }</p>
<p>  toString() {<br>    return this.color + ‘ ‘ + super.toString(); // 调用父类的toString()<br>  }<br>}<br>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>class Point { /<em> … </em>/ }</p>
<p>class ColorPoint extends Point {<br>  constructor() {<br>  }<br>}</p>
<p>let cp = new ColorPoint(); // ReferenceError<br>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</p>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<p>constructor(…args) {<br>  super(…args);<br>}<br>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<p>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>}</p>
<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    this.color = color; // ReferenceError<br>    super(x, y);<br>    this.color = color; // 正确<br>  }<br>}<br>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p>
<p>下面是生成子类实例的代码。</p>
<p>let cp = new ColorPoint(25, 8, ‘green’);</p>
<p>cp instanceof ColorPoint // true<br>cp instanceof Point // true<br>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p>
<p>类的prototype属性和<strong>proto</strong>属性<br>大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</p>
<p>class A {<br>}</p>
<p>class B extends A {<br>}</p>
<p>B.<strong>proto</strong> === A // true<br>B.prototype.<strong>proto</strong> === A.prototype // true<br>上面代码中，子类B的<strong>proto</strong>属性指向父类A，子类B的prototype属性的<strong>proto</strong>属性指向父类A的prototype属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<p>class A {<br>}</p>
<p>class B {<br>}</p>
<p>// B的实例继承A的实例<br>Object.setPrototypeOf(B.prototype, A.prototype);<br>const b = new B();</p>
<p>// B的实例继承A的静态属性<br>Object.setPrototypeOf(B, A);<br>const b = new B();<br>《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。</p>
<p>Object.setPrototypeOf = function (obj, proto) {<br>  obj.<strong>proto</strong> = proto;<br>  return obj;<br>}<br>因此，就得到了上面的结果。</p>
<p>Object.setPrototypeOf(B.prototype, A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;</p>
<p>Object.setPrototypeOf(B, A);<br>// 等同于<br>B.<strong>proto</strong> = A;<br>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</p>
<p>Object.create(A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;<br>Extends 的继承目标<br>extends关键字后面可以跟多种类型的值。</p>
<p>class B extends A {<br>}<br>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</p>
<p>下面，讨论三种特殊情况。</p>
<p>第一种特殊情况，子类继承Object类。</p>
<p>class A extends Object {<br>}</p>
<p>A.<strong>proto</strong> === Object // true<br>A.prototype.<strong>proto</strong> === Object.prototype // true<br>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p>
<p>第二种特殊情况，不存在任何继承。</p>
<p>class A {<br>}</p>
<p>A.<strong>proto</strong> === Function.prototype // true<br>A.prototype.<strong>proto</strong> === Object.prototype // true<br>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.<strong>proto</strong>指向构造函数（Object）的prototype属性。</p>
<p>第三种特殊情况，子类继承null。</p>
<p>class A extends null {<br>}</p>
<p>A.<strong>proto</strong> === Function.prototype // true<br>A.prototype.<strong>proto</strong> === undefined // true<br>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的<strong>proto</strong>指向Function.prototype，即实质上执行了下面的代码。</p>
<p>class C extends null {<br>  constructor() { return Object.create(null); }<br>}<br>Object.getPrototypeOf()<br>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<p>Object.getPrototypeOf(ColorPoint) === Point<br>// true<br>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<p>super 关键字<br>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
<p>class A {<br>  constructor() {<br>    console.log(new.target.name);<br>  }<br>}<br>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>new A() // A<br>new B() // B<br>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</p>
<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  m() {<br>    super(); // 报错<br>  }<br>}<br>上面代码中，super()用在B类的m方法之中，就会造成句法错误。</p>
<p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<p>class A {<br>  p() {<br>    return 2;<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.p()); // 2<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</p>
<p>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>
<p>class A {<br>  constructor() {<br>    this.p = 2;<br>  }<br>}</p>
<p>class B extends A {<br>  get m() {<br>    return super.p;<br>  }<br>}</p>
<p>let b = new B();<br>b.m // undefined<br>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，super就可以取到。</p>
<p>class A {}<br>A.prototype.x = 2;</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.x) // 2<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。</p>
<p>ES6 规定，通过super调用父类的方法时，super会绑定子类的this。</p>
<p>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>  print() {<br>    console.log(this.x);<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>  }<br>  m() {<br>    super.print();<br>  }<br>}</p>
<p>let b = new B();<br>b.m() // 2<br>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</p>
<p>由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>
<p>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>    super.x = 3;<br>    console.log(super.x); // undefined<br>    console.log(this.x); // 3<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p>
<p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>
<p>class Parent {<br>  static myMethod(msg) {<br>    console.log(‘static’, msg);<br>  }</p>
<p>  myMethod(msg) {<br>    console.log(‘instance’, msg);<br>  }<br>}</p>
<p>class Child extends Parent {<br>  static myMethod(msg) {<br>    super.myMethod(msg);<br>  }</p>
<p>  myMethod(msg) {<br>    super.myMethod(msg);<br>  }<br>}</p>
<p>Child.myMethod(1); // static 1</p>
<p>var child = new Child();<br>child.myMethod(2); // instance 2<br>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super); // 报错<br>  }<br>}<br>上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</p>
<p>class A {}</p>
<p>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.valueOf() instanceof B); // true<br>  }<br>}</p>
<p>let b = new B();<br>上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
<p>var obj = {<br>  toString() {<br>    return “MyObject: “ + super.toString();<br>  }<br>};</p>
<p>obj.toString(); // MyObject: [object Object]<br>实例的<strong>proto</strong>属性<br>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<p>var p1 = new Point(2, 3);<br>var p2 = new ColorPoint(2, 3, ‘red’);</p>
<p>p2.<strong>proto</strong> === p1.<strong>proto</strong> // false<br>p2.<strong>proto</strong>.<strong>proto</strong> === p1.<strong>proto</strong> // true<br>上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。</p>
<p>p2.<strong>proto</strong>.<strong>proto</strong>.printName = function () {<br>  console.log(‘Ha’);<br>};</p>
<p>p1.printName() // “Ha”<br>上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</p>
<p>原生构造函数的继承<br>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p>
<p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()<br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。</p>
<p>function MyArray() {<br>  Array.apply(this, arguments);<br>}</p>
<p>MyArray.prototype = Object.create(Array.prototype, {<br>  constructor: {<br>    value: MyArray,<br>    writable: true,<br>    configurable: true,<br>    enumerable: true<br>  }<br>});<br>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p>
<p>var colors = new MyArray();<br>colors[0] = “red”;<br>colors.length  // 0</p>
<p>colors.length = 0;<br>colors[0]  // “red”<br>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>
<p>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承Error对象。</p>
<p>var e = {};</p>
<p>Object.getOwnPropertyNames(Error.call(e))<br>// [ ‘stack’ ]</p>
<p>Object.getOwnPropertyNames(e)<br>// []<br>上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<p>class MyArray extends Array {<br>  constructor(…args) {<br>    super(…args);<br>  }<br>}</p>
<p>var arr = new MyArray();<br>arr[0] = 12;<br>arr.length // 1</p>
<p>arr.length = 0;<br>arr[0] // undefined<br>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p>
<p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<p>class VersionedArray extends Array {<br>  constructor() {<br>    super();<br>    this.history = [[]];<br>  }<br>  commit() {<br>    this.history.push(this.slice());<br>  }<br>  revert() {<br>    this.splice(0, this.length, …this.history[this.history.length - 1]);<br>  }<br>}</p>
<p>var x = new VersionedArray();</p>
<p>x.push(1);<br>x.push(2);<br>x // [1, 2]<br>x.history // [[]]</p>
<p>x.commit();<br>x.history // [[], [1, 2]]<br>x.push(3);<br>x // [1, 2, 3]</p>
<p>x.revert();<br>x // [1, 2]<br>上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义Error子类的例子。</p>
<p>class ExtendableError extends Error {<br>  constructor(message) {<br>    super();<br>    this.message = message;<br>    this.stack = (new Error()).stack;<br>    this.name = this.constructor.name;<br>  }<br>}</p>
<p>class MyError extends ExtendableError {<br>  constructor(m) {<br>    super(m);<br>  }<br>}</p>
<p>var myerror = new MyError(‘ll’);<br>myerror.message // “ll”<br>myerror instanceof Error // true<br>myerror.name // “MyError”<br>myerror.stack<br>// Error<br>//     at MyError.ExtendableError<br>//     …<br>注意，继承Object的子类，有一个行为差异。</p>
<p>class NewObj extends Object{<br>  constructor(){<br>    super(…arguments);<br>  }<br>}<br>var o = new NewObj({attr: true});<br>console.log(o.attr === true);  // false<br>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。</p>
<p>Class的取值函数（getter）和存值函数（setter）<br>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<p>class MyClass {<br>  constructor() {<br>    // …<br>  }<br>  get prop() {<br>    return ‘getter’;<br>  }<br>  set prop(value) {<br>    console.log(‘setter: ‘+value);<br>  }<br>}</p>
<p>let inst = new MyClass();</p>
<p>inst.prop = 123;<br>// setter: 123</p>
<p>inst.prop<br>// ‘getter’<br>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>
<p>class CustomHTMLElement {<br>  constructor(element) {<br>    this.element = element;<br>  }</p>
<p>  get html() {<br>    return this.element.innerHTML;<br>  }</p>
<p>  set html(value) {<br>    this.element.innerHTML = value;<br>  }<br>}</p>
<p>var descriptor = Object.getOwnPropertyDescriptor(<br>  CustomHTMLElement.prototype, “html”);<br>“get” in descriptor  // true<br>“set” in descriptor  // true<br>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>
<p>Class 的 Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<p>class Foo {<br>  constructor(…args) {<br>    this.args = args;<br>  }</p>
<ul>
<li><a href="">Symbol.iterator</a> {<br>for (let arg of this.args) {<br>  yield arg;<br>}<br>}<br>}</li>
</ul>
<p>for (let x of new Foo(‘hello’, ‘world’)) {<br>  console.log(x);<br>}<br>// hello<br>// world<br>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。</p>
<p>Class 的静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>Foo.classMethod() // ‘hello’</p>
<p>var foo = new Foo();<br>foo.classMethod()<br>// TypeError: foo.classMethod is not a function<br>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>父类的静态方法，可以被子类继承。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>class Bar extends Foo {<br>}</p>
<p>Bar.classMethod(); // ‘hello’<br>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p>
<p>静态方法也是可以从super对象上调用的。</p>
<p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p>
<p>class Bar extends Foo {<br>  static classMethod() {<br>    return super.classMethod() + ‘, too’;<br>  }<br>}</p>
<p>Bar.classMethod();<br>Class的静态属性和实例属性<br>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<p>class Foo {<br>}</p>
<p>Foo.prop = 1;<br>Foo.prop // 1<br>上面的写法为Foo类定义了一个静态属性prop。</p>
<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<p>// 以下两种写法都无效<br>class Foo {<br>  // 写法一<br>  prop: 2</p>
<p>  // 写法二<br>  static prop: 2<br>}</p>
<p>Foo.prop // undefined<br>ES7有一个静态属性的提案，目前Babel转码器支持。</p>
<p>这个提案对实例属性和静态属性，都规定了新的写法。</p>
<p>（1）类的实例属性</p>
<p>类的实例属性可以用等式，写入类的定义之中。</p>
<p>class MyClass {<br>  myProp = 42;</p>
<p>  constructor() {<br>    console.log(this.myProp); // 42<br>  }<br>}<br>上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。</p>
<p>以前，我们定义实例属性，只能写在类的constructor方法里面。</p>
<p>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>}<br>上面代码中，构造方法constructor里面，定义了this.state属性。</p>
<p>有了新的写法以后，可以不在constructor方法里面定义。</p>
<p>class ReactCounter extends React.Component {<br>  state = {<br>    count: 0<br>  };<br>}<br>这种写法比以前更清晰。</p>
<p>为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</p>
<p>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>  state;<br>}<br>（2）类的静态属性</p>
<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>
<p>class MyClass {<br>  static myStaticProp = 42;</p>
<p>  constructor() {<br>    console.log(MyClass.myStaticProp); // 42<br>  }<br>}<br>同样的，这个新写法大大方便了静态属性的表达。</p>
<p>// 老写法<br>class Foo {<br>}<br>Foo.prop = 1;</p>
<p>// 新写法<br>class Foo {<br>  static prop = 1;<br>}<br>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<p>类的私有属性<br>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。</p>
<p>class Point {</p>
<p>  #x;</p>
<p>  constructor(x = 0) {</p>
<pre><code>#x = +x;
</code></pre><p>  }</p>
<p>  get x() { return #x }<br>  set x(value) { #x = +value }<br>}<br>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p>
<p>私有属性可以指定初始值，在构造函数执行时进行初始化。</p>
<p>class Point {</p>
<p>  #x = 0;<br>  constructor() {</p>
<pre><code>#x; // 0
</code></pre><p>  }<br>}<br>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。</p>
<p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。</p>
<p>class Foo {</p>
<p>  #a;</p>
<p>  #b;</p>
<p>  #sum() { return #a + #b; }<br>  printSum() { console.log(#sum()); }<br>  constructor(a, b) { #a = a; #b = b; }<br>}<br>new.target属性<br>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<p>function Person(name) {<br>  if (new.target !== undefined) {<br>    this.name = name;<br>  } else {<br>    throw new Error(‘必须使用new生成实例’);<br>  }<br>}</p>
<p>// 另一种写法<br>function Person(name) {<br>  if (new.target === Person) {<br>    this.name = name;<br>  } else {<br>    throw new Error(‘必须使用new生成实例’);<br>  }<br>}</p>
<p>var person = new Person(‘张三’); // 正确<br>var notAPerson = Person.call(person, ‘张三’);  // 报错<br>上面代码确保构造函数只能通过new命令调用。</p>
<p>Class内部调用new.target，返回当前Class。</p>
<p>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    this.length = length;<br>    this.width = width;<br>  }<br>}</p>
<p>var obj = new Rectangle(3, 4); // 输出 true<br>需要注意的是，子类继承父类时，new.target会返回子类。</p>
<p>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    // …<br>  }<br>}</p>
<p>class Square extends Rectangle {<br>  constructor(length) {<br>    super(length, length);<br>  }<br>}</p>
<p>var obj = new Square(3); // 输出 false<br>上面代码中，new.target会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<p>class Shape {<br>  constructor() {<br>    if (new.target === Shape) {<br>      throw new Error(‘本类不能实例化’);<br>    }<br>  }<br>}</p>
<p>class Rectangle extends Shape {<br>  constructor(length, width) {<br>    super();<br>    // …<br>  }<br>}</p>
<p>var x = new Shape();  // 报错<br>var y = new Rectangle(3, 4);  // 正确<br>上面代码中，Shape类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用new.target会报错。</p>
<p>Mixin模式的实现<br>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p>
<p>function mix(…mixins) {<br>  class Mix {}</p>
<p>  for (let mixin of mixins) {<br>    copyProperties(Mix, mixin);<br>    copyProperties(Mix.prototype, mixin.prototype);<br>  }</p>
<p>  return Mix;<br>}</p>
<p>function copyProperties(target, source) {<br>  for (let key of Reflect.ownKeys(source)) {<br>    if ( key !== “constructor”<br>      &amp;&amp; key !== “prototype”<br>      &amp;&amp; key !== “name”<br>    ) {<br>      let desc = Object.getOwnPropertyDescriptor(source, key);<br>      Object.defineProperty(target, key, desc);<br>    }<br>  }<br>}<br>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<p>class DistributedEdit extends mix(Loggable, Serializable) {<br>  // …<br>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####ECMAScript 6简介&lt;/p&gt;
&lt;p&gt;###1.Class基本语法&lt;/p&gt;
&lt;p&gt;##概述&lt;br&gt;JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Point.prototype.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;(&#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&#39;, &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&#39;)&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。&lt;/p&gt;
&lt;p&gt;ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>yilia配置</title>
    <link href="http://yoursite.com/2017/04/11/yilia%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/04/11/yilia配置/</id>
    <published>2017-04-11T02:41:53.000Z</published>
    <updated>2017-05-16T03:23:52.809Z</updated>
    
    <content type="html"><![CDATA[<p>主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>menu:<br>  主页: /<br>  随笔: /tags/随笔/</p>
<h1 id="SubNav"><a href="#SubNav" class="headerlink" title="SubNav"></a>SubNav</h1><p>subnav:<br>  github: “#”<br>  weibo: “#”<br>  rss: “#”<a id="more"></a><br>  zhihu: “#”</p>
<p>  #qq: “#”</p>
<p>  #weixin: “#”</p>
<p>  #jianshu: “#”</p>
<p>  #douban: “#”</p>
<p>  #segmentfault: “#”</p>
<p>  #bilibili: “#”</p>
<p>  #acfun: “#”</p>
<p>  #mail: “mailto:litten225@qq.com”</p>
<p>  #facebook: “#”</p>
<p>  #google: “#”</p>
<p>  #twitter: “#”</p>
<p>  #linkedin: “#”</p>
<p>rss: /atom.xml</p>
<h1 id="是否需要修改-root-路径"><a href="#是否需要修改-root-路径" class="headerlink" title="是否需要修改 root 路径"></a>是否需要修改 root 路径</h1><h1 id="如果您的网站存放在子目录中，例如-http-yoursite-com-blog，"><a href="#如果您的网站存放在子目录中，例如-http-yoursite-com-blog，" class="headerlink" title="如果您的网站存放在子目录中，例如 http://yoursite.com/blog，"></a>如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，">http://yoursite.com/blog，</a></h1><h1 id="请将您的-url-设为-http-yoursite-com-blog-并把-root-设为-blog-。"><a href="#请将您的-url-设为-http-yoursite-com-blog-并把-root-设为-blog-。" class="headerlink" title="请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。"></a>请将您的 url 设为 <a href="http://yoursite.com/blog">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</h1><p>root: </p>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h1 id="文章太长，截断按钮文字"><a href="#文章太长，截断按钮文字" class="headerlink" title="文章太长，截断按钮文字"></a>文章太长，截断按钮文字</h1><p>excerpt_link: more</p>
<h1 id="文章卡片右下角常驻链接，不需要请设置为false"><a href="#文章卡片右下角常驻链接，不需要请设置为false" class="headerlink" title="文章卡片右下角常驻链接，不需要请设置为false"></a>文章卡片右下角常驻链接，不需要请设置为false</h1><p>show_all_link: ‘展开全文’</p>
<h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>mathjax: false</p>
<h1 id="是否在新窗口打开链接"><a href="#是否在新窗口打开链接" class="headerlink" title="是否在新窗口打开链接"></a>是否在新窗口打开链接</h1><p>open_in_new: false</p>
<h1 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h1><h1 id="请在需要打赏的文章的md文件头部，设置属性reward-true"><a href="#请在需要打赏的文章的md文件头部，设置属性reward-true" class="headerlink" title="请在需要打赏的文章的md文件头部，设置属性reward: true"></a>请在需要打赏的文章的md文件头部，设置属性reward: true</h1><h1 id="打赏基础设定：0-关闭打赏；-1-文章对应的md文件里有reward-true属性，才有打赏；-2-所有文章均有打赏"><a href="#打赏基础设定：0-关闭打赏；-1-文章对应的md文件里有reward-true属性，才有打赏；-2-所有文章均有打赏" class="headerlink" title="打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏"></a>打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</h1><p>reward_type: 2</p>
<h1 id="打赏wording"><a href="#打赏wording" class="headerlink" title="打赏wording"></a>打赏wording</h1><p>reward_wording: ‘谢谢你请我吃糖果’</p>
<h1 id="支付宝二维码图片地址，跟你设置头像的方式一样。比如：-assets-img-alipay-jpg"><a href="#支付宝二维码图片地址，跟你设置头像的方式一样。比如：-assets-img-alipay-jpg" class="headerlink" title="支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg"></a>支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</h1><p>alipay: </p>
<h1 id="微信二维码图片地址"><a href="#微信二维码图片地址" class="headerlink" title="微信二维码图片地址"></a>微信二维码图片地址</h1><p>weixin: </p>
<h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><p>baidu_analytics: ‘’<br>google_analytics: ‘’<br>favicon: /favicon.png</p>
<p>#你的头像url<br>avatar:</p>
<p>#是否开启分享<br>share_jia: true</p>
<p>#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key</p>
<p>#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论<br>duoshuo: false</p>
<h1 id="样式定制-一般不需要修改，除非有很强的定制欲望…"><a href="#样式定制-一般不需要修改，除非有很强的定制欲望…" class="headerlink" title="样式定制 - 一般不需要修改，除非有很强的定制欲望…"></a>样式定制 - 一般不需要修改，除非有很强的定制欲望…</h1><p>style:</p>
<h1 id="头像上面的背景颜色"><a href="#头像上面的背景颜色" class="headerlink" title="头像上面的背景颜色"></a>头像上面的背景颜色</h1><p>  header: ‘#4d4d4d’</p>
<h1 id="右滑板块背景"><a href="#右滑板块背景" class="headerlink" title="右滑板块背景"></a>右滑板块背景</h1><p>  slider: ‘linear-gradient(200deg,#a0cfe4,#e8c37e)’</p>
<h1 id="slider的设置"><a href="#slider的设置" class="headerlink" title="slider的设置"></a>slider的设置</h1><p>slider:</p>
<h1 id="是否默认展开tags板块"><a href="#是否默认展开tags板块" class="headerlink" title="是否默认展开tags板块"></a>是否默认展开tags板块</h1><p>  showTags: false</p>
<h1 id="智能菜单"><a href="#智能菜单" class="headerlink" title="智能菜单"></a>智能菜单</h1><h1 id="如不需要，将该对应项置为false"><a href="#如不需要，将该对应项置为false" class="headerlink" title="如不需要，将该对应项置为false"></a>如不需要，将该对应项置为false</h1><h1 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h1><p>#smart_menu:</p>
<h1 id="friends-false"><a href="#friends-false" class="headerlink" title="friends: false"></a>friends: false</h1><p>smart_menu:<br>  innerArchive: ‘所有文章’<br>  friends: ‘友链’<br>  aboutme: ‘关于我’</p>
<p>friends:<br>  友情链接1: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接2: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接3: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接4: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接5: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>  友情链接6: <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></p>
<p>aboutme: 很惭愧<br><br>只做了一点微小的工作<br>谢谢大家</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 完整配置例子，可以参考我的博客备份&lt;/p&gt;
&lt;h1 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; title=&quot;Header&quot;&gt;&lt;/a&gt;Header&lt;/h1&gt;&lt;p&gt;menu:&lt;br&gt;  主页: /&lt;br&gt;  随笔: /tags/随笔/&lt;/p&gt;
&lt;h1 id=&quot;SubNav&quot;&gt;&lt;a href=&quot;#SubNav&quot; class=&quot;headerlink&quot; title=&quot;SubNav&quot;&gt;&lt;/a&gt;SubNav&lt;/h1&gt;&lt;p&gt;subnav:&lt;br&gt;  github: “#”&lt;br&gt;  weibo: “#”&lt;br&gt;  rss: “#”
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一个博客</title>
    <link href="http://yoursite.com/2017/04/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/04/08/我的第一个博客/</id>
    <published>2017-04-08T03:11:41.000Z</published>
    <updated>2017-05-16T03:23:59.532Z</updated>
    
    <content type="html"><![CDATA[<p>您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您好！欢迎来到我的第一个博客！在这里我会展示我的学术论文以及的我的小demo，欢迎您提出宝贵的意见！&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
